import pandas as pd
import numpy as np
import os
from sklearn.neighbors import NearestNeighbors
from fink_fat.orbit_fitting.orbfit_local import prep_orbitfit
from fink_fat.orbit_fitting.orbfit_local import rm_files


from glob import glob
import signal
from astropy.time import Time
from astropy.coordinates import SkyCoord
import astropy.units as u
from shutil import rmtree
import re
import subprocess
import multiprocessing as mp

import traceback
import logging

import fink_fat.orbit_fitting.orbfit_local as ol


def write_inp(ram_dir, first_designation, second_designation):
    """
    Write the input files of Orbfit in orbit identification mode. Two designations need to be given corresponding to the both arcs.

    Parameters
    ----------
    ram_dir : string
        the path where to write the temporary file generated by orbfit.
    first_designation : string
        the provisional designation of the first arc
    second_designation : string
        the provisional designation of the second arc

    Return
    ------
    None
    """
    with open(
        ram_dir + first_designation + "_" + second_designation + ".inp", "wt"
    ) as file:
        file.write(ram_dir + first_designation + "_" + second_designation)


def write_oop(ram_dir, first_designation, second_designation):
    """
    Write the option file of OrbFit in orbit identification mode. Two designations need to be given corresponding to the both arcs.

    Parameters
    ----------
    ram_dir : string
        the path where to write the temporary file generated by orbfit.
    first_designation : string
        the provisional designation of the first arc
    second_designation : string
        the provisional designation of the second arc

    Return
    ------
    None
    """
    with open(
        ram_dir + first_designation + "_" + second_designation + ".oop", "w"
    ) as file:
        # write output options
        file.write("output.\n")
        file.write("\t.elements = 'KEP'\n")

        # write operations options
        file.write("operations.\n")
        file.write("\t.init_orbdet = 2\n")
        file.write("\t.diffcor = 2\n")
        file.write("\t.ident = 2\n")
        file.write("\t.ephem = 0\n")

        # write error model options
        file.write("error_model.\n")
        file.write("\t.name='fcct14'\n")

        # write additional options
        file.write("IERS.\n")
        file.write("\t.extrapolation = .T.\n")

        # write reject options
        file.write("reject.\n")
        file.write("\t.rejopp = .FALSE.\n")

        # write propagation options
        file.write("propag.\n")
        file.write("\t.iast = 17\n")
        file.write("\t.npoint = 600\n")
        file.write("\t.dmea = 0.2d0\n")
        file.write("\t.dter = 0.05d0\n")

        # write location files options
        file.write(".filbe=" + ram_dir + "AST17\n")
        file.write("\noutput_files.\n")
        file.write(
            "\t.elem = "
            + ram_dir
            + first_designation
            + "_"
            + second_designation
            + ".oel\n"
        )
        file.write("object1.\n")
        file.write("\t.obs_dir = " + ram_dir + "mpcobs\n")
        file.write("\t.name = " + first_designation)

        # write second object location
        file.write("\nobject2.\n")
        file.write("\t.obs_dir = " + ram_dir + "mpcobs\n")
        file.write("\t.name = " + second_designation)


def write_observation_file(ram_dir, obs_df):
    """
    Write an observation file to mpc standard from a dataframe containing all the observations of one trajectories

    Parameters
    ----------
    ram_dir : string
        the path where to write the file

    obs_df : dataframe
        the observation dataframe
        have to contains the following columns :
            ra, dec, dcmag, fid, jd, trajectory_id

    Returns
    -------
    prov_desig : string
        the provisional designation assign to the trajectory

    Examples
    --------
    >>> os.mkdir("mpcobs")
    >>> test_obs = pd.DataFrame({
    ... "ra" : [0, 1],
    ... "dec": [0, 1],
    ... "dcmag" : [17.4, 17.6],
    ... "fid": [1, 2],
    ... "jd" : [2440423.34352, 2440423.34387],
    ... "trajectory_id" : [0, 0]
    ... })

    >>> write_observation_file("", test_obs)
    'K69O00A'

    >>> filecmp.cmp("mpcobs/K69O00A.obs", "fink_fat/test/K69O00A_test.obs")
    True

    >>> shutil.rmtree("mpcobs/")
    """

    obs_df = obs_df.sort_values(["trajectory_id", "jd"])
    ra = obs_df["ra"]
    dec = obs_df["dec"]
    dcmag = obs_df["dcmag"]
    band = obs_df["fid"]
    date = obs_df["jd"]
    traj_id = obs_df["trajectory_id"].values[0]

    coord = SkyCoord(ra, dec, unit=u.degree).to_string("hmsdms")
    translation_rules = {ord(i): " " for i in "hmd"}
    translation_rules[ord("s")] = ""

    coord = [el.translate(translation_rules) for el in coord]

    coord = [
        re.sub(r"(\d+)\.(\d+)", lambda matchobj: matchobj.group()[:5], s) for s in coord
    ]

    t = Time(date.astype(np.double), format="jd")
    date = t.iso
    prov_desig = ol.make_designation(date[0], traj_id)

    date = [ol.make_date(d) for d in date]

    res = [ol.join_string([el1] + [el2], " ") for el1, el2 in zip(date, coord)]

    res = [
        "     "
        + prov_desig
        + "  C"  # how the observation was made : C means CCD
        + el
        + "         "
        + str(round(mag, 1))
        + " "
        + ol.band_to_str(b)
        + "      I41"  # ZTF observation code
        for el, mag, b in zip(res, dcmag, band)
    ]

    res[0] = res[0][:12] + "*" + res[0][13:]

    dir_path = ram_dir + "mpcobs/"
    with open(dir_path + prov_desig + ".obs", "wt") as file:
        file.write(ol.join_string(res, "\n"))

    return prov_desig


def call_orbitfit(ram_dir, first_designation, second_designation):
    """
    Call the OrbFit software in a subprocess. Kill it after 5 second if OrbFit are blocked.
    This function is for the orbit identification mode where two designations corresponding to the both arc need to be given.

    Parameters
    ----------
    ram_dir : string
        path where to write the file.
    first_designation : string
        the provisional designation of the first arc.
    second_designation : string
        the provisional designation of the second arc.

    Returns
    -------
    output : integer
        return status of the orbfit process

    Examples
    --------

    >>> call_orbitfit("fink_fat/test/call_orbfit/", "K21E00A")

    >>> os.path.exists("fink_fat/test/call_orbfit/K21E00A.oel")
    True

    >>> os.remove("fink_fat/test/call_orbfit/K21E00A.odc")
    >>> os.remove("fink_fat/test/call_orbfit/K21E00A.olg")
    >>> os.remove("fink_fat/test/call_orbfit/K21E00A.pro")
    >>> os.remove("fink_fat/test/call_orbfit/mpcobs/K21E00A.rwo")
    """
    orbitfit_path = os.path.join("~", "OrbitFit", "bin", "")
    command = (
        orbitfit_path
        + "orbfit.x < "
        + ram_dir
        + first_designation
        + "_"
        + second_designation
        + ".inp "
        + ">/dev/null 2>&1"
    )

    with subprocess.Popen(
        command, shell=True, stdout=subprocess.DEVNULL, preexec_fn=os.setsid
    ) as process:
        try:
            output = process.communicate(timeout=5)[0]
            return output
        except subprocess.TimeoutExpired:
            os.killpg(process.pid, signal.SIGINT)  # send signal to the process group
            output = process.communicate()[0]
            return output


def read_oel(ram_dir, first_desig, second_desig):
    """
    Read the .oel file return by orbfit. This file contains the orbital elements, the reference epoch of the orbit computation and
    the rms of the orbital elements

    Parameters
    ----------
    ram_dir : string
        Path where files are located
    prov_desig : string
        the provisional designation of the trajectory that triggered the OrbFit process.

    Returns
    -------
    orb_elem : integer list
        A list with the reference epoch first then the orbital elements and finally the rms.

    Examples
    --------
    >>> read_oel("fink_fat/test/call_orbfit/", "K21E00A")
    [2459274.810893373, '1.5833993623527698E+00', '0.613559993695898', '5.9440877456670', '343.7960539272898', '270.1931234374459', '333.9557366497585', -1, -1, -1, -1, -1, -1]

    >>> read_oel("", "")
    [-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]

    >>> read_oel("fink_fat/test/call_orbfit/", "K21H00A")
    [2459345.797868819, '3.1514694062448680E+00', '0.113946062348132', '1.6879159876457', '38.1016474068882', '136.1915246941109', '46.5628893357021', '7.94527E-03', '1.83696E-02', '4.77846E-02', '3.17863E-01', '1.34503E+01', '9.82298E+00']
    """
    try:
        with open(ram_dir + first_desig + "_" + second_desig + ".oel") as file:
            lines = file.readlines()

            ref_mjd = float(lines[8].strip().split()[1])
            # conversion from modified julian date to julian date
            ref_jd = ref_mjd + 2400000.5

            orb_params = " ".join(lines[7].strip().split()).split(" ")
            if len(lines) > 12:
                rms = " ".join(lines[12].strip().split()).split(" ")
            else:
                rms = [-1, -1, -1, -1, -1, -1, -1, -1]
            return [ref_jd] + orb_params[1:] + rms[2:]
    except FileNotFoundError:
        return list(np.ones(13, dtype=np.float64) * -1)
    except Exception as e:
        print("----")
        print(e)
        print()
        print("ERROR READ OEL FILE: {}".format(first_desig + "_" + second_desig))
        print()
        print(lines)
        print()
        print()
        logging.error(traceback.format_exc())
        print("----")
        return list(np.ones(13, dtype=np.float64) * -1)


def detect_ident(ram_dir, first_desig, second_desig):
    """
    Read the .olg files return by orbfit. The .olg files is the log files of OrbFit. It contains the information if the orbit identification
    have been a success and the keplerian orbital elements of the merged trajectories.

    Parameters
    ----------
    ram_dir : string
        Path where the temporary files of Orbfit are written.
    first_desig : string
        the provisional designation of the first arc.
    second_desig : string
        the provisional designation of the second arc.
    """
    try:
        with open(ram_dir + first_desig + "_" + second_desig + ".olg") as file:
            lines = file.readlines()

            try:
                for i in range(len(lines)):
                    if (
                        first_desig + "=" + second_desig in lines[i]
                        and "Differential correction" in lines[i]
                        and lines[i + 1].strip() != "FAILED"
                    ):

                        orb_res = []

                        for j in range(i + 2, i + 8):

                            numeric_const_pattern = r"""
                            [-+]? # optional sign
                            (?:
                                (?: \d* \. \d+ ) # .1 .12 .123 etc 9.1 etc 98.1 etc
                                |
                                (?: \d+ \.? ) # 1. 12. 123. etc 1 12 123 etc
                            )
                            # followed by optional exponent part if desired
                            (?: [Ee] [+-]? \d+ ) ?
                            """

                            rx = re.compile(numeric_const_pattern, re.VERBOSE)

                            get_orb_str = rx.findall(lines[j])[0]
                            orb_res.append(float(get_orb_str))

                        ref_mjd = float(rx.findall(lines[i + 8])[0])
                        # conversion from modified julian date to julian date
                        ref_jd = ref_mjd + 2400000.5

                        orb_res.append(ref_jd)
                        return orb_res
            except Exception:
                return list(np.ones(7, dtype=np.float64) * -1)

            return list(np.ones(7, dtype=np.float64) * -1)

    except FileNotFoundError:
        return list(np.ones(7, dtype=np.float64) * -1)


def parallel_merger(ram_dir, trajectory_df, orb_cand, indices):
    """
    Function used for the parallel computation of Orbfit in orbit identification mode.
    Try all the combination of trajectories return by the nearest neighbor algorithm.

    Paramters
    ---------
    ram_dir : string
        Path where the temporary files of Orbfit are written.
    trajectory_df : dataframe
        The set of observations of each trajectories
    orb_cand : dataframe
        The set of orbital elements of each trajectories
    indices : integer
        Indices of the orb_cand parameters used to recover the neighborhood of a trajectories

    Return
    ------
    res_orb : dataframe
        The results of the orbit identification. The dataframe contains the trajectories of the both arcs involved in the merge and
        the orbitals elements of the new merged trajectories.
    """
    res_orb = []

    # for each trajectories in the current chunk
    for i in range(len(indices)):
        neighbor_traj = list(orb_cand.iloc[indices[i]]["trajectory_id"])

        prep_orbitfit(ram_dir)

        first_traj = trajectory_df[trajectory_df["trajectory_id"] == neighbor_traj[0]]

        first_obj = write_observation_file(ram_dir, first_traj)

        # for each trajectories in the neighborhood of the ith trajectories
        for other_traj in neighbor_traj[1:]:

            second_traj = trajectory_df[trajectory_df["trajectory_id"] == other_traj]

            second_obj = write_observation_file(ram_dir, second_traj)

            write_inp(ram_dir, first_obj, second_obj)
            write_oop(ram_dir, first_obj, second_obj)

            call_orbitfit(ram_dir, first_obj, second_obj)

            res_orb.append(
                [neighbor_traj[0], other_traj]
                + detect_ident(ram_dir, first_obj, second_obj)
            )

        rm_files(glob.glob(os.path.join(ram_dir, "*.err")))
        rm_files(glob.glob(os.path.join(ram_dir, "*.inp")))
        rm_files(glob.glob(os.path.join(ram_dir, "*.oop")))
        rm_files(glob.glob(os.path.join(ram_dir, "*.pro")))
        rm_files(glob.glob(os.path.join(ram_dir, "*.odc")))

    return res_orb


def merge_orbit(observations, orbit_candidate, ram_dir, nb_neighbors, cpu_count):
    """
    Call OrbFit with the orbit identification mode activated.
    OrbFit is call with an observations files containing two sets of observations, one for the first orbital arcs and one for the second.
    Orbfit compute then an orbit for the two arcs and try to match a single orbit for the two arcs.
    If it succeed, this function return the orbital elements of the orbit belonging to both arcs.

    To merge all the trajectories, we should try all the trajectories combination. It means O(len(observations))^2. To reduce the computation time,
    a nearest neighbor algorithm is applied with the first three orbital elements (a, e, i) as features. Only the nearest neighborhood of a trajectories
    are tested with OrbFit.

    Parameters
    ----------
    observations : dataframe
        The observations of each trajectories
    orbit_candidate : dataframe
        The set of orbital elements of each trajectories
    ram_dir : string
        Path where the temporary files produced by orbfit are written.
    nb_neighbors : integer
        The number of trajectories in the nearest neighborhood of all trajectories. Increase this parameters will increase the computation time.
    cpu_count : integer
        The number of cpu core used for the parallel computation

    Return
    ------
    df_orb_elem : dataframe
        The set of orbital parameters of the merged trajectories. It contains also the trajectory_id of both merged trajectories.
    """
    orb_features = np.array(orbit_candidate[["a", "e", "i"]])

    nbrs = NearestNeighbors(n_neighbors=nb_neighbors, algorithm="ball_tree").fit(
        orb_features
    )

    _, indices = nbrs.kneighbors(orb_features)

    trajectory_id_chunks = np.array_split(indices, cpu_count)

    chunk_ramdir = [
        os.path.join(ram_dir, "chunkid_{}".format(chunk_id), "")
        for chunk_id in np.arange(len(trajectory_id_chunks))
    ]

    for chunk_dir in chunk_ramdir:
        os.mkdir(chunk_dir)
        prep_orbitfit(chunk_dir)

    chunks = [
        (chunk_dir, observations, orbit_candidate, tr_chunk)
        for tr_chunk, chunk_dir in zip(trajectory_id_chunks, chunk_ramdir)
        if len(tr_chunk) > 0
    ]

    pool = mp.Pool(cpu_count)

    results = pool.starmap(parallel_merger, chunks)

    for chunk_dir in chunk_ramdir:
        rmtree(chunk_dir)

    rm_files(glob.glob("*.rwo"))

    results = [el2 for el1 in results for el2 in el1]

    column_name = [
        "trajectory_id_1",
        "trajectory_id_2",
        "a",
        "e",
        "i",
        "long. node",
        "arg. peric",
        "mean anomaly",
        "ref_epoch",
    ]

    df_orb_elem = pd.DataFrame(results, columns=column_name,)

    return df_orb_elem[df_orb_elem["a"] != -1.0]


def remove_mirror(pdf):
    """
    Remove the mirror associations that can occurs in the dataframe return by the orbit identification
    - Mirrors means (A <-> B and B <-> A)

    Parameters
    ----------
    pdf : dataframe
        The dataframe return by the orbit identification where trajectory_id_1 are for the first arcs and trajectory_id_2 are for the second arcs.

    Return
    ------
    pdf : dataframe
        The mirrors associations have been removed, keep only one of them.
    """
    return pdf.loc[
        pd.DataFrame(
            np.sort(pdf[["trajectory_id_1", "trajectory_id_2"]], 1), index=pdf.index
        )
        .drop_duplicates(keep="first")
        .index
    ].sort_values(["trajectory_id_2"])


def remove_transitive(pdf):
    """
    Remove the transitive associations that can occurs in the dataframe return by the orbit identification
    - Transitive means (A <-> B and B <-> C => A <-> C)
    Parameters
    ----------
    pdf : dataframe
        The dataframe return by the orbit identification where trajectory_id_1 are for the first arcs and trajectory_id_2 are for the second arcs.

    Return
    ------
    pdf : dataframe
        The trajectory_id_2 replaced by the trajectory_id_1 of the first arcs involved in the transitive associations
    """
    transitive_left = pdf["trajectory_id_1"].isin(pdf["trajectory_id_2"])

    transitive_id = pdf[pdf["trajectory_id_2"].isin(pdf["trajectory_id_1"])][
        "trajectory_id_1"
    ].values

    pdf.loc[transitive_left, "trajectory_id_1"] = transitive_id

    return pdf


def merge_obs_id(pdf_obs, pdf_traj_merge):
    """
    Merge the observations of the both arcs to return only one single trajectories for each merged trajectories.

    Parameters
    ----------
    pdf_obs : dataframe
        The original observations dataframe
    pdf_traj_merge : dataframe
        The dataframe return by the orbit identification. It contains mainly the trajectory id of the both arcs

    Return
    ------
    tmp_pdf_obs : dataframe
        A copy of the original observations dataframe. The trajectory_id of the second arcs have been replaced by the one of the first arcs.
    """
    second_traj = pdf_obs[
        pdf_obs["trajectory_id"].isin(pdf_traj_merge["trajectory_id_2"])
    ]

    second_traj_size = second_traj.groupby(["trajectory_id"]).count()["ra"].to_numpy()

    tr_id_repeat = np.repeat(
        pdf_traj_merge["trajectory_id_1"].to_numpy(), second_traj_size
    )

    tmp_pdf_obs = pdf_obs.copy()

    tmp_pdf_obs.loc[
        tmp_pdf_obs["trajectory_id"].isin(pdf_traj_merge["trajectory_id_2"]),
        "trajectory_id",
    ] = tr_id_repeat

    return tmp_pdf_obs


def merge_orb_id(orb_cand, confirmed_merger, pdf_traj_merge):
    """
    Modification of the orbital elements dataframe to take into account of the merging.
    Remove the orbital elements of the second arcs and replaces the orbital elements of the first arcs
    by those of the merger.

    Parameters
    ----------
    orb_cand : dataframe
        the orginal orbital elements dataframe
    confirmed_merger : dataframe
        the orbital elements of the merged trajectories confirmed return by the second call to orbfit
    pdf_traj_merge : dataframe
        the trajectory_id of the both arcs with their orbitals elements return by the orbit identification

    Return
    ------
    orb_cand : dataframe
        The orbit elements dataframe where the second arcs of the confirmed merger have been removed and the orbital elements
        of the first arcs have been replaced by those of the merger.
    """

    # get the tmp merger view of the confirmed merger
    tmp_merger = pdf_traj_merge[
        pdf_traj_merge["trajectory_id_1"].isin(confirmed_merger["trajectory_id"])
    ]

    # remove the second orbital elements and observation arcs of the merger
    orb_cand = orb_cand[~orb_cand["trajectory_id"].isin(tmp_merger["trajectory_id_2"])]

    # get the orbital elements of the first confirmed arcs
    merged_traj_id = orb_cand["trajectory_id"].isin(tmp_merger["trajectory_id_1"])

    column_name = [
        "ref_epoch",
        "a",
        "e",
        "i",
        "long. node",
        "arg. peric",
        "mean anomaly",
        "rms_a",
        "rms_e",
        "rms_i",
        "rms_long. node",
        "rms_arg. peric",
        "rms_mean anomaly",
        "chi_reduced",
    ]

    # replaces the orbital elements by the merger ones
    orb_cand.loc[merged_traj_id, column_name] = confirmed_merger[column_name].to_numpy()

    return orb_cand


def orbit_identification(obs_cand, orbit_elem_cand, ram_dir, nb_neighbor, cpu_count):
    """
    Call orbfit to merge two trajectories candidates. Create two observations files and orbfit try to match a single orbit
    based on the two orbitals arcs (the two trajectories). Orbfit is able to return orbital elements for the merged trajectories
    but, due to a lack of documentation from Orbfit, a second call to orbfit is performed to return a better set of orbital elements for the
    merged trajectories.

    Parameters
    ----------
    obs_cand : dataframe
        The set of observations of each trajectories candidates.
    orbit_elem_cand : dataframe
        The set of orbital elements of each trajectories candidates
    ram_dir : string
        path where to write the temporary files generated by Orbfit
    nb_neighbor : integer
        The number of neighbor used to associates the trajectories
    cpu_count : integer
        The number of cpu core used by the parallel orbfit computation

    Return
    ------
    new_obs_cand : dataframe
        The observations dataframe, the trajectories that may belong to the same solar system objects have been merged together
    new_orbit_cand : dataframe
        The dataframe with the orbital elements, the orbital elements of the second arcs have been discarded and the orbital elements
        of the first arcs have been replaced by those of the merger.
    """

    # call orbfit to merge two orbitals arcs
    merge_results = merge_orbit(
        obs_cand, orbit_elem_cand, ram_dir, nb_neighbor, cpu_count
    )

    # (A <-> B means A associated with B)
    # remove the mirror (A <-> B and B <-> A) and transitive (A <-> B and B <-> C => A <-> C)
    merge_traj = remove_mirror(merge_results)
    merge_traj = remove_transitive(merge_traj)

    # the trajectory_id of the second arcs are replaced with the trajectory_id of the first arcs
    merged_obs_cand = merge_obs_id(obs_cand, merge_traj)

    # get the new merged trajectories
    new_traj = merged_obs_cand[
        merged_obs_cand["trajectory_id"].isin(merge_traj["trajectory_id_1"])
    ]

    # call orbfit to get the new orbital paramters of the merged trajectories even if the orbit identification return orbital elements.
    new_orb = ol.compute_df_orbit_param(new_traj, cpu_count, ram_dir)
    confirmed_merger = new_orb[(new_orb["a"] != -1.0) & (new_orb["rms_a"] != -1.0)]

    new_orbit_cand = merge_orb_id(orbit_elem_cand, confirmed_merger, merge_traj)

    # get the both trajectory_id merged arcs
    tmp_confirmed_merger = merge_traj[
        merge_traj["trajectory_id_1"].isin(confirmed_merger["trajectory_id"])
    ]

    # remove the both merged arcs from the observations dataframe
    obs_cand = obs_cand[
        ~obs_cand["trajectory_id"].isin(tmp_confirmed_merger["trajectory_id_1"])
    ]
    obs_cand = obs_cand[
        ~obs_cand["trajectory_id"].isin(tmp_confirmed_merger["trajectory_id_2"])
    ]

    # get the observations of the confirmed merger
    confirmed_obs = new_traj[
        new_traj["trajectory_id"].isin(confirmed_merger["trajectory_id"])
    ]
    # concat the old observations with the observations of the merged observations
    new_obs_cand = pd.concat([obs_cand, confirmed_obs])

    return new_obs_cand, new_orbit_cand


# if __name__ == "__main__":

#     ram_dir = "/media/virtuelram/" # "/tmp/ramdisk/"

#     path_data = "~/Documents/Doctorat/Asteroids/test_asteroids_candidates/ZTF/hope_without_bug/asteroids_candidates_resultats/candidates"

#     obs_cand = pd.read_parquet(os.path.join(path_data, "trajectory_orb.parquet")).sort_values(["trajectory_id"])

#     orbit_candidate = pd.read_parquet(os.path.join(path_data, "orbital.parquet")).reset_index(drop=True)


#     orbit_candidate["chi_reduced"] = np.ones(len(orbit_candidate)) * -1.0

#     obs_cand_with_merger, orb_cand_with_merger = orbit_identification(obs_cand, orbit_candidate, "/media/virtuelram/", 5, 10)

#     print(orb_cand_with_merger.sort_values(["chi_reduced"]))
