# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

import enum
import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt
import winsdk.windows.applicationmodel.activation
import winsdk.windows.applicationmodel.calls.background
import winsdk.windows.devices.bluetooth
import winsdk.windows.devices.bluetooth.advertisement
import winsdk.windows.devices.bluetooth.background
import winsdk.windows.devices.bluetooth.genericattributeprofile
import winsdk.windows.devices.geolocation
import winsdk.windows.devices.sensors
import winsdk.windows.devices.smartcards
import winsdk.windows.devices.sms
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.networking
import winsdk.windows.networking.sockets
import winsdk.windows.storage
import winsdk.windows.storage.provider
import winsdk.windows.system
import winsdk.windows.ui.notifications

class AlarmAccessStatus(enum.IntEnum):
    UNSPECIFIED = 0
    ALLOWED_WITH_WAKEUP_CAPABILITY = 1
    ALLOWED_WITHOUT_WAKEUP_CAPABILITY = 2
    DENIED = 3

class ApplicationTriggerResult(enum.IntEnum):
    ALLOWED = 0
    CURRENTLY_RUNNING = 1
    DISABLED_BY_POLICY = 2
    UNKNOWN_ERROR = 3

class BackgroundAccessRequestKind(enum.IntEnum):
    ALWAYS_ALLOWED = 0
    ALLOWED_SUBJECT_TO_SYSTEM_POLICY = 1

class BackgroundAccessStatus(enum.IntEnum):
    UNSPECIFIED = 0
    ALLOWED_WITH_ALWAYS_ON_REAL_TIME_CONNECTIVITY = 1
    ALLOWED_MAY_USE_ACTIVE_REAL_TIME_CONNECTIVITY = 2
    DENIED = 3
    ALWAYS_ALLOWED = 4
    ALLOWED_SUBJECT_TO_SYSTEM_POLICY = 5
    DENIED_BY_SYSTEM_POLICY = 6
    DENIED_BY_USER = 7

class BackgroundTaskCancellationReason(enum.IntEnum):
    ABORT = 0
    TERMINATING = 1
    LOGGING_OFF = 2
    SERVICING_UPDATE = 3
    IDLE_TASK = 4
    UNINSTALL = 5
    CONDITION_LOSS = 6
    SYSTEM_POLICY = 7
    QUIET_HOURS_ENTERED = 8
    EXECUTION_TIME_EXCEEDED = 9
    RESOURCE_REVOCATION = 10
    ENERGY_SAVER = 11

class BackgroundTaskThrottleCounter(enum.IntEnum):
    ALL = 0
    CPU = 1
    NETWORK = 2

class BackgroundWorkCostValue(enum.IntEnum):
    LOW = 0
    MEDIUM = 1
    HIGH = 2

class CustomSystemEventTriggerRecurrence(enum.IntEnum):
    ONCE = 0
    ALWAYS = 1

class DeviceTriggerResult(enum.IntEnum):
    ALLOWED = 0
    DENIED_BY_USER = 1
    DENIED_BY_SYSTEM = 2
    LOW_BATTERY = 3

class LocationTriggerType(enum.IntEnum):
    GEOFENCE = 0

class MediaProcessingTriggerResult(enum.IntEnum):
    ALLOWED = 0
    CURRENTLY_RUNNING = 1
    DISABLED_BY_POLICY = 2
    UNKNOWN_ERROR = 3

class SystemConditionType(enum.IntEnum):
    INVALID = 0
    USER_PRESENT = 1
    USER_NOT_PRESENT = 2
    INTERNET_AVAILABLE = 3
    INTERNET_NOT_AVAILABLE = 4
    SESSION_CONNECTED = 5
    SESSION_DISCONNECTED = 6
    FREE_NETWORK_AVAILABLE = 7
    BACKGROUND_WORK_COST_NOT_HIGH = 8

class SystemTriggerType(enum.IntEnum):
    INVALID = 0
    SMS_RECEIVED = 1
    USER_PRESENT = 2
    USER_AWAY = 3
    NETWORK_STATE_CHANGE = 4
    CONTROL_CHANNEL_RESET = 5
    INTERNET_AVAILABLE = 6
    SESSION_CONNECTED = 7
    SERVICING_COMPLETE = 8
    LOCK_SCREEN_APPLICATION_ADDED = 9
    LOCK_SCREEN_APPLICATION_REMOVED = 10
    TIME_ZONE_CHANGE = 11
    ONLINE_ID_CONNECTED_STATE_CHANGE = 12
    BACKGROUND_WORK_COST_CHANGE = 13
    POWER_STATE_CHANGE = 14
    DEFAULT_SIGN_IN_ACCOUNT_CHANGE = 15

Self = typing.TypeVar('Self')

class ActivitySensorTrigger(_winrt.Object):
    minimum_report_interval: _winrt.UInt32
    report_interval: _winrt.UInt32
    subscribed_activities: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.devices.sensors.ActivityType]]
    supported_activities: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.devices.sensors.ActivityType]]
    @staticmethod
    def _from(obj: _winrt.Object) -> ActivitySensorTrigger: ...
    def __init__(self, report_interval_in_milliseconds: _winrt.UInt32) -> None: ...

class AlarmApplicationManager(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> AlarmApplicationManager: ...
    @staticmethod
    def get_access_status() -> AlarmAccessStatus: ...
    @staticmethod
    def request_access_async() -> winsdk.windows.foundation.IAsyncOperation[AlarmAccessStatus]: ...

class AppBroadcastTrigger(_winrt.Object):
    provider_info: typing.Optional[AppBroadcastTriggerProviderInfo]
    @staticmethod
    def _from(obj: _winrt.Object) -> AppBroadcastTrigger: ...
    def __init__(self, provider_key: str) -> None: ...

class AppBroadcastTriggerProviderInfo(_winrt.Object):
    video_key_frame_interval: winsdk.windows.foundation.TimeSpan
    max_video_width: _winrt.UInt32
    max_video_height: _winrt.UInt32
    max_video_bitrate: _winrt.UInt32
    logo_resource: str
    display_name_resource: str
    @staticmethod
    def _from(obj: _winrt.Object) -> AppBroadcastTriggerProviderInfo: ...

class ApplicationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ApplicationTrigger: ...
    def __init__(self) -> None: ...
    @typing.overload
    def request_async(self) -> winsdk.windows.foundation.IAsyncOperation[ApplicationTriggerResult]: ...
    @typing.overload
    def request_async(self, arguments: typing.Optional[winsdk.windows.foundation.collections.ValueSet]) -> winsdk.windows.foundation.IAsyncOperation[ApplicationTriggerResult]: ...

class ApplicationTriggerDetails(_winrt.Object):
    arguments: typing.Optional[winsdk.windows.foundation.collections.ValueSet]
    @staticmethod
    def _from(obj: _winrt.Object) -> ApplicationTriggerDetails: ...

class AppointmentStoreNotificationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> AppointmentStoreNotificationTrigger: ...
    def __init__(self) -> None: ...

class BackgroundExecutionManager(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundExecutionManager: ...
    @typing.overload
    @staticmethod
    def get_access_status() -> BackgroundAccessStatus: ...
    @typing.overload
    @staticmethod
    def get_access_status(application_id: str) -> BackgroundAccessStatus: ...
    @typing.overload
    @staticmethod
    def get_access_status_for_modern_standby() -> BackgroundAccessStatus: ...
    @typing.overload
    @staticmethod
    def get_access_status_for_modern_standby(application_id: str) -> BackgroundAccessStatus: ...
    @typing.overload
    @staticmethod
    def remove_access() -> None: ...
    @typing.overload
    @staticmethod
    def remove_access(application_id: str) -> None: ...
    @typing.overload
    @staticmethod
    def request_access_async() -> winsdk.windows.foundation.IAsyncOperation[BackgroundAccessStatus]: ...
    @typing.overload
    @staticmethod
    def request_access_async(application_id: str) -> winsdk.windows.foundation.IAsyncOperation[BackgroundAccessStatus]: ...
    @staticmethod
    def request_access_kind_async(requested_access: BackgroundAccessRequestKind, reason: str) -> winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]: ...
    @staticmethod
    def request_access_kind_for_modern_standby_async(requested_access: BackgroundAccessRequestKind, reason: str) -> winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]: ...

class BackgroundTaskBuilder(_winrt.Object):
    task_entry_point: str
    name: str
    cancel_on_condition_loss: _winrt.Boolean
    is_network_requested: _winrt.Boolean
    task_group: typing.Optional[BackgroundTaskRegistrationGroup]
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskBuilder: ...
    def __init__(self) -> None: ...
    def add_condition(self, condition: typing.Optional[IBackgroundCondition]) -> None: ...
    def register(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    def set_task_entry_point_clsid(self, task_entry_point: uuid.UUID) -> None: ...
    def set_trigger(self, trigger: typing.Optional[IBackgroundTrigger]) -> None: ...

class BackgroundTaskCompletedEventArgs(_winrt.Object):
    instance_id: uuid.UUID
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskCompletedEventArgs: ...
    def check_result(self) -> None: ...

class BackgroundTaskDeferral(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskDeferral: ...
    def complete(self) -> None: ...

class BackgroundTaskProgressEventArgs(_winrt.Object):
    instance_id: uuid.UUID
    progress: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskProgressEventArgs: ...

class BackgroundTaskRegistration(_winrt.Object):
    name: str
    task_id: uuid.UUID
    trigger: typing.Optional[IBackgroundTrigger]
    task_group: typing.Optional[BackgroundTaskRegistrationGroup]
    all_tasks: typing.Optional[winsdk.windows.foundation.collections.IMapView[uuid.UUID, IBackgroundTaskRegistration]]
    all_task_groups: typing.Optional[winsdk.windows.foundation.collections.IMapView[str, BackgroundTaskRegistrationGroup]]
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskRegistration: ...
    @staticmethod
    def get_task_group(group_id: str) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...
    def unregister(self, cancel_task: _winrt.Boolean) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class BackgroundTaskRegistrationGroup(_winrt.Object):
    all_tasks: typing.Optional[winsdk.windows.foundation.collections.IMapView[uuid.UUID, BackgroundTaskRegistration]]
    id: str
    name: str
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskRegistrationGroup: ...
    @typing.overload
    def __init__(self, id: str) -> None: ...
    @typing.overload
    def __init__(self, id: str, name: str) -> None: ...
    def add_background_activated(self, handler: winsdk.windows.foundation.TypedEventHandler[BackgroundTaskRegistrationGroup, winsdk.windows.applicationmodel.activation.BackgroundActivatedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_background_activated(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class BackgroundWorkCost(_winrt.Object):
    current_background_work_cost: BackgroundWorkCostValue
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundWorkCost: ...

class BluetoothLEAdvertisementPublisherTrigger(_winrt.Object):
    advertisement: typing.Optional[winsdk.windows.devices.bluetooth.advertisement.BluetoothLEAdvertisement]
    use_extended_format: _winrt.Boolean
    preferred_transmit_power_level_in_d_bm: typing.Optional[typing.Optional[_winrt.Int16]]
    is_anonymous: _winrt.Boolean
    include_transmit_power_level: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> BluetoothLEAdvertisementPublisherTrigger: ...
    def __init__(self) -> None: ...

class BluetoothLEAdvertisementWatcherTrigger(_winrt.Object):
    signal_strength_filter: typing.Optional[winsdk.windows.devices.bluetooth.BluetoothSignalStrengthFilter]
    advertisement_filter: typing.Optional[winsdk.windows.devices.bluetooth.advertisement.BluetoothLEAdvertisementFilter]
    max_out_of_range_timeout: winsdk.windows.foundation.TimeSpan
    max_sampling_interval: winsdk.windows.foundation.TimeSpan
    min_out_of_range_timeout: winsdk.windows.foundation.TimeSpan
    min_sampling_interval: winsdk.windows.foundation.TimeSpan
    allow_extended_advertisements: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> BluetoothLEAdvertisementWatcherTrigger: ...
    def __init__(self) -> None: ...

class CachedFileUpdaterTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> CachedFileUpdaterTrigger: ...
    def __init__(self) -> None: ...

class CachedFileUpdaterTriggerDetails(_winrt.Object):
    can_request_user_input: _winrt.Boolean
    update_request: typing.Optional[winsdk.windows.storage.provider.FileUpdateRequest]
    update_target: winsdk.windows.storage.provider.CachedFileTarget
    @staticmethod
    def _from(obj: _winrt.Object) -> CachedFileUpdaterTriggerDetails: ...

class ChatMessageNotificationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ChatMessageNotificationTrigger: ...
    def __init__(self) -> None: ...

class ChatMessageReceivedNotificationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ChatMessageReceivedNotificationTrigger: ...
    def __init__(self) -> None: ...

class CommunicationBlockingAppSetAsActiveTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> CommunicationBlockingAppSetAsActiveTrigger: ...
    def __init__(self) -> None: ...

class ContactStoreNotificationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ContactStoreNotificationTrigger: ...
    def __init__(self) -> None: ...

class ContentPrefetchTrigger(_winrt.Object):
    wait_interval: winsdk.windows.foundation.TimeSpan
    @staticmethod
    def _from(obj: _winrt.Object) -> ContentPrefetchTrigger: ...
    @typing.overload
    def __init__(self, wait_interval: winsdk.windows.foundation.TimeSpan) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class ConversationalAgentTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ConversationalAgentTrigger: ...
    def __init__(self) -> None: ...

class CustomSystemEventTrigger(_winrt.Object):
    recurrence: CustomSystemEventTriggerRecurrence
    trigger_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> CustomSystemEventTrigger: ...
    def __init__(self, trigger_id: str, recurrence: CustomSystemEventTriggerRecurrence) -> None: ...

class DeviceConnectionChangeTrigger(_winrt.Object):
    maintain_connection: _winrt.Boolean
    can_maintain_connection: _winrt.Boolean
    device_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceConnectionChangeTrigger: ...
    @staticmethod
    def from_id_async(device_id: str) -> winsdk.windows.foundation.IAsyncOperation[DeviceConnectionChangeTrigger]: ...

class DeviceManufacturerNotificationTrigger(_winrt.Object):
    one_shot: _winrt.Boolean
    trigger_qualifier: str
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceManufacturerNotificationTrigger: ...
    def __init__(self, trigger_qualifier: str, one_shot: _winrt.Boolean) -> None: ...

class DeviceServicingTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceServicingTrigger: ...
    def __init__(self) -> None: ...
    @typing.overload
    def request_async(self, device_id: str, expected_duration: winsdk.windows.foundation.TimeSpan) -> winsdk.windows.foundation.IAsyncOperation[DeviceTriggerResult]: ...
    @typing.overload
    def request_async(self, device_id: str, expected_duration: winsdk.windows.foundation.TimeSpan, arguments: str) -> winsdk.windows.foundation.IAsyncOperation[DeviceTriggerResult]: ...

class DeviceUseTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceUseTrigger: ...
    def __init__(self) -> None: ...
    @typing.overload
    def request_async(self, device_id: str) -> winsdk.windows.foundation.IAsyncOperation[DeviceTriggerResult]: ...
    @typing.overload
    def request_async(self, device_id: str, arguments: str) -> winsdk.windows.foundation.IAsyncOperation[DeviceTriggerResult]: ...

class DeviceWatcherTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceWatcherTrigger: ...

class EmailStoreNotificationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> EmailStoreNotificationTrigger: ...
    def __init__(self) -> None: ...

class GattCharacteristicNotificationTrigger(_winrt.Object):
    characteristic: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattCharacteristic]
    event_triggering_mode: winsdk.windows.devices.bluetooth.background.BluetoothEventTriggeringMode
    @staticmethod
    def _from(obj: _winrt.Object) -> GattCharacteristicNotificationTrigger: ...
    @typing.overload
    def __init__(self, characteristic: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattCharacteristic], event_triggering_mode: winsdk.windows.devices.bluetooth.background.BluetoothEventTriggeringMode) -> None: ...
    @typing.overload
    def __init__(self, characteristic: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattCharacteristic]) -> None: ...

class GattServiceProviderTrigger(_winrt.Object):
    advertising_parameters: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattServiceProviderAdvertisingParameters]
    service: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattLocalService]
    trigger_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> GattServiceProviderTrigger: ...
    @staticmethod
    def create_async(trigger_id: str, service_uuid: uuid.UUID) -> winsdk.windows.foundation.IAsyncOperation[GattServiceProviderTriggerResult]: ...

class GattServiceProviderTriggerResult(_winrt.Object):
    error: winsdk.windows.devices.bluetooth.BluetoothError
    trigger: typing.Optional[GattServiceProviderTrigger]
    @staticmethod
    def _from(obj: _winrt.Object) -> GattServiceProviderTriggerResult: ...

class GeovisitTrigger(_winrt.Object):
    monitoring_scope: winsdk.windows.devices.geolocation.VisitMonitoringScope
    @staticmethod
    def _from(obj: _winrt.Object) -> GeovisitTrigger: ...
    def __init__(self) -> None: ...

class LocationTrigger(_winrt.Object):
    trigger_type: LocationTriggerType
    @staticmethod
    def _from(obj: _winrt.Object) -> LocationTrigger: ...
    def __init__(self, trigger_type: LocationTriggerType) -> None: ...

class MaintenanceTrigger(_winrt.Object):
    freshness_time: _winrt.UInt32
    one_shot: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> MaintenanceTrigger: ...
    def __init__(self, freshness_time: _winrt.UInt32, one_shot: _winrt.Boolean) -> None: ...

class MediaProcessingTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaProcessingTrigger: ...
    def __init__(self) -> None: ...
    @typing.overload
    def request_async(self) -> winsdk.windows.foundation.IAsyncOperation[MediaProcessingTriggerResult]: ...
    @typing.overload
    def request_async(self, arguments: typing.Optional[winsdk.windows.foundation.collections.ValueSet]) -> winsdk.windows.foundation.IAsyncOperation[MediaProcessingTriggerResult]: ...

class MobileBroadbandDeviceServiceNotificationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandDeviceServiceNotificationTrigger: ...
    def __init__(self) -> None: ...

class MobileBroadbandPcoDataChangeTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandPcoDataChangeTrigger: ...
    def __init__(self) -> None: ...

class MobileBroadbandPinLockStateChangeTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandPinLockStateChangeTrigger: ...
    def __init__(self) -> None: ...

class MobileBroadbandRadioStateChangeTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandRadioStateChangeTrigger: ...
    def __init__(self) -> None: ...

class MobileBroadbandRegistrationStateChangeTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandRegistrationStateChangeTrigger: ...
    def __init__(self) -> None: ...

class NetworkOperatorDataUsageTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> NetworkOperatorDataUsageTrigger: ...
    def __init__(self) -> None: ...

class NetworkOperatorHotspotAuthenticationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> NetworkOperatorHotspotAuthenticationTrigger: ...
    def __init__(self) -> None: ...

class NetworkOperatorNotificationTrigger(_winrt.Object):
    network_account_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> NetworkOperatorNotificationTrigger: ...
    def __init__(self, network_account_id: str) -> None: ...

class PaymentAppCanMakePaymentTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> PaymentAppCanMakePaymentTrigger: ...
    def __init__(self) -> None: ...

class PhoneTrigger(_winrt.Object):
    one_shot: _winrt.Boolean
    trigger_type: winsdk.windows.applicationmodel.calls.background.PhoneTriggerType
    @staticmethod
    def _from(obj: _winrt.Object) -> PhoneTrigger: ...
    def __init__(self, type: winsdk.windows.applicationmodel.calls.background.PhoneTriggerType, one_shot: _winrt.Boolean) -> None: ...

class PushNotificationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> PushNotificationTrigger: ...
    @typing.overload
    def __init__(self, application_id: str) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class RcsEndUserMessageAvailableTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> RcsEndUserMessageAvailableTrigger: ...
    def __init__(self) -> None: ...

class RfcommConnectionTrigger(_winrt.Object):
    remote_host_name: typing.Optional[winsdk.windows.networking.HostName]
    protection_level: winsdk.windows.networking.sockets.SocketProtectionLevel
    allow_multiple_connections: _winrt.Boolean
    inbound_connection: typing.Optional[winsdk.windows.devices.bluetooth.background.RfcommInboundConnectionInformation]
    outbound_connection: typing.Optional[winsdk.windows.devices.bluetooth.background.RfcommOutboundConnectionInformation]
    @staticmethod
    def _from(obj: _winrt.Object) -> RfcommConnectionTrigger: ...
    def __init__(self) -> None: ...

class SecondaryAuthenticationFactorAuthenticationTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SecondaryAuthenticationFactorAuthenticationTrigger: ...
    def __init__(self) -> None: ...

class SensorDataThresholdTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SensorDataThresholdTrigger: ...
    def __init__(self, threshold: typing.Optional[winsdk.windows.devices.sensors.ISensorDataThreshold]) -> None: ...

class SmartCardTrigger(_winrt.Object):
    trigger_type: winsdk.windows.devices.smartcards.SmartCardTriggerType
    @staticmethod
    def _from(obj: _winrt.Object) -> SmartCardTrigger: ...
    def __init__(self, trigger_type: winsdk.windows.devices.smartcards.SmartCardTriggerType) -> None: ...

class SmsMessageReceivedTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SmsMessageReceivedTrigger: ...
    def __init__(self, filter_rules: typing.Optional[winsdk.windows.devices.sms.SmsFilterRules]) -> None: ...

class SocketActivityTrigger(_winrt.Object):
    is_wake_from_low_power_supported: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> SocketActivityTrigger: ...
    def __init__(self) -> None: ...

class StorageLibraryChangeTrackerTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> StorageLibraryChangeTrackerTrigger: ...
    def __init__(self, tracker: typing.Optional[winsdk.windows.storage.StorageLibraryChangeTracker]) -> None: ...

class StorageLibraryContentChangedTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> StorageLibraryContentChangedTrigger: ...
    @staticmethod
    def create(storage_library: typing.Optional[winsdk.windows.storage.StorageLibrary]) -> typing.Optional[StorageLibraryContentChangedTrigger]: ...
    @staticmethod
    def create_from_libraries(storage_libraries: typing.Iterable[winsdk.windows.storage.StorageLibrary]) -> typing.Optional[StorageLibraryContentChangedTrigger]: ...

class SystemCondition(_winrt.Object):
    condition_type: SystemConditionType
    @staticmethod
    def _from(obj: _winrt.Object) -> SystemCondition: ...
    def __init__(self, condition_type: SystemConditionType) -> None: ...

class SystemTrigger(_winrt.Object):
    one_shot: _winrt.Boolean
    trigger_type: SystemTriggerType
    @staticmethod
    def _from(obj: _winrt.Object) -> SystemTrigger: ...
    def __init__(self, trigger_type: SystemTriggerType, one_shot: _winrt.Boolean) -> None: ...

class TetheringEntitlementCheckTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> TetheringEntitlementCheckTrigger: ...
    def __init__(self) -> None: ...

class TimeTrigger(_winrt.Object):
    freshness_time: _winrt.UInt32
    one_shot: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> TimeTrigger: ...
    def __init__(self, freshness_time: _winrt.UInt32, one_shot: _winrt.Boolean) -> None: ...

class ToastNotificationActionTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ToastNotificationActionTrigger: ...
    @typing.overload
    def __init__(self, application_id: str) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class ToastNotificationHistoryChangedTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ToastNotificationHistoryChangedTrigger: ...
    @typing.overload
    def __init__(self, application_id: str) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class UserNotificationChangedTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> UserNotificationChangedTrigger: ...
    def __init__(self, notification_kinds: winsdk.windows.ui.notifications.NotificationKinds) -> None: ...

class WiFiOnDemandHotspotConnectTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> WiFiOnDemandHotspotConnectTrigger: ...
    def __init__(self) -> None: ...

class WiFiOnDemandHotspotUpdateMetadataTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> WiFiOnDemandHotspotUpdateMetadataTrigger: ...
    def __init__(self) -> None: ...

class IBackgroundCondition(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundCondition: ...

class IBackgroundTask(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTask: ...
    def run(self, task_instance: typing.Optional[IBackgroundTaskInstance]) -> None: ...

class IBackgroundTaskInstance(_winrt.Object):
    instance_id: uuid.UUID
    progress: _winrt.UInt32
    suspended_count: _winrt.UInt32
    task: typing.Optional[BackgroundTaskRegistration]
    trigger_details: typing.Optional[_winrt.Object]
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskInstance: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskInstance2(_winrt.Object):
    instance_id: uuid.UUID
    progress: _winrt.UInt32
    suspended_count: _winrt.UInt32
    task: typing.Optional[BackgroundTaskRegistration]
    trigger_details: typing.Optional[_winrt.Object]
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskInstance2: ...
    def get_throttle_count(self, counter: BackgroundTaskThrottleCounter) -> _winrt.UInt32: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskInstance4(_winrt.Object):
    user: typing.Optional[winsdk.windows.system.User]
    instance_id: uuid.UUID
    progress: _winrt.UInt32
    suspended_count: _winrt.UInt32
    task: typing.Optional[BackgroundTaskRegistration]
    trigger_details: typing.Optional[_winrt.Object]
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskInstance4: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskRegistration(_winrt.Object):
    name: str
    task_id: uuid.UUID
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskRegistration: ...
    def unregister(self, cancel_task: _winrt.Boolean) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskRegistration2(_winrt.Object):
    trigger: typing.Optional[IBackgroundTrigger]
    name: str
    task_id: uuid.UUID
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskRegistration2: ...
    def unregister(self, cancel_task: _winrt.Boolean) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskRegistration3(_winrt.Object):
    task_group: typing.Optional[BackgroundTaskRegistrationGroup]
    name: str
    task_id: uuid.UUID
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskRegistration3: ...
    def unregister(self, cancel_task: _winrt.Boolean) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTrigger: ...

BackgroundTaskCanceledEventHandler = typing.Callable[[typing.Optional[IBackgroundTaskInstance], BackgroundTaskCancellationReason], None]

BackgroundTaskCompletedEventHandler = typing.Callable[[typing.Optional[BackgroundTaskRegistration], typing.Optional[BackgroundTaskCompletedEventArgs]], None]

BackgroundTaskProgressEventHandler = typing.Callable[[typing.Optional[BackgroundTaskRegistration], typing.Optional[BackgroundTaskProgressEventArgs]], None]

