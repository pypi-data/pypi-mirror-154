# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
TECA Python module

The core module contains the pipeline and executive
as well as metadata object, variant array and abstract
datasets.

The data module provides high-level data structures that
are produced and consumed by teca_algorithms such as
Cartesian meshes, AMR datasets, and tables.

The alg module contains data processing, analysis, remeshing,
and detectors.

The io module contains readers and writers.

"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _teca_py
else:
    import _teca_py

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class ios_base(object):
    r"""Proxy of C++ std::ios_base class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _teca_py.ios_base_erase_event
    
    imbue_event = _teca_py.ios_base_imbue_event
    
    copyfmt_event = _teca_py.ios_base_copyfmt_event
    

    def register_callback(self, __fn, __index):
        r"""
        register_callback(ios_base self, std::ios_base::event_callback __fn, int __index)

        Parameters
        ----------
        __fn: std::ios_base::event_callback
        __index: int

        """
        return _teca_py.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        r"""
        flags(ios_base self) -> std::ios_base::fmtflags
        flags(ios_base self, std::ios_base::fmtflags __fmtfl) -> std::ios_base::fmtflags

        Parameters
        ----------
        __fmtfl: std::ios_base::fmtflags

        """
        return _teca_py.ios_base_flags(self, *args)

    def setf(self, *args):
        r"""
        setf(ios_base self, std::ios_base::fmtflags __fmtfl) -> std::ios_base::fmtflags

        Parameters
        ----------
        __fmtfl: std::ios_base::fmtflags

        setf(ios_base self, std::ios_base::fmtflags __fmtfl, std::ios_base::fmtflags __mask) -> std::ios_base::fmtflags

        Parameters
        ----------
        __fmtfl: std::ios_base::fmtflags
        __mask: std::ios_base::fmtflags

        """
        return _teca_py.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        r"""
        unsetf(ios_base self, std::ios_base::fmtflags __mask)

        Parameters
        ----------
        __mask: std::ios_base::fmtflags

        """
        return _teca_py.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        r"""
        precision(ios_base self) -> std::streamsize
        precision(ios_base self, std::streamsize __prec) -> std::streamsize

        Parameters
        ----------
        __prec: std::streamsize

        """
        return _teca_py.ios_base_precision(self, *args)

    def width(self, *args):
        r"""
        width(ios_base self) -> std::streamsize
        width(ios_base self, std::streamsize __wide) -> std::streamsize

        Parameters
        ----------
        __wide: std::streamsize

        """
        return _teca_py.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync=True):
        r"""
        sync_with_stdio(bool __sync=True) -> bool

        Parameters
        ----------
        __sync: bool

        """
        return _teca_py.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc):
        r"""
        imbue(ios_base self, std::locale const & __loc) -> std::locale

        Parameters
        ----------
        __loc: std::locale const &

        """
        return _teca_py.ios_base_imbue(self, __loc)

    def getloc(self):
        r"""getloc(ios_base self) -> std::locale"""
        return _teca_py.ios_base_getloc(self)

    @staticmethod
    def xalloc():
        r"""xalloc() -> int"""
        return _teca_py.ios_base_xalloc()

    def iword(self, __ix):
        r"""
        iword(ios_base self, int __ix) -> long &

        Parameters
        ----------
        __ix: int

        """
        return _teca_py.ios_base_iword(self, __ix)

    def pword(self, __ix):
        r"""
        pword(ios_base self, int __ix) -> void *&

        Parameters
        ----------
        __ix: int

        """
        return _teca_py.ios_base_pword(self, __ix)
    __swig_destroy__ = _teca_py.delete_ios_base

# Register ios_base in _teca_py:
_teca_py.ios_base_swigregister(ios_base)
cvar = _teca_py.cvar
ios_base.boolalpha = _teca_py.cvar.ios_base_boolalpha
ios_base.dec = _teca_py.cvar.ios_base_dec
ios_base.fixed = _teca_py.cvar.ios_base_fixed
ios_base.hex = _teca_py.cvar.ios_base_hex
ios_base.internal = _teca_py.cvar.ios_base_internal
ios_base.left = _teca_py.cvar.ios_base_left
ios_base.oct = _teca_py.cvar.ios_base_oct
ios_base.right = _teca_py.cvar.ios_base_right
ios_base.scientific = _teca_py.cvar.ios_base_scientific
ios_base.showbase = _teca_py.cvar.ios_base_showbase
ios_base.showpoint = _teca_py.cvar.ios_base_showpoint
ios_base.showpos = _teca_py.cvar.ios_base_showpos
ios_base.skipws = _teca_py.cvar.ios_base_skipws
ios_base.unitbuf = _teca_py.cvar.ios_base_unitbuf
ios_base.uppercase = _teca_py.cvar.ios_base_uppercase
ios_base.adjustfield = _teca_py.cvar.ios_base_adjustfield
ios_base.basefield = _teca_py.cvar.ios_base_basefield
ios_base.floatfield = _teca_py.cvar.ios_base_floatfield
ios_base.badbit = _teca_py.cvar.ios_base_badbit
ios_base.eofbit = _teca_py.cvar.ios_base_eofbit
ios_base.failbit = _teca_py.cvar.ios_base_failbit
ios_base.goodbit = _teca_py.cvar.ios_base_goodbit
ios_base.app = _teca_py.cvar.ios_base_app
ios_base.ate = _teca_py.cvar.ios_base_ate
ios_base.binary = _teca_py.cvar.ios_base_binary
ios_base.ios_base_in = _teca_py.cvar.ios_base_ios_base_in
ios_base.out = _teca_py.cvar.ios_base_out
ios_base.trunc = _teca_py.cvar.ios_base_trunc
ios_base.beg = _teca_py.cvar.ios_base_beg
ios_base.cur = _teca_py.cvar.ios_base_cur
ios_base.end = _teca_py.cvar.ios_base_end

def ios_base_sync_with_stdio(__sync=True):
    r"""
    ios_base_sync_with_stdio(bool __sync=True) -> bool

    Parameters
    ----------
    __sync: bool

    """
    return _teca_py.ios_base_sync_with_stdio(__sync)

def ios_base_xalloc():
    r"""ios_base_xalloc() -> int"""
    return _teca_py.ios_base_xalloc()

class ios(ios_base):
    r"""Proxy of C++ std::basic_ios< char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self):
        r"""rdstate(ios self) -> std::ios_base::iostate"""
        return _teca_py.ios_rdstate(self)

    def clear(self, *args):
        r"""
        clear(ios self, std::ios_base::iostate __state=goodbit)

        Parameters
        ----------
        __state: std::ios_base::iostate

        """
        return _teca_py.ios_clear(self, *args)

    def setstate(self, __state):
        r"""
        setstate(ios self, std::ios_base::iostate __state)

        Parameters
        ----------
        __state: std::ios_base::iostate

        """
        return _teca_py.ios_setstate(self, __state)

    def good(self):
        r"""good(ios self) -> bool"""
        return _teca_py.ios_good(self)

    def eof(self):
        r"""eof(ios self) -> bool"""
        return _teca_py.ios_eof(self)

    def fail(self):
        r"""fail(ios self) -> bool"""
        return _teca_py.ios_fail(self)

    def bad(self):
        r"""bad(ios self) -> bool"""
        return _teca_py.ios_bad(self)

    def exceptions(self, *args):
        r"""
        exceptions(ios self) -> std::ios_base::iostate
        exceptions(ios self, std::ios_base::iostate __except)

        Parameters
        ----------
        __except: std::ios_base::iostate

        """
        return _teca_py.ios_exceptions(self, *args)

    def __init__(self, __sb):
        r"""
        __init__(ios self, std::basic_streambuf< char,std::char_traits< char > > * __sb) -> ios

        Parameters
        ----------
        __sb: std::basic_streambuf< char,std::char_traits< char > > *

        """
        _teca_py.ios_swiginit(self, _teca_py.new_ios(__sb))
    __swig_destroy__ = _teca_py.delete_ios

    def tie(self, *args):
        r"""
        tie(ios self) -> ostream
        tie(ios self, ostream __tiestr) -> ostream

        Parameters
        ----------
        __tiestr: std::basic_ostream< char,std::char_traits< char > > *

        """
        return _teca_py.ios_tie(self, *args)

    def rdbuf(self, *args):
        r"""
        rdbuf(ios self) -> std::basic_streambuf< char,std::char_traits< char > >
        rdbuf(ios self, std::basic_streambuf< char,std::char_traits< char > > * __sb) -> std::basic_streambuf< char,std::char_traits< char > > *

        Parameters
        ----------
        __sb: std::basic_streambuf< char,std::char_traits< char > > *

        """
        return _teca_py.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        r"""
        copyfmt(ios self, ios __rhs) -> ios

        Parameters
        ----------
        __rhs: std::basic_ios< char > const &

        """
        return _teca_py.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        r"""
        fill(ios self) -> std::basic_ios< char >::char_type
        fill(ios self, std::basic_ios< char >::char_type __ch) -> std::basic_ios< char >::char_type

        Parameters
        ----------
        __ch: std::basic_ios< char >::char_type

        """
        return _teca_py.ios_fill(self, *args)

    def imbue(self, __loc):
        r"""
        imbue(ios self, std::locale const & __loc) -> std::locale

        Parameters
        ----------
        __loc: std::locale const &

        """
        return _teca_py.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        r"""
        narrow(ios self, std::basic_ios< char >::char_type __c, char __dfault) -> char

        Parameters
        ----------
        __c: std::basic_ios< char >::char_type
        __dfault: char

        """
        return _teca_py.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        r"""
        widen(ios self, char __c) -> std::basic_ios< char >::char_type

        Parameters
        ----------
        __c: char

        """
        return _teca_py.ios_widen(self, __c)

# Register ios in _teca_py:
_teca_py.ios_swigregister(ios)

class ostream(ios):
    r"""Proxy of C++ std::basic_ostream< char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        r"""
        __init__(ostream self, std::basic_streambuf< char,std::char_traits< char > > * __sb) -> ostream

        Parameters
        ----------
        __sb: std::basic_streambuf< char,std::char_traits< char > > *

        """
        _teca_py.ostream_swiginit(self, _teca_py.new_ostream(__sb))
    __swig_destroy__ = _teca_py.delete_ostream

    def __lshift__(self, *args):
        r"""
        __lshift__(ostream self, std::basic_ostream< char,std::char_traits< char > > &(*)(std::basic_ostream< char,std::char_traits< char > > &) __pf) -> ostream

        Parameters
        ----------
        __pf: std::basic_ostream< char,std::char_traits< char > > &(*)(std::basic_ostream< char,std::char_traits< char > > &)

        __lshift__(ostream self, std::basic_ios< char,std::char_traits< char > > &(*)(std::basic_ios< char,std::char_traits< char > > &) __pf) -> ostream

        Parameters
        ----------
        __pf: std::basic_ios< char,std::char_traits< char > > &(*)(std::basic_ios< char,std::char_traits< char > > &)

        __lshift__(ostream self, std::ios_base &(*)(std::ios_base &) __pf) -> ostream

        Parameters
        ----------
        __pf: std::ios_base &(*)(std::ios_base &)

        __lshift__(ostream self, long __n) -> ostream

        Parameters
        ----------
        __n: long

        __lshift__(ostream self, unsigned long __n) -> ostream

        Parameters
        ----------
        __n: unsigned long

        __lshift__(ostream self, bool __n) -> ostream

        Parameters
        ----------
        __n: bool

        __lshift__(ostream self, short __n) -> ostream

        Parameters
        ----------
        __n: short

        __lshift__(ostream self, unsigned short __n) -> ostream

        Parameters
        ----------
        __n: unsigned short

        __lshift__(ostream self, int __n) -> ostream

        Parameters
        ----------
        __n: int

        __lshift__(ostream self, unsigned int __n) -> ostream

        Parameters
        ----------
        __n: unsigned int

        __lshift__(ostream self, long long __n) -> ostream

        Parameters
        ----------
        __n: long long

        __lshift__(ostream self, unsigned long long __n) -> ostream

        Parameters
        ----------
        __n: unsigned long long

        __lshift__(ostream self, double __f) -> ostream

        Parameters
        ----------
        __f: double

        __lshift__(ostream self, float __f) -> ostream

        Parameters
        ----------
        __f: float

        __lshift__(ostream self, long double __f) -> ostream

        Parameters
        ----------
        __f: long double

        __lshift__(ostream self, void const * __p) -> ostream

        Parameters
        ----------
        __p: void const *

        __lshift__(ostream self, std::basic_streambuf< char,std::char_traits< char > > * __sb) -> ostream

        Parameters
        ----------
        __sb: std::basic_streambuf< char,std::char_traits< char > > *

        __lshift__(ostream self, std::basic_string< char,std::char_traits< char >,std::allocator< char > > const & s) -> ostream

        Parameters
        ----------
        s: std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &

        """
        return _teca_py.ostream___lshift__(self, *args)

    def put(self, __c):
        r"""
        put(ostream self, std::basic_ostream< char >::char_type __c) -> ostream

        Parameters
        ----------
        __c: std::basic_ostream< char >::char_type

        """
        return _teca_py.ostream_put(self, __c)

    def write(self, __s, __n):
        r"""
        write(ostream self, std::basic_ostream< char >::char_type const * __s, std::streamsize __n) -> ostream

        Parameters
        ----------
        __s: std::basic_ostream< char >::char_type const *
        __n: std::streamsize

        """
        return _teca_py.ostream_write(self, __s, __n)

    def flush(self):
        r"""flush(ostream self) -> ostream"""
        return _teca_py.ostream_flush(self)

    def tellp(self):
        r"""tellp(ostream self) -> std::basic_ostream< char >::pos_type"""
        return _teca_py.ostream_tellp(self)

    def seekp(self, *args):
        r"""
        seekp(ostream self, std::basic_ostream< char >::pos_type arg2) -> ostream

        Parameters
        ----------
        arg2: std::basic_ostream< char >::pos_type

        seekp(ostream self, std::basic_ostream< char >::off_type arg2, std::ios_base::seekdir arg3) -> ostream

        Parameters
        ----------
        arg2: std::basic_ostream< char >::off_type
        arg3: std::ios_base::seekdir

        """
        return _teca_py.ostream_seekp(self, *args)

# Register ostream in _teca_py:
_teca_py.ostream_swigregister(ostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

class istream(ios):
    r"""Proxy of C++ std::basic_istream< char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        r"""
        __init__(istream self, std::basic_streambuf< char,std::char_traits< char > > * __sb) -> istream

        Parameters
        ----------
        __sb: std::basic_streambuf< char,std::char_traits< char > > *

        """
        _teca_py.istream_swiginit(self, _teca_py.new_istream(__sb))
    __swig_destroy__ = _teca_py.delete_istream

    def __rshift__(self, *args):
        r"""
        __rshift__(istream self, std::basic_istream< char,std::char_traits< char > > &(*)(std::basic_istream< char,std::char_traits< char > > &) __pf) -> istream

        Parameters
        ----------
        __pf: std::basic_istream< char,std::char_traits< char > > &(*)(std::basic_istream< char,std::char_traits< char > > &)

        __rshift__(istream self, std::basic_ios< char,std::char_traits< char > > &(*)(std::basic_ios< char,std::char_traits< char > > &) __pf) -> istream

        Parameters
        ----------
        __pf: std::basic_ios< char,std::char_traits< char > > &(*)(std::basic_ios< char,std::char_traits< char > > &)

        __rshift__(istream self, std::ios_base &(*)(std::ios_base &) __pf) -> istream

        Parameters
        ----------
        __pf: std::ios_base &(*)(std::ios_base &)

        __rshift__(istream self, bool & __n) -> istream

        Parameters
        ----------
        __n: bool &

        __rshift__(istream self, short & __n) -> istream

        Parameters
        ----------
        __n: short &

        __rshift__(istream self, unsigned short & __n) -> istream

        Parameters
        ----------
        __n: unsigned short &

        __rshift__(istream self, int & __n) -> istream

        Parameters
        ----------
        __n: int &

        __rshift__(istream self, unsigned int & __n) -> istream

        Parameters
        ----------
        __n: unsigned int &

        __rshift__(istream self, long & __n) -> istream

        Parameters
        ----------
        __n: long &

        __rshift__(istream self, unsigned long & __n) -> istream

        Parameters
        ----------
        __n: unsigned long &

        __rshift__(istream self, long long & __n) -> istream

        Parameters
        ----------
        __n: long long &

        __rshift__(istream self, unsigned long long & __n) -> istream

        Parameters
        ----------
        __n: unsigned long long &

        __rshift__(istream self, float & __f) -> istream

        Parameters
        ----------
        __f: float &

        __rshift__(istream self, double & __f) -> istream

        Parameters
        ----------
        __f: double &

        __rshift__(istream self, long double & __f) -> istream

        Parameters
        ----------
        __f: long double &

        __rshift__(istream self, void *& __p) -> istream

        Parameters
        ----------
        __p: void *&

        __rshift__(istream self, std::basic_streambuf< char,std::char_traits< char > > * __sb) -> istream

        Parameters
        ----------
        __sb: std::basic_streambuf< char,std::char_traits< char > > *

        """
        return _teca_py.istream___rshift__(self, *args)

    def gcount(self):
        r"""gcount(istream self) -> std::streamsize"""
        return _teca_py.istream_gcount(self)

    def get(self, *args):
        r"""
        get(istream self) -> std::basic_istream< char >::int_type
        get(istream self, std::basic_istream< char >::char_type & __c) -> istream

        Parameters
        ----------
        __c: std::basic_istream< char >::char_type &

        get(istream self, std::basic_istream< char >::char_type * __s, std::streamsize __n, std::basic_istream< char >::char_type __delim) -> istream

        Parameters
        ----------
        __s: std::basic_istream< char >::char_type *
        __n: std::streamsize
        __delim: std::basic_istream< char >::char_type

        get(istream self, std::basic_istream< char >::char_type * __s, std::streamsize __n) -> istream

        Parameters
        ----------
        __s: std::basic_istream< char >::char_type *
        __n: std::streamsize

        get(istream self, std::basic_streambuf< char,std::char_traits< char > > & __sb, std::basic_istream< char >::char_type __delim) -> istream

        Parameters
        ----------
        __sb: std::basic_streambuf< char,std::char_traits< char > > &
        __delim: std::basic_istream< char >::char_type

        get(istream self, std::basic_streambuf< char,std::char_traits< char > > & __sb) -> istream

        Parameters
        ----------
        __sb: std::basic_streambuf< char,std::char_traits< char > > &

        """
        return _teca_py.istream_get(self, *args)

    def getline(self, *args):
        r"""
        getline(istream self, std::basic_istream< char >::char_type * __s, std::streamsize __n, std::basic_istream< char >::char_type __delim) -> istream

        Parameters
        ----------
        __s: std::basic_istream< char >::char_type *
        __n: std::streamsize
        __delim: std::basic_istream< char >::char_type

        getline(istream self, std::basic_istream< char >::char_type * __s, std::streamsize __n) -> istream

        Parameters
        ----------
        __s: std::basic_istream< char >::char_type *
        __n: std::streamsize

        """
        return _teca_py.istream_getline(self, *args)

    def ignore(self, *args):
        r"""
        ignore(istream self, std::streamsize __n=1, std::basic_istream< char >::int_type __delim=std::char_traits< char >::eof()) -> istream

        Parameters
        ----------
        __n: std::streamsize
        __delim: std::basic_istream< char >::int_type

        """
        return _teca_py.istream_ignore(self, *args)

    def peek(self):
        r"""peek(istream self) -> std::basic_istream< char >::int_type"""
        return _teca_py.istream_peek(self)

    def read(self, __s, __n):
        r"""
        read(istream self, std::basic_istream< char >::char_type * __s, std::streamsize __n) -> istream

        Parameters
        ----------
        __s: std::basic_istream< char >::char_type *
        __n: std::streamsize

        """
        return _teca_py.istream_read(self, __s, __n)

    def readsome(self, __s, __n):
        r"""
        readsome(istream self, std::basic_istream< char >::char_type * __s, std::streamsize __n) -> std::streamsize

        Parameters
        ----------
        __s: std::basic_istream< char >::char_type *
        __n: std::streamsize

        """
        return _teca_py.istream_readsome(self, __s, __n)

    def putback(self, __c):
        r"""
        putback(istream self, std::basic_istream< char >::char_type __c) -> istream

        Parameters
        ----------
        __c: std::basic_istream< char >::char_type

        """
        return _teca_py.istream_putback(self, __c)

    def unget(self):
        r"""unget(istream self) -> istream"""
        return _teca_py.istream_unget(self)

    def sync(self):
        r"""sync(istream self) -> int"""
        return _teca_py.istream_sync(self)

    def tellg(self):
        r"""tellg(istream self) -> std::basic_istream< char >::pos_type"""
        return _teca_py.istream_tellg(self)

    def seekg(self, *args):
        r"""
        seekg(istream self, std::basic_istream< char >::pos_type arg2) -> istream

        Parameters
        ----------
        arg2: std::basic_istream< char >::pos_type

        seekg(istream self, std::basic_istream< char >::off_type arg2, std::ios_base::seekdir arg3) -> istream

        Parameters
        ----------
        arg2: std::basic_istream< char >::off_type
        arg3: std::ios_base::seekdir

        """
        return _teca_py.istream_seekg(self, *args)

# Register istream in _teca_py:
_teca_py.istream_swigregister(istream)

class iostream(istream, ostream):
    r"""Proxy of C++ std::basic_iostream< char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        r"""
        __init__(iostream self, std::basic_streambuf< char,std::char_traits< char > > * __sb) -> iostream

        Parameters
        ----------
        __sb: std::basic_streambuf< char,std::char_traits< char > > *

        """
        _teca_py.iostream_swiginit(self, _teca_py.new_iostream(__sb))
    __swig_destroy__ = _teca_py.delete_iostream

# Register iostream in _teca_py:
_teca_py.iostream_swigregister(iostream)

endl_cb_ptr = _teca_py.endl_cb_ptr

endl = _teca_py.endl
ends_cb_ptr = _teca_py.ends_cb_ptr

ends = _teca_py.ends
flush_cb_ptr = _teca_py.flush_cb_ptr

flush = _teca_py.flush
TECA_DATA_ROOT = _teca_py.TECA_DATA_ROOT


def get_teca_version_descr():
    r"""get_teca_version_descr() -> char const *"""
    return _teca_py.get_teca_version_descr()

def get_teca_python_version():
    r"""get_teca_python_version() -> int"""
    return _teca_py.get_teca_python_version()

def get_teca_has_data():
    r"""get_teca_has_data() -> bool"""
    return _teca_py.get_teca_has_data()

def get_teca_data_root():
    r"""get_teca_data_root() -> char const *"""
    return _teca_py.get_teca_data_root()

def get_teca_has_regex():
    r"""get_teca_has_regex() -> bool"""
    return _teca_py.get_teca_has_regex()

def get_teca_has_netcdf():
    r"""get_teca_has_netcdf() -> bool"""
    return _teca_py.get_teca_has_netcdf()

def get_teca_has_mpi():
    r"""get_teca_has_mpi() -> bool"""
    return _teca_py.get_teca_has_mpi()

def get_teca_has_boost():
    r"""get_teca_has_boost() -> bool"""
    return _teca_py.get_teca_has_boost()

def get_teca_has_vtk():
    r"""get_teca_has_vtk() -> bool"""
    return _teca_py.get_teca_has_vtk()

def get_teca_has_paraview():
    r"""get_teca_has_paraview() -> bool"""
    return _teca_py.get_teca_has_paraview()

def get_teca_has_udunits():
    r"""get_teca_has_udunits() -> bool"""
    return _teca_py.get_teca_has_udunits()

def get_teca_has_openssl():
    r"""get_teca_has_openssl() -> bool"""
    return _teca_py.get_teca_has_openssl()

def get_teca_has_numpy():
    r"""get_teca_has_numpy() -> bool"""
    return _teca_py.get_teca_has_numpy()

def get_teca_has_cupy():
    r"""get_teca_has_cupy() -> bool"""
    return _teca_py.get_teca_has_cupy()

def get_teca_has_pytorch():
    r"""get_teca_has_pytorch() -> bool"""
    return _teca_py.get_teca_has_pytorch()

def get_teca_has_matplotlib():
    r"""get_teca_has_matplotlib() -> bool"""
    return _teca_py.get_teca_has_matplotlib()

def get_teca_has_tcpypi():
    r"""get_teca_has_tcpypi() -> bool"""
    return _teca_py.get_teca_has_tcpypi()

def get_teca_has_cuda():
    r"""get_teca_has_cuda() -> bool"""
    return _teca_py.get_teca_has_cuda()
class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _teca_py.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _teca_py.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _teca_py.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""
        distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _teca_py.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""
        equal(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _teca_py.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _teca_py.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _teca_py.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _teca_py.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _teca_py.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""
        advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _teca_py.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""
        __eq__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _teca_py.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""
        __ne__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _teca_py.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""
        __iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _teca_py.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""
        __isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _teca_py.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""
        __add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _teca_py.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _teca_py.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _teca_py:
_teca_py.SwigPyIterator_swigregister(SwigPyIterator)

class std_vector_char(object):
    r"""Proxy of C++ std::vector< char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_char self) -> SwigPyIterator"""
        return _teca_py.std_vector_char_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_char self) -> bool"""
        return _teca_py.std_vector_char___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_char self) -> bool"""
        return _teca_py.std_vector_char___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_char self) -> std::vector< char >::size_type"""
        return _teca_py.std_vector_char___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_char self, std::vector< char >::difference_type i, std::vector< char >::difference_type j) -> std_vector_char

        Parameters
        ----------
        i: std::vector< char >::difference_type
        j: std::vector< char >::difference_type

        """
        return _teca_py.std_vector_char___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_char self, std::vector< char >::difference_type i, std::vector< char >::difference_type j)

        Parameters
        ----------
        i: std::vector< char >::difference_type
        j: std::vector< char >::difference_type

        __setslice__(std_vector_char self, std::vector< char >::difference_type i, std::vector< char >::difference_type j, std_vector_char v)

        Parameters
        ----------
        i: std::vector< char >::difference_type
        j: std::vector< char >::difference_type
        v: std::vector< char,std::allocator< char > > const &

        """
        return _teca_py.std_vector_char___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_char self, std::vector< char >::difference_type i, std::vector< char >::difference_type j)

        Parameters
        ----------
        i: std::vector< char >::difference_type
        j: std::vector< char >::difference_type

        """
        return _teca_py.std_vector_char___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_char self, std::vector< char >::difference_type i)

        Parameters
        ----------
        i: std::vector< char >::difference_type

        __delitem__(std_vector_char self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_char___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_char self, PySliceObject * slice) -> std_vector_char

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_char self, std::vector< char >::difference_type i) -> std::vector< char >::value_type const &

        Parameters
        ----------
        i: std::vector< char >::difference_type

        """
        return _teca_py.std_vector_char___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_char self, PySliceObject * slice, std_vector_char v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< char,std::allocator< char > > const &

        __setitem__(std_vector_char self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_char self, std::vector< char >::difference_type i, std::vector< char >::value_type const & x)

        Parameters
        ----------
        i: std::vector< char >::difference_type
        x: std::vector< char >::value_type const &

        """
        return _teca_py.std_vector_char___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_char self) -> std::vector< char >::value_type"""
        return _teca_py.std_vector_char_pop(self)

    def append(self, x):
        r"""
        append(std_vector_char self, std::vector< char >::value_type const & x)

        Parameters
        ----------
        x: std::vector< char >::value_type const &

        """
        return _teca_py.std_vector_char_append(self, x)

    def empty(self):
        r"""empty(std_vector_char self) -> bool"""
        return _teca_py.std_vector_char_empty(self)

    def size(self):
        r"""size(std_vector_char self) -> std::vector< char >::size_type"""
        return _teca_py.std_vector_char_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_char self, std_vector_char v)

        Parameters
        ----------
        v: std::vector< char > &

        """
        return _teca_py.std_vector_char_swap(self, v)

    def begin(self):
        r"""begin(std_vector_char self) -> std::vector< char >::iterator"""
        return _teca_py.std_vector_char_begin(self)

    def end(self):
        r"""end(std_vector_char self) -> std::vector< char >::iterator"""
        return _teca_py.std_vector_char_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_char self) -> std::vector< char >::reverse_iterator"""
        return _teca_py.std_vector_char_rbegin(self)

    def rend(self):
        r"""rend(std_vector_char self) -> std::vector< char >::reverse_iterator"""
        return _teca_py.std_vector_char_rend(self)

    def clear(self):
        r"""clear(std_vector_char self)"""
        return _teca_py.std_vector_char_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_char self) -> std::vector< char >::allocator_type"""
        return _teca_py.std_vector_char_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_char self)"""
        return _teca_py.std_vector_char_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_char self, std::vector< char >::iterator pos) -> std::vector< char >::iterator

        Parameters
        ----------
        pos: std::vector< char >::iterator

        erase(std_vector_char self, std::vector< char >::iterator first, std::vector< char >::iterator last) -> std::vector< char >::iterator

        Parameters
        ----------
        first: std::vector< char >::iterator
        last: std::vector< char >::iterator

        """
        return _teca_py.std_vector_char_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_char self) -> std_vector_char
        __init__(std_vector_char self, std_vector_char other) -> std_vector_char

        Parameters
        ----------
        other: std::vector< char > const &

        __init__(std_vector_char self, std::vector< char >::size_type size) -> std_vector_char

        Parameters
        ----------
        size: std::vector< char >::size_type

        __init__(std_vector_char self, std::vector< char >::size_type size, std::vector< char >::value_type const & value) -> std_vector_char

        Parameters
        ----------
        size: std::vector< char >::size_type
        value: std::vector< char >::value_type const &

        """
        _teca_py.std_vector_char_swiginit(self, _teca_py.new_std_vector_char(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_char self, std::vector< char >::value_type const & x)

        Parameters
        ----------
        x: std::vector< char >::value_type const &

        """
        return _teca_py.std_vector_char_push_back(self, x)

    def front(self):
        r"""front(std_vector_char self) -> std::vector< char >::value_type const &"""
        return _teca_py.std_vector_char_front(self)

    def back(self):
        r"""back(std_vector_char self) -> std::vector< char >::value_type const &"""
        return _teca_py.std_vector_char_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_char self, std::vector< char >::size_type n, std::vector< char >::value_type const & x)

        Parameters
        ----------
        n: std::vector< char >::size_type
        x: std::vector< char >::value_type const &

        """
        return _teca_py.std_vector_char_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_char self, std::vector< char >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< char >::size_type

        resize(std_vector_char self, std::vector< char >::size_type new_size, std::vector< char >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< char >::size_type
        x: std::vector< char >::value_type const &

        """
        return _teca_py.std_vector_char_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_char self, std::vector< char >::iterator pos, std::vector< char >::value_type const & x) -> std::vector< char >::iterator

        Parameters
        ----------
        pos: std::vector< char >::iterator
        x: std::vector< char >::value_type const &

        insert(std_vector_char self, std::vector< char >::iterator pos, std::vector< char >::size_type n, std::vector< char >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< char >::iterator
        n: std::vector< char >::size_type
        x: std::vector< char >::value_type const &

        """
        return _teca_py.std_vector_char_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_char self, std::vector< char >::size_type n)

        Parameters
        ----------
        n: std::vector< char >::size_type

        """
        return _teca_py.std_vector_char_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_char self) -> std::vector< char >::size_type"""
        return _teca_py.std_vector_char_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_char

# Register std_vector_char in _teca_py:
_teca_py.std_vector_char_swigregister(std_vector_char)

class std_vector_uchar(object):
    r"""Proxy of C++ std::vector< unsigned char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_uchar self) -> SwigPyIterator"""
        return _teca_py.std_vector_uchar_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_uchar self) -> bool"""
        return _teca_py.std_vector_uchar___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_uchar self) -> bool"""
        return _teca_py.std_vector_uchar___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_uchar self) -> std::vector< unsigned char >::size_type"""
        return _teca_py.std_vector_uchar___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_uchar self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j) -> std_vector_uchar

        Parameters
        ----------
        i: std::vector< unsigned char >::difference_type
        j: std::vector< unsigned char >::difference_type

        """
        return _teca_py.std_vector_uchar___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_uchar self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned char >::difference_type
        j: std::vector< unsigned char >::difference_type

        __setslice__(std_vector_uchar self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j, std_vector_uchar v)

        Parameters
        ----------
        i: std::vector< unsigned char >::difference_type
        j: std::vector< unsigned char >::difference_type
        v: std::vector< unsigned char,std::allocator< unsigned char > > const &

        """
        return _teca_py.std_vector_uchar___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_uchar self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned char >::difference_type
        j: std::vector< unsigned char >::difference_type

        """
        return _teca_py.std_vector_uchar___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_uchar self, std::vector< unsigned char >::difference_type i)

        Parameters
        ----------
        i: std::vector< unsigned char >::difference_type

        __delitem__(std_vector_uchar self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_uchar___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_uchar self, PySliceObject * slice) -> std_vector_uchar

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_uchar self, std::vector< unsigned char >::difference_type i) -> std::vector< unsigned char >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned char >::difference_type

        """
        return _teca_py.std_vector_uchar___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_uchar self, PySliceObject * slice, std_vector_uchar v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< unsigned char,std::allocator< unsigned char > > const &

        __setitem__(std_vector_uchar self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_uchar self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::value_type const & x)

        Parameters
        ----------
        i: std::vector< unsigned char >::difference_type
        x: std::vector< unsigned char >::value_type const &

        """
        return _teca_py.std_vector_uchar___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_uchar self) -> std::vector< unsigned char >::value_type"""
        return _teca_py.std_vector_uchar_pop(self)

    def append(self, x):
        r"""
        append(std_vector_uchar self, std::vector< unsigned char >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned char >::value_type const &

        """
        return _teca_py.std_vector_uchar_append(self, x)

    def empty(self):
        r"""empty(std_vector_uchar self) -> bool"""
        return _teca_py.std_vector_uchar_empty(self)

    def size(self):
        r"""size(std_vector_uchar self) -> std::vector< unsigned char >::size_type"""
        return _teca_py.std_vector_uchar_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_uchar self, std_vector_uchar v)

        Parameters
        ----------
        v: std::vector< unsigned char > &

        """
        return _teca_py.std_vector_uchar_swap(self, v)

    def begin(self):
        r"""begin(std_vector_uchar self) -> std::vector< unsigned char >::iterator"""
        return _teca_py.std_vector_uchar_begin(self)

    def end(self):
        r"""end(std_vector_uchar self) -> std::vector< unsigned char >::iterator"""
        return _teca_py.std_vector_uchar_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_uchar self) -> std::vector< unsigned char >::reverse_iterator"""
        return _teca_py.std_vector_uchar_rbegin(self)

    def rend(self):
        r"""rend(std_vector_uchar self) -> std::vector< unsigned char >::reverse_iterator"""
        return _teca_py.std_vector_uchar_rend(self)

    def clear(self):
        r"""clear(std_vector_uchar self)"""
        return _teca_py.std_vector_uchar_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_uchar self) -> std::vector< unsigned char >::allocator_type"""
        return _teca_py.std_vector_uchar_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_uchar self)"""
        return _teca_py.std_vector_uchar_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_uchar self, std::vector< unsigned char >::iterator pos) -> std::vector< unsigned char >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned char >::iterator

        erase(std_vector_uchar self, std::vector< unsigned char >::iterator first, std::vector< unsigned char >::iterator last) -> std::vector< unsigned char >::iterator

        Parameters
        ----------
        first: std::vector< unsigned char >::iterator
        last: std::vector< unsigned char >::iterator

        """
        return _teca_py.std_vector_uchar_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_uchar self) -> std_vector_uchar
        __init__(std_vector_uchar self, std_vector_uchar other) -> std_vector_uchar

        Parameters
        ----------
        other: std::vector< unsigned char > const &

        __init__(std_vector_uchar self, std::vector< unsigned char >::size_type size) -> std_vector_uchar

        Parameters
        ----------
        size: std::vector< unsigned char >::size_type

        __init__(std_vector_uchar self, std::vector< unsigned char >::size_type size, std::vector< unsigned char >::value_type const & value) -> std_vector_uchar

        Parameters
        ----------
        size: std::vector< unsigned char >::size_type
        value: std::vector< unsigned char >::value_type const &

        """
        _teca_py.std_vector_uchar_swiginit(self, _teca_py.new_std_vector_uchar(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_uchar self, std::vector< unsigned char >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned char >::value_type const &

        """
        return _teca_py.std_vector_uchar_push_back(self, x)

    def front(self):
        r"""front(std_vector_uchar self) -> std::vector< unsigned char >::value_type const &"""
        return _teca_py.std_vector_uchar_front(self)

    def back(self):
        r"""back(std_vector_uchar self) -> std::vector< unsigned char >::value_type const &"""
        return _teca_py.std_vector_uchar_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_uchar self, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)

        Parameters
        ----------
        n: std::vector< unsigned char >::size_type
        x: std::vector< unsigned char >::value_type const &

        """
        return _teca_py.std_vector_uchar_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_uchar self, std::vector< unsigned char >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned char >::size_type

        resize(std_vector_uchar self, std::vector< unsigned char >::size_type new_size, std::vector< unsigned char >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< unsigned char >::size_type
        x: std::vector< unsigned char >::value_type const &

        """
        return _teca_py.std_vector_uchar_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_uchar self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::value_type const & x) -> std::vector< unsigned char >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned char >::iterator
        x: std::vector< unsigned char >::value_type const &

        insert(std_vector_uchar self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< unsigned char >::iterator
        n: std::vector< unsigned char >::size_type
        x: std::vector< unsigned char >::value_type const &

        """
        return _teca_py.std_vector_uchar_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_uchar self, std::vector< unsigned char >::size_type n)

        Parameters
        ----------
        n: std::vector< unsigned char >::size_type

        """
        return _teca_py.std_vector_uchar_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_uchar self) -> std::vector< unsigned char >::size_type"""
        return _teca_py.std_vector_uchar_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_uchar

# Register std_vector_uchar in _teca_py:
_teca_py.std_vector_uchar_swigregister(std_vector_uchar)

class std_vector_int(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_int self) -> SwigPyIterator"""
        return _teca_py.std_vector_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_int self) -> bool"""
        return _teca_py.std_vector_int___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_int self) -> bool"""
        return _teca_py.std_vector_int___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_int self) -> std::vector< int >::size_type"""
        return _teca_py.std_vector_int___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> std_vector_int

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type

        """
        return _teca_py.std_vector_int___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type

        __setslice__(std_vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, std_vector_int v)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type
        v: std::vector< int,std::allocator< int > > const &

        """
        return _teca_py.std_vector_int___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type

        """
        return _teca_py.std_vector_int___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_int self, std::vector< int >::difference_type i)

        Parameters
        ----------
        i: std::vector< int >::difference_type

        __delitem__(std_vector_int self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_int___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_int self, PySliceObject * slice) -> std_vector_int

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_int self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &

        Parameters
        ----------
        i: std::vector< int >::difference_type

        """
        return _teca_py.std_vector_int___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_int self, PySliceObject * slice, std_vector_int v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< int,std::allocator< int > > const &

        __setitem__(std_vector_int self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_int self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        x: std::vector< int >::value_type const &

        """
        return _teca_py.std_vector_int___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_int self) -> std::vector< int >::value_type"""
        return _teca_py.std_vector_int_pop(self)

    def append(self, x):
        r"""
        append(std_vector_int self, std::vector< int >::value_type const & x)

        Parameters
        ----------
        x: std::vector< int >::value_type const &

        """
        return _teca_py.std_vector_int_append(self, x)

    def empty(self):
        r"""empty(std_vector_int self) -> bool"""
        return _teca_py.std_vector_int_empty(self)

    def size(self):
        r"""size(std_vector_int self) -> std::vector< int >::size_type"""
        return _teca_py.std_vector_int_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_int self, std_vector_int v)

        Parameters
        ----------
        v: std::vector< int > &

        """
        return _teca_py.std_vector_int_swap(self, v)

    def begin(self):
        r"""begin(std_vector_int self) -> std::vector< int >::iterator"""
        return _teca_py.std_vector_int_begin(self)

    def end(self):
        r"""end(std_vector_int self) -> std::vector< int >::iterator"""
        return _teca_py.std_vector_int_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_int self) -> std::vector< int >::reverse_iterator"""
        return _teca_py.std_vector_int_rbegin(self)

    def rend(self):
        r"""rend(std_vector_int self) -> std::vector< int >::reverse_iterator"""
        return _teca_py.std_vector_int_rend(self)

    def clear(self):
        r"""clear(std_vector_int self)"""
        return _teca_py.std_vector_int_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_int self) -> std::vector< int >::allocator_type"""
        return _teca_py.std_vector_int_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_int self)"""
        return _teca_py.std_vector_int_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_int self, std::vector< int >::iterator pos) -> std::vector< int >::iterator

        Parameters
        ----------
        pos: std::vector< int >::iterator

        erase(std_vector_int self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator

        Parameters
        ----------
        first: std::vector< int >::iterator
        last: std::vector< int >::iterator

        """
        return _teca_py.std_vector_int_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_int self) -> std_vector_int
        __init__(std_vector_int self, std_vector_int other) -> std_vector_int

        Parameters
        ----------
        other: std::vector< int > const &

        __init__(std_vector_int self, std::vector< int >::size_type size) -> std_vector_int

        Parameters
        ----------
        size: std::vector< int >::size_type

        __init__(std_vector_int self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> std_vector_int

        Parameters
        ----------
        size: std::vector< int >::size_type
        value: std::vector< int >::value_type const &

        """
        _teca_py.std_vector_int_swiginit(self, _teca_py.new_std_vector_int(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_int self, std::vector< int >::value_type const & x)

        Parameters
        ----------
        x: std::vector< int >::value_type const &

        """
        return _teca_py.std_vector_int_push_back(self, x)

    def front(self):
        r"""front(std_vector_int self) -> std::vector< int >::value_type const &"""
        return _teca_py.std_vector_int_front(self)

    def back(self):
        r"""back(std_vector_int self) -> std::vector< int >::value_type const &"""
        return _teca_py.std_vector_int_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_int self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)

        Parameters
        ----------
        n: std::vector< int >::size_type
        x: std::vector< int >::value_type const &

        """
        return _teca_py.std_vector_int_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_int self, std::vector< int >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< int >::size_type

        resize(std_vector_int self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< int >::size_type
        x: std::vector< int >::value_type const &

        """
        return _teca_py.std_vector_int_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_int self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator

        Parameters
        ----------
        pos: std::vector< int >::iterator
        x: std::vector< int >::value_type const &

        insert(std_vector_int self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< int >::iterator
        n: std::vector< int >::size_type
        x: std::vector< int >::value_type const &

        """
        return _teca_py.std_vector_int_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_int self, std::vector< int >::size_type n)

        Parameters
        ----------
        n: std::vector< int >::size_type

        """
        return _teca_py.std_vector_int_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_int self) -> std::vector< int >::size_type"""
        return _teca_py.std_vector_int_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_int

# Register std_vector_int in _teca_py:
_teca_py.std_vector_int_swigregister(std_vector_int)

class std_vector_uint(object):
    r"""Proxy of C++ std::vector< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_uint self) -> SwigPyIterator"""
        return _teca_py.std_vector_uint_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_uint self) -> bool"""
        return _teca_py.std_vector_uint___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_uint self) -> bool"""
        return _teca_py.std_vector_uint___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_uint self) -> std::vector< unsigned int >::size_type"""
        return _teca_py.std_vector_uint___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> std_vector_uint

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type

        """
        return _teca_py.std_vector_uint___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type

        __setslice__(std_vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, std_vector_uint v)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type
        v: std::vector< unsigned int,std::allocator< unsigned int > > const &

        """
        return _teca_py.std_vector_uint___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type

        """
        return _teca_py.std_vector_uint___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_uint self, std::vector< unsigned int >::difference_type i)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type

        __delitem__(std_vector_uint self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_uint___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_uint self, PySliceObject * slice) -> std_vector_uint

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_uint self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type

        """
        return _teca_py.std_vector_uint___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_uint self, PySliceObject * slice, std_vector_uint v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< unsigned int,std::allocator< unsigned int > > const &

        __setitem__(std_vector_uint self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _teca_py.std_vector_uint___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_uint self) -> std::vector< unsigned int >::value_type"""
        return _teca_py.std_vector_uint_pop(self)

    def append(self, x):
        r"""
        append(std_vector_uint self, std::vector< unsigned int >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned int >::value_type const &

        """
        return _teca_py.std_vector_uint_append(self, x)

    def empty(self):
        r"""empty(std_vector_uint self) -> bool"""
        return _teca_py.std_vector_uint_empty(self)

    def size(self):
        r"""size(std_vector_uint self) -> std::vector< unsigned int >::size_type"""
        return _teca_py.std_vector_uint_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_uint self, std_vector_uint v)

        Parameters
        ----------
        v: std::vector< unsigned int > &

        """
        return _teca_py.std_vector_uint_swap(self, v)

    def begin(self):
        r"""begin(std_vector_uint self) -> std::vector< unsigned int >::iterator"""
        return _teca_py.std_vector_uint_begin(self)

    def end(self):
        r"""end(std_vector_uint self) -> std::vector< unsigned int >::iterator"""
        return _teca_py.std_vector_uint_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_uint self) -> std::vector< unsigned int >::reverse_iterator"""
        return _teca_py.std_vector_uint_rbegin(self)

    def rend(self):
        r"""rend(std_vector_uint self) -> std::vector< unsigned int >::reverse_iterator"""
        return _teca_py.std_vector_uint_rend(self)

    def clear(self):
        r"""clear(std_vector_uint self)"""
        return _teca_py.std_vector_uint_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_uint self) -> std::vector< unsigned int >::allocator_type"""
        return _teca_py.std_vector_uint_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_uint self)"""
        return _teca_py.std_vector_uint_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_uint self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned int >::iterator

        erase(std_vector_uint self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator

        Parameters
        ----------
        first: std::vector< unsigned int >::iterator
        last: std::vector< unsigned int >::iterator

        """
        return _teca_py.std_vector_uint_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_uint self) -> std_vector_uint
        __init__(std_vector_uint self, std_vector_uint other) -> std_vector_uint

        Parameters
        ----------
        other: std::vector< unsigned int > const &

        __init__(std_vector_uint self, std::vector< unsigned int >::size_type size) -> std_vector_uint

        Parameters
        ----------
        size: std::vector< unsigned int >::size_type

        __init__(std_vector_uint self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> std_vector_uint

        Parameters
        ----------
        size: std::vector< unsigned int >::size_type
        value: std::vector< unsigned int >::value_type const &

        """
        _teca_py.std_vector_uint_swiginit(self, _teca_py.new_std_vector_uint(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_uint self, std::vector< unsigned int >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned int >::value_type const &

        """
        return _teca_py.std_vector_uint_push_back(self, x)

    def front(self):
        r"""front(std_vector_uint self) -> std::vector< unsigned int >::value_type const &"""
        return _teca_py.std_vector_uint_front(self)

    def back(self):
        r"""back(std_vector_uint self) -> std::vector< unsigned int >::value_type const &"""
        return _teca_py.std_vector_uint_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_uint self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)

        Parameters
        ----------
        n: std::vector< unsigned int >::size_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _teca_py.std_vector_uint_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_uint self, std::vector< unsigned int >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned int >::size_type

        resize(std_vector_uint self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< unsigned int >::size_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _teca_py.std_vector_uint_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_uint self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned int >::iterator
        x: std::vector< unsigned int >::value_type const &

        insert(std_vector_uint self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< unsigned int >::iterator
        n: std::vector< unsigned int >::size_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _teca_py.std_vector_uint_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_uint self, std::vector< unsigned int >::size_type n)

        Parameters
        ----------
        n: std::vector< unsigned int >::size_type

        """
        return _teca_py.std_vector_uint_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_uint self) -> std::vector< unsigned int >::size_type"""
        return _teca_py.std_vector_uint_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_uint

# Register std_vector_uint in _teca_py:
_teca_py.std_vector_uint_swigregister(std_vector_uint)

class std_vector_long(object):
    r"""Proxy of C++ std::vector< long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_long self) -> SwigPyIterator"""
        return _teca_py.std_vector_long_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_long self) -> bool"""
        return _teca_py.std_vector_long___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_long self) -> bool"""
        return _teca_py.std_vector_long___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_long self) -> std::vector< long >::size_type"""
        return _teca_py.std_vector_long___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_long self, std::vector< long >::difference_type i, std::vector< long >::difference_type j) -> std_vector_long

        Parameters
        ----------
        i: std::vector< long >::difference_type
        j: std::vector< long >::difference_type

        """
        return _teca_py.std_vector_long___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_long self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)

        Parameters
        ----------
        i: std::vector< long >::difference_type
        j: std::vector< long >::difference_type

        __setslice__(std_vector_long self, std::vector< long >::difference_type i, std::vector< long >::difference_type j, std_vector_long v)

        Parameters
        ----------
        i: std::vector< long >::difference_type
        j: std::vector< long >::difference_type
        v: std::vector< long,std::allocator< long > > const &

        """
        return _teca_py.std_vector_long___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_long self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)

        Parameters
        ----------
        i: std::vector< long >::difference_type
        j: std::vector< long >::difference_type

        """
        return _teca_py.std_vector_long___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_long self, std::vector< long >::difference_type i)

        Parameters
        ----------
        i: std::vector< long >::difference_type

        __delitem__(std_vector_long self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_long___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_long self, PySliceObject * slice) -> std_vector_long

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_long self, std::vector< long >::difference_type i) -> std::vector< long >::value_type const &

        Parameters
        ----------
        i: std::vector< long >::difference_type

        """
        return _teca_py.std_vector_long___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_long self, PySliceObject * slice, std_vector_long v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< long,std::allocator< long > > const &

        __setitem__(std_vector_long self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_long self, std::vector< long >::difference_type i, std::vector< long >::value_type const & x)

        Parameters
        ----------
        i: std::vector< long >::difference_type
        x: std::vector< long >::value_type const &

        """
        return _teca_py.std_vector_long___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_long self) -> std::vector< long >::value_type"""
        return _teca_py.std_vector_long_pop(self)

    def append(self, x):
        r"""
        append(std_vector_long self, std::vector< long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< long >::value_type const &

        """
        return _teca_py.std_vector_long_append(self, x)

    def empty(self):
        r"""empty(std_vector_long self) -> bool"""
        return _teca_py.std_vector_long_empty(self)

    def size(self):
        r"""size(std_vector_long self) -> std::vector< long >::size_type"""
        return _teca_py.std_vector_long_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_long self, std_vector_long v)

        Parameters
        ----------
        v: std::vector< long > &

        """
        return _teca_py.std_vector_long_swap(self, v)

    def begin(self):
        r"""begin(std_vector_long self) -> std::vector< long >::iterator"""
        return _teca_py.std_vector_long_begin(self)

    def end(self):
        r"""end(std_vector_long self) -> std::vector< long >::iterator"""
        return _teca_py.std_vector_long_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_long self) -> std::vector< long >::reverse_iterator"""
        return _teca_py.std_vector_long_rbegin(self)

    def rend(self):
        r"""rend(std_vector_long self) -> std::vector< long >::reverse_iterator"""
        return _teca_py.std_vector_long_rend(self)

    def clear(self):
        r"""clear(std_vector_long self)"""
        return _teca_py.std_vector_long_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_long self) -> std::vector< long >::allocator_type"""
        return _teca_py.std_vector_long_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_long self)"""
        return _teca_py.std_vector_long_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_long self, std::vector< long >::iterator pos) -> std::vector< long >::iterator

        Parameters
        ----------
        pos: std::vector< long >::iterator

        erase(std_vector_long self, std::vector< long >::iterator first, std::vector< long >::iterator last) -> std::vector< long >::iterator

        Parameters
        ----------
        first: std::vector< long >::iterator
        last: std::vector< long >::iterator

        """
        return _teca_py.std_vector_long_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_long self) -> std_vector_long
        __init__(std_vector_long self, std_vector_long other) -> std_vector_long

        Parameters
        ----------
        other: std::vector< long > const &

        __init__(std_vector_long self, std::vector< long >::size_type size) -> std_vector_long

        Parameters
        ----------
        size: std::vector< long >::size_type

        __init__(std_vector_long self, std::vector< long >::size_type size, std::vector< long >::value_type const & value) -> std_vector_long

        Parameters
        ----------
        size: std::vector< long >::size_type
        value: std::vector< long >::value_type const &

        """
        _teca_py.std_vector_long_swiginit(self, _teca_py.new_std_vector_long(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_long self, std::vector< long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< long >::value_type const &

        """
        return _teca_py.std_vector_long_push_back(self, x)

    def front(self):
        r"""front(std_vector_long self) -> std::vector< long >::value_type const &"""
        return _teca_py.std_vector_long_front(self)

    def back(self):
        r"""back(std_vector_long self) -> std::vector< long >::value_type const &"""
        return _teca_py.std_vector_long_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_long self, std::vector< long >::size_type n, std::vector< long >::value_type const & x)

        Parameters
        ----------
        n: std::vector< long >::size_type
        x: std::vector< long >::value_type const &

        """
        return _teca_py.std_vector_long_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_long self, std::vector< long >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< long >::size_type

        resize(std_vector_long self, std::vector< long >::size_type new_size, std::vector< long >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< long >::size_type
        x: std::vector< long >::value_type const &

        """
        return _teca_py.std_vector_long_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_long self, std::vector< long >::iterator pos, std::vector< long >::value_type const & x) -> std::vector< long >::iterator

        Parameters
        ----------
        pos: std::vector< long >::iterator
        x: std::vector< long >::value_type const &

        insert(std_vector_long self, std::vector< long >::iterator pos, std::vector< long >::size_type n, std::vector< long >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< long >::iterator
        n: std::vector< long >::size_type
        x: std::vector< long >::value_type const &

        """
        return _teca_py.std_vector_long_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_long self, std::vector< long >::size_type n)

        Parameters
        ----------
        n: std::vector< long >::size_type

        """
        return _teca_py.std_vector_long_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_long self) -> std::vector< long >::size_type"""
        return _teca_py.std_vector_long_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_long

# Register std_vector_long in _teca_py:
_teca_py.std_vector_long_swigregister(std_vector_long)

class std_vector_ulong(object):
    r"""Proxy of C++ std::vector< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_ulong self) -> SwigPyIterator"""
        return _teca_py.std_vector_ulong_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_ulong self) -> bool"""
        return _teca_py.std_vector_ulong___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_ulong self) -> bool"""
        return _teca_py.std_vector_ulong___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_ulong self) -> std::vector< unsigned long >::size_type"""
        return _teca_py.std_vector_ulong___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_ulong self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> std_vector_ulong

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        j: std::vector< unsigned long >::difference_type

        """
        return _teca_py.std_vector_ulong___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_ulong self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        j: std::vector< unsigned long >::difference_type

        __setslice__(std_vector_ulong self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, std_vector_ulong v)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        j: std::vector< unsigned long >::difference_type
        v: std::vector< unsigned long,std::allocator< unsigned long > > const &

        """
        return _teca_py.std_vector_ulong___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_ulong self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        j: std::vector< unsigned long >::difference_type

        """
        return _teca_py.std_vector_ulong___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_ulong self, std::vector< unsigned long >::difference_type i)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type

        __delitem__(std_vector_ulong self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_ulong___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_ulong self, PySliceObject * slice) -> std_vector_ulong

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_ulong self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type

        """
        return _teca_py.std_vector_ulong___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_ulong self, PySliceObject * slice, std_vector_ulong v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< unsigned long,std::allocator< unsigned long > > const &

        __setitem__(std_vector_ulong self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_ulong self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        x: std::vector< unsigned long >::value_type const &

        """
        return _teca_py.std_vector_ulong___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_ulong self) -> std::vector< unsigned long >::value_type"""
        return _teca_py.std_vector_ulong_pop(self)

    def append(self, x):
        r"""
        append(std_vector_ulong self, std::vector< unsigned long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned long >::value_type const &

        """
        return _teca_py.std_vector_ulong_append(self, x)

    def empty(self):
        r"""empty(std_vector_ulong self) -> bool"""
        return _teca_py.std_vector_ulong_empty(self)

    def size(self):
        r"""size(std_vector_ulong self) -> std::vector< unsigned long >::size_type"""
        return _teca_py.std_vector_ulong_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_ulong self, std_vector_ulong v)

        Parameters
        ----------
        v: std::vector< unsigned long > &

        """
        return _teca_py.std_vector_ulong_swap(self, v)

    def begin(self):
        r"""begin(std_vector_ulong self) -> std::vector< unsigned long >::iterator"""
        return _teca_py.std_vector_ulong_begin(self)

    def end(self):
        r"""end(std_vector_ulong self) -> std::vector< unsigned long >::iterator"""
        return _teca_py.std_vector_ulong_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_ulong self) -> std::vector< unsigned long >::reverse_iterator"""
        return _teca_py.std_vector_ulong_rbegin(self)

    def rend(self):
        r"""rend(std_vector_ulong self) -> std::vector< unsigned long >::reverse_iterator"""
        return _teca_py.std_vector_ulong_rend(self)

    def clear(self):
        r"""clear(std_vector_ulong self)"""
        return _teca_py.std_vector_ulong_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_ulong self) -> std::vector< unsigned long >::allocator_type"""
        return _teca_py.std_vector_ulong_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_ulong self)"""
        return _teca_py.std_vector_ulong_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_ulong self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long >::iterator

        erase(std_vector_ulong self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator

        Parameters
        ----------
        first: std::vector< unsigned long >::iterator
        last: std::vector< unsigned long >::iterator

        """
        return _teca_py.std_vector_ulong_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_ulong self) -> std_vector_ulong
        __init__(std_vector_ulong self, std_vector_ulong other) -> std_vector_ulong

        Parameters
        ----------
        other: std::vector< unsigned long > const &

        __init__(std_vector_ulong self, std::vector< unsigned long >::size_type size) -> std_vector_ulong

        Parameters
        ----------
        size: std::vector< unsigned long >::size_type

        __init__(std_vector_ulong self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> std_vector_ulong

        Parameters
        ----------
        size: std::vector< unsigned long >::size_type
        value: std::vector< unsigned long >::value_type const &

        """
        _teca_py.std_vector_ulong_swiginit(self, _teca_py.new_std_vector_ulong(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_ulong self, std::vector< unsigned long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned long >::value_type const &

        """
        return _teca_py.std_vector_ulong_push_back(self, x)

    def front(self):
        r"""front(std_vector_ulong self) -> std::vector< unsigned long >::value_type const &"""
        return _teca_py.std_vector_ulong_front(self)

    def back(self):
        r"""back(std_vector_ulong self) -> std::vector< unsigned long >::value_type const &"""
        return _teca_py.std_vector_ulong_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_ulong self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)

        Parameters
        ----------
        n: std::vector< unsigned long >::size_type
        x: std::vector< unsigned long >::value_type const &

        """
        return _teca_py.std_vector_ulong_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_ulong self, std::vector< unsigned long >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned long >::size_type

        resize(std_vector_ulong self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< unsigned long >::size_type
        x: std::vector< unsigned long >::value_type const &

        """
        return _teca_py.std_vector_ulong_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_ulong self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long >::iterator
        x: std::vector< unsigned long >::value_type const &

        insert(std_vector_ulong self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< unsigned long >::iterator
        n: std::vector< unsigned long >::size_type
        x: std::vector< unsigned long >::value_type const &

        """
        return _teca_py.std_vector_ulong_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_ulong self, std::vector< unsigned long >::size_type n)

        Parameters
        ----------
        n: std::vector< unsigned long >::size_type

        """
        return _teca_py.std_vector_ulong_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_ulong self) -> std::vector< unsigned long >::size_type"""
        return _teca_py.std_vector_ulong_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_ulong

# Register std_vector_ulong in _teca_py:
_teca_py.std_vector_ulong_swigregister(std_vector_ulong)

class std_vector_long_long(object):
    r"""Proxy of C++ std::vector< long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_long_long self) -> SwigPyIterator"""
        return _teca_py.std_vector_long_long_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_long_long self) -> bool"""
        return _teca_py.std_vector_long_long___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_long_long self) -> bool"""
        return _teca_py.std_vector_long_long___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_long_long self) -> std::vector< long long >::size_type"""
        return _teca_py.std_vector_long_long___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_long_long self, std::vector< long long >::difference_type i, std::vector< long long >::difference_type j) -> std_vector_long_long

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        j: std::vector< long long >::difference_type

        """
        return _teca_py.std_vector_long_long___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_long_long self, std::vector< long long >::difference_type i, std::vector< long long >::difference_type j)

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        j: std::vector< long long >::difference_type

        __setslice__(std_vector_long_long self, std::vector< long long >::difference_type i, std::vector< long long >::difference_type j, std_vector_long_long v)

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        j: std::vector< long long >::difference_type
        v: std::vector< long long,std::allocator< long long > > const &

        """
        return _teca_py.std_vector_long_long___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_long_long self, std::vector< long long >::difference_type i, std::vector< long long >::difference_type j)

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        j: std::vector< long long >::difference_type

        """
        return _teca_py.std_vector_long_long___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_long_long self, std::vector< long long >::difference_type i)

        Parameters
        ----------
        i: std::vector< long long >::difference_type

        __delitem__(std_vector_long_long self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_long_long___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_long_long self, PySliceObject * slice) -> std_vector_long_long

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_long_long self, std::vector< long long >::difference_type i) -> std::vector< long long >::value_type const &

        Parameters
        ----------
        i: std::vector< long long >::difference_type

        """
        return _teca_py.std_vector_long_long___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_long_long self, PySliceObject * slice, std_vector_long_long v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< long long,std::allocator< long long > > const &

        __setitem__(std_vector_long_long self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_long_long self, std::vector< long long >::difference_type i, std::vector< long long >::value_type const & x)

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        x: std::vector< long long >::value_type const &

        """
        return _teca_py.std_vector_long_long___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_long_long self) -> std::vector< long long >::value_type"""
        return _teca_py.std_vector_long_long_pop(self)

    def append(self, x):
        r"""
        append(std_vector_long_long self, std::vector< long long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< long long >::value_type const &

        """
        return _teca_py.std_vector_long_long_append(self, x)

    def empty(self):
        r"""empty(std_vector_long_long self) -> bool"""
        return _teca_py.std_vector_long_long_empty(self)

    def size(self):
        r"""size(std_vector_long_long self) -> std::vector< long long >::size_type"""
        return _teca_py.std_vector_long_long_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_long_long self, std_vector_long_long v)

        Parameters
        ----------
        v: std::vector< long long > &

        """
        return _teca_py.std_vector_long_long_swap(self, v)

    def begin(self):
        r"""begin(std_vector_long_long self) -> std::vector< long long >::iterator"""
        return _teca_py.std_vector_long_long_begin(self)

    def end(self):
        r"""end(std_vector_long_long self) -> std::vector< long long >::iterator"""
        return _teca_py.std_vector_long_long_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_long_long self) -> std::vector< long long >::reverse_iterator"""
        return _teca_py.std_vector_long_long_rbegin(self)

    def rend(self):
        r"""rend(std_vector_long_long self) -> std::vector< long long >::reverse_iterator"""
        return _teca_py.std_vector_long_long_rend(self)

    def clear(self):
        r"""clear(std_vector_long_long self)"""
        return _teca_py.std_vector_long_long_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_long_long self) -> std::vector< long long >::allocator_type"""
        return _teca_py.std_vector_long_long_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_long_long self)"""
        return _teca_py.std_vector_long_long_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_long_long self, std::vector< long long >::iterator pos) -> std::vector< long long >::iterator

        Parameters
        ----------
        pos: std::vector< long long >::iterator

        erase(std_vector_long_long self, std::vector< long long >::iterator first, std::vector< long long >::iterator last) -> std::vector< long long >::iterator

        Parameters
        ----------
        first: std::vector< long long >::iterator
        last: std::vector< long long >::iterator

        """
        return _teca_py.std_vector_long_long_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_long_long self) -> std_vector_long_long
        __init__(std_vector_long_long self, std_vector_long_long other) -> std_vector_long_long

        Parameters
        ----------
        other: std::vector< long long > const &

        __init__(std_vector_long_long self, std::vector< long long >::size_type size) -> std_vector_long_long

        Parameters
        ----------
        size: std::vector< long long >::size_type

        __init__(std_vector_long_long self, std::vector< long long >::size_type size, std::vector< long long >::value_type const & value) -> std_vector_long_long

        Parameters
        ----------
        size: std::vector< long long >::size_type
        value: std::vector< long long >::value_type const &

        """
        _teca_py.std_vector_long_long_swiginit(self, _teca_py.new_std_vector_long_long(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_long_long self, std::vector< long long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< long long >::value_type const &

        """
        return _teca_py.std_vector_long_long_push_back(self, x)

    def front(self):
        r"""front(std_vector_long_long self) -> std::vector< long long >::value_type const &"""
        return _teca_py.std_vector_long_long_front(self)

    def back(self):
        r"""back(std_vector_long_long self) -> std::vector< long long >::value_type const &"""
        return _teca_py.std_vector_long_long_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_long_long self, std::vector< long long >::size_type n, std::vector< long long >::value_type const & x)

        Parameters
        ----------
        n: std::vector< long long >::size_type
        x: std::vector< long long >::value_type const &

        """
        return _teca_py.std_vector_long_long_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_long_long self, std::vector< long long >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< long long >::size_type

        resize(std_vector_long_long self, std::vector< long long >::size_type new_size, std::vector< long long >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< long long >::size_type
        x: std::vector< long long >::value_type const &

        """
        return _teca_py.std_vector_long_long_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_long_long self, std::vector< long long >::iterator pos, std::vector< long long >::value_type const & x) -> std::vector< long long >::iterator

        Parameters
        ----------
        pos: std::vector< long long >::iterator
        x: std::vector< long long >::value_type const &

        insert(std_vector_long_long self, std::vector< long long >::iterator pos, std::vector< long long >::size_type n, std::vector< long long >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< long long >::iterator
        n: std::vector< long long >::size_type
        x: std::vector< long long >::value_type const &

        """
        return _teca_py.std_vector_long_long_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_long_long self, std::vector< long long >::size_type n)

        Parameters
        ----------
        n: std::vector< long long >::size_type

        """
        return _teca_py.std_vector_long_long_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_long_long self) -> std::vector< long long >::size_type"""
        return _teca_py.std_vector_long_long_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_long_long

# Register std_vector_long_long in _teca_py:
_teca_py.std_vector_long_long_swigregister(std_vector_long_long)

class std_vector_ulong_long(object):
    r"""Proxy of C++ std::vector< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_ulong_long self) -> SwigPyIterator"""
        return _teca_py.std_vector_ulong_long_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_ulong_long self) -> bool"""
        return _teca_py.std_vector_ulong_long___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_ulong_long self) -> bool"""
        return _teca_py.std_vector_ulong_long___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_ulong_long self) -> std::vector< unsigned long long >::size_type"""
        return _teca_py.std_vector_ulong_long___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_ulong_long self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j) -> std_vector_ulong_long

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        """
        return _teca_py.std_vector_ulong_long___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_ulong_long self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        __setslice__(std_vector_ulong_long self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j, std_vector_ulong_long v)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type
        v: std::vector< unsigned long long,std::allocator< unsigned long long > > const &

        """
        return _teca_py.std_vector_ulong_long___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_ulong_long self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        """
        return _teca_py.std_vector_ulong_long___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_ulong_long self, std::vector< unsigned long long >::difference_type i)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type

        __delitem__(std_vector_ulong_long self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_ulong_long___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_ulong_long self, PySliceObject * slice) -> std_vector_ulong_long

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_ulong_long self, std::vector< unsigned long long >::difference_type i) -> std::vector< unsigned long long >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type

        """
        return _teca_py.std_vector_ulong_long___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_ulong_long self, PySliceObject * slice, std_vector_ulong_long v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< unsigned long long,std::allocator< unsigned long long > > const &

        __setitem__(std_vector_ulong_long self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_ulong_long self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _teca_py.std_vector_ulong_long___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_ulong_long self) -> std::vector< unsigned long long >::value_type"""
        return _teca_py.std_vector_ulong_long_pop(self)

    def append(self, x):
        r"""
        append(std_vector_ulong_long self, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned long long >::value_type const &

        """
        return _teca_py.std_vector_ulong_long_append(self, x)

    def empty(self):
        r"""empty(std_vector_ulong_long self) -> bool"""
        return _teca_py.std_vector_ulong_long_empty(self)

    def size(self):
        r"""size(std_vector_ulong_long self) -> std::vector< unsigned long long >::size_type"""
        return _teca_py.std_vector_ulong_long_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_ulong_long self, std_vector_ulong_long v)

        Parameters
        ----------
        v: std::vector< unsigned long long > &

        """
        return _teca_py.std_vector_ulong_long_swap(self, v)

    def begin(self):
        r"""begin(std_vector_ulong_long self) -> std::vector< unsigned long long >::iterator"""
        return _teca_py.std_vector_ulong_long_begin(self)

    def end(self):
        r"""end(std_vector_ulong_long self) -> std::vector< unsigned long long >::iterator"""
        return _teca_py.std_vector_ulong_long_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_ulong_long self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _teca_py.std_vector_ulong_long_rbegin(self)

    def rend(self):
        r"""rend(std_vector_ulong_long self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _teca_py.std_vector_ulong_long_rend(self)

    def clear(self):
        r"""clear(std_vector_ulong_long self)"""
        return _teca_py.std_vector_ulong_long_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_ulong_long self) -> std::vector< unsigned long long >::allocator_type"""
        return _teca_py.std_vector_ulong_long_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_ulong_long self)"""
        return _teca_py.std_vector_ulong_long_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_ulong_long self, std::vector< unsigned long long >::iterator pos) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator

        erase(std_vector_ulong_long self, std::vector< unsigned long long >::iterator first, std::vector< unsigned long long >::iterator last) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        first: std::vector< unsigned long long >::iterator
        last: std::vector< unsigned long long >::iterator

        """
        return _teca_py.std_vector_ulong_long_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_ulong_long self) -> std_vector_ulong_long
        __init__(std_vector_ulong_long self, std_vector_ulong_long other) -> std_vector_ulong_long

        Parameters
        ----------
        other: std::vector< unsigned long long > const &

        __init__(std_vector_ulong_long self, std::vector< unsigned long long >::size_type size) -> std_vector_ulong_long

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type

        __init__(std_vector_ulong_long self, std::vector< unsigned long long >::size_type size, std::vector< unsigned long long >::value_type const & value) -> std_vector_ulong_long

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type
        value: std::vector< unsigned long long >::value_type const &

        """
        _teca_py.std_vector_ulong_long_swiginit(self, _teca_py.new_std_vector_ulong_long(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_ulong_long self, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned long long >::value_type const &

        """
        return _teca_py.std_vector_ulong_long_push_back(self, x)

    def front(self):
        r"""front(std_vector_ulong_long self) -> std::vector< unsigned long long >::value_type const &"""
        return _teca_py.std_vector_ulong_long_front(self)

    def back(self):
        r"""back(std_vector_ulong_long self) -> std::vector< unsigned long long >::value_type const &"""
        return _teca_py.std_vector_ulong_long_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_ulong_long self, std::vector< unsigned long long >::size_type n, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        n: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _teca_py.std_vector_ulong_long_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_ulong_long self, std::vector< unsigned long long >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned long long >::size_type

        resize(std_vector_ulong_long self, std::vector< unsigned long long >::size_type new_size, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _teca_py.std_vector_ulong_long_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_ulong_long self, std::vector< unsigned long long >::iterator pos, std::vector< unsigned long long >::value_type const & x) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator
        x: std::vector< unsigned long long >::value_type const &

        insert(std_vector_ulong_long self, std::vector< unsigned long long >::iterator pos, std::vector< unsigned long long >::size_type n, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator
        n: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _teca_py.std_vector_ulong_long_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_ulong_long self, std::vector< unsigned long long >::size_type n)

        Parameters
        ----------
        n: std::vector< unsigned long long >::size_type

        """
        return _teca_py.std_vector_ulong_long_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_ulong_long self) -> std::vector< unsigned long long >::size_type"""
        return _teca_py.std_vector_ulong_long_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_ulong_long

# Register std_vector_ulong_long in _teca_py:
_teca_py.std_vector_ulong_long_swigregister(std_vector_ulong_long)

class std_vector_float(object):
    r"""Proxy of C++ std::vector< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_float self) -> SwigPyIterator"""
        return _teca_py.std_vector_float_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_float self) -> bool"""
        return _teca_py.std_vector_float___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_float self) -> bool"""
        return _teca_py.std_vector_float___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_float self) -> std::vector< float >::size_type"""
        return _teca_py.std_vector_float___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_float self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> std_vector_float

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type

        """
        return _teca_py.std_vector_float___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_float self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type

        __setslice__(std_vector_float self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, std_vector_float v)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type
        v: std::vector< float,std::allocator< float > > const &

        """
        return _teca_py.std_vector_float___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_float self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type

        """
        return _teca_py.std_vector_float___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_float self, std::vector< float >::difference_type i)

        Parameters
        ----------
        i: std::vector< float >::difference_type

        __delitem__(std_vector_float self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_float___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_float self, PySliceObject * slice) -> std_vector_float

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_float self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &

        Parameters
        ----------
        i: std::vector< float >::difference_type

        """
        return _teca_py.std_vector_float___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_float self, PySliceObject * slice, std_vector_float v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< float,std::allocator< float > > const &

        __setitem__(std_vector_float self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_float self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        x: std::vector< float >::value_type const &

        """
        return _teca_py.std_vector_float___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_float self) -> std::vector< float >::value_type"""
        return _teca_py.std_vector_float_pop(self)

    def append(self, x):
        r"""
        append(std_vector_float self, std::vector< float >::value_type const & x)

        Parameters
        ----------
        x: std::vector< float >::value_type const &

        """
        return _teca_py.std_vector_float_append(self, x)

    def empty(self):
        r"""empty(std_vector_float self) -> bool"""
        return _teca_py.std_vector_float_empty(self)

    def size(self):
        r"""size(std_vector_float self) -> std::vector< float >::size_type"""
        return _teca_py.std_vector_float_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_float self, std_vector_float v)

        Parameters
        ----------
        v: std::vector< float > &

        """
        return _teca_py.std_vector_float_swap(self, v)

    def begin(self):
        r"""begin(std_vector_float self) -> std::vector< float >::iterator"""
        return _teca_py.std_vector_float_begin(self)

    def end(self):
        r"""end(std_vector_float self) -> std::vector< float >::iterator"""
        return _teca_py.std_vector_float_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_float self) -> std::vector< float >::reverse_iterator"""
        return _teca_py.std_vector_float_rbegin(self)

    def rend(self):
        r"""rend(std_vector_float self) -> std::vector< float >::reverse_iterator"""
        return _teca_py.std_vector_float_rend(self)

    def clear(self):
        r"""clear(std_vector_float self)"""
        return _teca_py.std_vector_float_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_float self) -> std::vector< float >::allocator_type"""
        return _teca_py.std_vector_float_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_float self)"""
        return _teca_py.std_vector_float_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_float self, std::vector< float >::iterator pos) -> std::vector< float >::iterator

        Parameters
        ----------
        pos: std::vector< float >::iterator

        erase(std_vector_float self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator

        Parameters
        ----------
        first: std::vector< float >::iterator
        last: std::vector< float >::iterator

        """
        return _teca_py.std_vector_float_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_float self) -> std_vector_float
        __init__(std_vector_float self, std_vector_float other) -> std_vector_float

        Parameters
        ----------
        other: std::vector< float > const &

        __init__(std_vector_float self, std::vector< float >::size_type size) -> std_vector_float

        Parameters
        ----------
        size: std::vector< float >::size_type

        __init__(std_vector_float self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> std_vector_float

        Parameters
        ----------
        size: std::vector< float >::size_type
        value: std::vector< float >::value_type const &

        """
        _teca_py.std_vector_float_swiginit(self, _teca_py.new_std_vector_float(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_float self, std::vector< float >::value_type const & x)

        Parameters
        ----------
        x: std::vector< float >::value_type const &

        """
        return _teca_py.std_vector_float_push_back(self, x)

    def front(self):
        r"""front(std_vector_float self) -> std::vector< float >::value_type const &"""
        return _teca_py.std_vector_float_front(self)

    def back(self):
        r"""back(std_vector_float self) -> std::vector< float >::value_type const &"""
        return _teca_py.std_vector_float_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_float self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)

        Parameters
        ----------
        n: std::vector< float >::size_type
        x: std::vector< float >::value_type const &

        """
        return _teca_py.std_vector_float_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_float self, std::vector< float >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< float >::size_type

        resize(std_vector_float self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< float >::size_type
        x: std::vector< float >::value_type const &

        """
        return _teca_py.std_vector_float_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_float self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator

        Parameters
        ----------
        pos: std::vector< float >::iterator
        x: std::vector< float >::value_type const &

        insert(std_vector_float self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< float >::iterator
        n: std::vector< float >::size_type
        x: std::vector< float >::value_type const &

        """
        return _teca_py.std_vector_float_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_float self, std::vector< float >::size_type n)

        Parameters
        ----------
        n: std::vector< float >::size_type

        """
        return _teca_py.std_vector_float_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_float self) -> std::vector< float >::size_type"""
        return _teca_py.std_vector_float_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_float

# Register std_vector_float in _teca_py:
_teca_py.std_vector_float_swigregister(std_vector_float)

class std_vector_double(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_double self) -> SwigPyIterator"""
        return _teca_py.std_vector_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_double self) -> bool"""
        return _teca_py.std_vector_double___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_double self) -> bool"""
        return _teca_py.std_vector_double___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_double self) -> std::vector< double >::size_type"""
        return _teca_py.std_vector_double___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> std_vector_double

        Parameters
        ----------
        i: std::vector< double >::difference_type
        j: std::vector< double >::difference_type

        """
        return _teca_py.std_vector_double___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)

        Parameters
        ----------
        i: std::vector< double >::difference_type
        j: std::vector< double >::difference_type

        __setslice__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, std_vector_double v)

        Parameters
        ----------
        i: std::vector< double >::difference_type
        j: std::vector< double >::difference_type
        v: std::vector< double,std::allocator< double > > const &

        """
        return _teca_py.std_vector_double___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)

        Parameters
        ----------
        i: std::vector< double >::difference_type
        j: std::vector< double >::difference_type

        """
        return _teca_py.std_vector_double___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_double self, std::vector< double >::difference_type i)

        Parameters
        ----------
        i: std::vector< double >::difference_type

        __delitem__(std_vector_double self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_double___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_double self, PySliceObject * slice) -> std_vector_double

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_double self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &

        Parameters
        ----------
        i: std::vector< double >::difference_type

        """
        return _teca_py.std_vector_double___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_double self, PySliceObject * slice, std_vector_double v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< double,std::allocator< double > > const &

        __setitem__(std_vector_double self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)

        Parameters
        ----------
        i: std::vector< double >::difference_type
        x: std::vector< double >::value_type const &

        """
        return _teca_py.std_vector_double___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_double self) -> std::vector< double >::value_type"""
        return _teca_py.std_vector_double_pop(self)

    def append(self, x):
        r"""
        append(std_vector_double self, std::vector< double >::value_type const & x)

        Parameters
        ----------
        x: std::vector< double >::value_type const &

        """
        return _teca_py.std_vector_double_append(self, x)

    def empty(self):
        r"""empty(std_vector_double self) -> bool"""
        return _teca_py.std_vector_double_empty(self)

    def size(self):
        r"""size(std_vector_double self) -> std::vector< double >::size_type"""
        return _teca_py.std_vector_double_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_double self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double > &

        """
        return _teca_py.std_vector_double_swap(self, v)

    def begin(self):
        r"""begin(std_vector_double self) -> std::vector< double >::iterator"""
        return _teca_py.std_vector_double_begin(self)

    def end(self):
        r"""end(std_vector_double self) -> std::vector< double >::iterator"""
        return _teca_py.std_vector_double_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_double self) -> std::vector< double >::reverse_iterator"""
        return _teca_py.std_vector_double_rbegin(self)

    def rend(self):
        r"""rend(std_vector_double self) -> std::vector< double >::reverse_iterator"""
        return _teca_py.std_vector_double_rend(self)

    def clear(self):
        r"""clear(std_vector_double self)"""
        return _teca_py.std_vector_double_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_double self) -> std::vector< double >::allocator_type"""
        return _teca_py.std_vector_double_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_double self)"""
        return _teca_py.std_vector_double_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_double self, std::vector< double >::iterator pos) -> std::vector< double >::iterator

        Parameters
        ----------
        pos: std::vector< double >::iterator

        erase(std_vector_double self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator

        Parameters
        ----------
        first: std::vector< double >::iterator
        last: std::vector< double >::iterator

        """
        return _teca_py.std_vector_double_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_double self) -> std_vector_double
        __init__(std_vector_double self, std_vector_double other) -> std_vector_double

        Parameters
        ----------
        other: std::vector< double > const &

        __init__(std_vector_double self, std::vector< double >::size_type size) -> std_vector_double

        Parameters
        ----------
        size: std::vector< double >::size_type

        __init__(std_vector_double self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> std_vector_double

        Parameters
        ----------
        size: std::vector< double >::size_type
        value: std::vector< double >::value_type const &

        """
        _teca_py.std_vector_double_swiginit(self, _teca_py.new_std_vector_double(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_double self, std::vector< double >::value_type const & x)

        Parameters
        ----------
        x: std::vector< double >::value_type const &

        """
        return _teca_py.std_vector_double_push_back(self, x)

    def front(self):
        r"""front(std_vector_double self) -> std::vector< double >::value_type const &"""
        return _teca_py.std_vector_double_front(self)

    def back(self):
        r"""back(std_vector_double self) -> std::vector< double >::value_type const &"""
        return _teca_py.std_vector_double_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_double self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)

        Parameters
        ----------
        n: std::vector< double >::size_type
        x: std::vector< double >::value_type const &

        """
        return _teca_py.std_vector_double_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_double self, std::vector< double >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< double >::size_type

        resize(std_vector_double self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< double >::size_type
        x: std::vector< double >::value_type const &

        """
        return _teca_py.std_vector_double_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_double self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator

        Parameters
        ----------
        pos: std::vector< double >::iterator
        x: std::vector< double >::value_type const &

        insert(std_vector_double self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< double >::iterator
        n: std::vector< double >::size_type
        x: std::vector< double >::value_type const &

        """
        return _teca_py.std_vector_double_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_double self, std::vector< double >::size_type n)

        Parameters
        ----------
        n: std::vector< double >::size_type

        """
        return _teca_py.std_vector_double_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_double self) -> std::vector< double >::size_type"""
        return _teca_py.std_vector_double_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_double

# Register std_vector_double in _teca_py:
_teca_py.std_vector_double_swigregister(std_vector_double)

class std_vector_string(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_string self) -> SwigPyIterator"""
        return _teca_py.std_vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_string self) -> bool"""
        return _teca_py.std_vector_string___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_string self) -> bool"""
        return _teca_py.std_vector_string___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_string self) -> std::vector< std::string >::size_type"""
        return _teca_py.std_vector_string___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> std_vector_string

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _teca_py.std_vector_string___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        __setslice__(std_vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, std_vector_string v)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type
        v: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _teca_py.std_vector_string___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _teca_py.std_vector_string___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_string self, std::vector< std::string >::difference_type i)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        __delitem__(std_vector_string self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_string___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_string self, PySliceObject * slice) -> std_vector_string

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_string self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        """
        return _teca_py.std_vector_string___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_string self, PySliceObject * slice, std_vector_string v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::string,std::allocator< std::string > > const &

        __setitem__(std_vector_string self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        x: std::vector< std::string >::value_type const &

        """
        return _teca_py.std_vector_string___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_string self) -> std::vector< std::string >::value_type"""
        return _teca_py.std_vector_string_pop(self)

    def append(self, x):
        r"""
        append(std_vector_string self, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _teca_py.std_vector_string_append(self, x)

    def empty(self):
        r"""empty(std_vector_string self) -> bool"""
        return _teca_py.std_vector_string_empty(self)

    def size(self):
        r"""size(std_vector_string self) -> std::vector< std::string >::size_type"""
        return _teca_py.std_vector_string_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_string self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string > &

        """
        return _teca_py.std_vector_string_swap(self, v)

    def begin(self):
        r"""begin(std_vector_string self) -> std::vector< std::string >::iterator"""
        return _teca_py.std_vector_string_begin(self)

    def end(self):
        r"""end(std_vector_string self) -> std::vector< std::string >::iterator"""
        return _teca_py.std_vector_string_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _teca_py.std_vector_string_rbegin(self)

    def rend(self):
        r"""rend(std_vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _teca_py.std_vector_string_rend(self)

    def clear(self):
        r"""clear(std_vector_string self)"""
        return _teca_py.std_vector_string_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_string self) -> std::vector< std::string >::allocator_type"""
        return _teca_py.std_vector_string_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_string self)"""
        return _teca_py.std_vector_string_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_string self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator

        erase(std_vector_string self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator

        Parameters
        ----------
        first: std::vector< std::string >::iterator
        last: std::vector< std::string >::iterator

        """
        return _teca_py.std_vector_string_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_string self) -> std_vector_string
        __init__(std_vector_string self, std_vector_string other) -> std_vector_string

        Parameters
        ----------
        other: std::vector< std::string > const &

        __init__(std_vector_string self, std::vector< std::string >::size_type size) -> std_vector_string

        Parameters
        ----------
        size: std::vector< std::string >::size_type

        __init__(std_vector_string self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> std_vector_string

        Parameters
        ----------
        size: std::vector< std::string >::size_type
        value: std::vector< std::string >::value_type const &

        """
        _teca_py.std_vector_string_swiginit(self, _teca_py.new_std_vector_string(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_string self, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _teca_py.std_vector_string_push_back(self, x)

    def front(self):
        r"""front(std_vector_string self) -> std::vector< std::string >::value_type const &"""
        return _teca_py.std_vector_string_front(self)

    def back(self):
        r"""back(std_vector_string self) -> std::vector< std::string >::value_type const &"""
        return _teca_py.std_vector_string_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_string self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _teca_py.std_vector_string_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_string self, std::vector< std::string >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type

        resize(std_vector_string self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _teca_py.std_vector_string_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        x: std::vector< std::string >::value_type const &

        insert(std_vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _teca_py.std_vector_string_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_string self, std::vector< std::string >::size_type n)

        Parameters
        ----------
        n: std::vector< std::string >::size_type

        """
        return _teca_py.std_vector_string_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_string self) -> std::vector< std::string >::size_type"""
        return _teca_py.std_vector_string_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_string

# Register std_vector_string in _teca_py:
_teca_py.std_vector_string_swigregister(std_vector_string)

SHARED_PTR_DISOWN = _teca_py.SHARED_PTR_DISOWN

class buffer_handle_float(object):
    r"""Proxy of C++ hamr::buffer_handle< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_float

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_float self) -> buffer_handle_float
        __init__(buffer_handle_float self, std::shared_ptr< float > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_float

        Parameters
        ----------
        src: std::shared_ptr< float > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_float self, buffer_handle_float other) -> buffer_handle_float

        Parameters
        ----------
        other: hamr::buffer_handle< float > const &

        """
        _teca_py.buffer_handle_float_swiginit(self, _teca_py.new_buffer_handle_float(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_float self) -> PyObject *"""
        return _teca_py.buffer_handle_float_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_float self) -> PyObject *"""
        return _teca_py.buffer_handle_float_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_float self) -> PyObject *"""
        return _teca_py.buffer_handle_float_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_float self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_float_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_float_m_data_get, _teca_py.buffer_handle_float_m_data_set, doc=r"""m_data : std::shared_ptr<(float)>""")
    m_size = property(_teca_py.buffer_handle_float_m_size_get, _teca_py.buffer_handle_float_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_float_m_read_only_get, _teca_py.buffer_handle_float_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_float_m_cpu_accessible_get, _teca_py.buffer_handle_float_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_float_m_cuda_accessible_get, _teca_py.buffer_handle_float_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_float self) -> PyObject *"""
        return _teca_py.buffer_handle_float___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_float in _teca_py:
_teca_py.buffer_handle_float_swigregister(buffer_handle_float)

class buffer_handle_double(object):
    r"""Proxy of C++ hamr::buffer_handle< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_double

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_double self) -> buffer_handle_double
        __init__(buffer_handle_double self, std::shared_ptr< double > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_double

        Parameters
        ----------
        src: std::shared_ptr< double > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_double self, buffer_handle_double other) -> buffer_handle_double

        Parameters
        ----------
        other: hamr::buffer_handle< double > const &

        """
        _teca_py.buffer_handle_double_swiginit(self, _teca_py.new_buffer_handle_double(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_double self) -> PyObject *"""
        return _teca_py.buffer_handle_double_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_double self) -> PyObject *"""
        return _teca_py.buffer_handle_double_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_double self) -> PyObject *"""
        return _teca_py.buffer_handle_double_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_double self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_double_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_double_m_data_get, _teca_py.buffer_handle_double_m_data_set, doc=r"""m_data : std::shared_ptr<(double)>""")
    m_size = property(_teca_py.buffer_handle_double_m_size_get, _teca_py.buffer_handle_double_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_double_m_read_only_get, _teca_py.buffer_handle_double_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_double_m_cpu_accessible_get, _teca_py.buffer_handle_double_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_double_m_cuda_accessible_get, _teca_py.buffer_handle_double_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_double self) -> PyObject *"""
        return _teca_py.buffer_handle_double___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_double in _teca_py:
_teca_py.buffer_handle_double_swigregister(buffer_handle_double)

class buffer_handle_char(object):
    r"""Proxy of C++ hamr::buffer_handle< char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_char

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_char self) -> buffer_handle_char
        __init__(buffer_handle_char self, std::shared_ptr< char > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_char

        Parameters
        ----------
        src: std::shared_ptr< char > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_char self, buffer_handle_char other) -> buffer_handle_char

        Parameters
        ----------
        other: hamr::buffer_handle< char > const &

        """
        _teca_py.buffer_handle_char_swiginit(self, _teca_py.new_buffer_handle_char(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_char self) -> PyObject *"""
        return _teca_py.buffer_handle_char_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_char self) -> PyObject *"""
        return _teca_py.buffer_handle_char_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_char self) -> PyObject *"""
        return _teca_py.buffer_handle_char_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_char self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_char_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_char_m_data_get, _teca_py.buffer_handle_char_m_data_set, doc=r"""m_data : std::shared_ptr<(char)>""")
    m_size = property(_teca_py.buffer_handle_char_m_size_get, _teca_py.buffer_handle_char_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_char_m_read_only_get, _teca_py.buffer_handle_char_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_char_m_cpu_accessible_get, _teca_py.buffer_handle_char_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_char_m_cuda_accessible_get, _teca_py.buffer_handle_char_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_char self) -> PyObject *"""
        return _teca_py.buffer_handle_char___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_char in _teca_py:
_teca_py.buffer_handle_char_swigregister(buffer_handle_char)

class buffer_handle_short(object):
    r"""Proxy of C++ hamr::buffer_handle< short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_short

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_short self) -> buffer_handle_short
        __init__(buffer_handle_short self, std::shared_ptr< short > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_short

        Parameters
        ----------
        src: std::shared_ptr< short > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_short self, buffer_handle_short other) -> buffer_handle_short

        Parameters
        ----------
        other: hamr::buffer_handle< short > const &

        """
        _teca_py.buffer_handle_short_swiginit(self, _teca_py.new_buffer_handle_short(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_short self) -> PyObject *"""
        return _teca_py.buffer_handle_short_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_short self) -> PyObject *"""
        return _teca_py.buffer_handle_short_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_short self) -> PyObject *"""
        return _teca_py.buffer_handle_short_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_short self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_short_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_short_m_data_get, _teca_py.buffer_handle_short_m_data_set, doc=r"""m_data : std::shared_ptr<(short)>""")
    m_size = property(_teca_py.buffer_handle_short_m_size_get, _teca_py.buffer_handle_short_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_short_m_read_only_get, _teca_py.buffer_handle_short_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_short_m_cpu_accessible_get, _teca_py.buffer_handle_short_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_short_m_cuda_accessible_get, _teca_py.buffer_handle_short_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_short self) -> PyObject *"""
        return _teca_py.buffer_handle_short___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_short in _teca_py:
_teca_py.buffer_handle_short_swigregister(buffer_handle_short)

class buffer_handle_int(object):
    r"""Proxy of C++ hamr::buffer_handle< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_int

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_int self) -> buffer_handle_int
        __init__(buffer_handle_int self, std::shared_ptr< int > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_int

        Parameters
        ----------
        src: std::shared_ptr< int > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_int self, buffer_handle_int other) -> buffer_handle_int

        Parameters
        ----------
        other: hamr::buffer_handle< int > const &

        """
        _teca_py.buffer_handle_int_swiginit(self, _teca_py.new_buffer_handle_int(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_int self) -> PyObject *"""
        return _teca_py.buffer_handle_int_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_int self) -> PyObject *"""
        return _teca_py.buffer_handle_int_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_int self) -> PyObject *"""
        return _teca_py.buffer_handle_int_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_int self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_int_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_int_m_data_get, _teca_py.buffer_handle_int_m_data_set, doc=r"""m_data : std::shared_ptr<(int)>""")
    m_size = property(_teca_py.buffer_handle_int_m_size_get, _teca_py.buffer_handle_int_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_int_m_read_only_get, _teca_py.buffer_handle_int_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_int_m_cpu_accessible_get, _teca_py.buffer_handle_int_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_int_m_cuda_accessible_get, _teca_py.buffer_handle_int_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_int self) -> PyObject *"""
        return _teca_py.buffer_handle_int___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_int in _teca_py:
_teca_py.buffer_handle_int_swigregister(buffer_handle_int)

class buffer_handle_long(object):
    r"""Proxy of C++ hamr::buffer_handle< long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_long

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_long self) -> buffer_handle_long
        __init__(buffer_handle_long self, std::shared_ptr< long > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_long

        Parameters
        ----------
        src: std::shared_ptr< long > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_long self, buffer_handle_long other) -> buffer_handle_long

        Parameters
        ----------
        other: hamr::buffer_handle< long > const &

        """
        _teca_py.buffer_handle_long_swiginit(self, _teca_py.new_buffer_handle_long(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_long self) -> PyObject *"""
        return _teca_py.buffer_handle_long_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_long self) -> PyObject *"""
        return _teca_py.buffer_handle_long_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_long self) -> PyObject *"""
        return _teca_py.buffer_handle_long_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_long self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_long_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_long_m_data_get, _teca_py.buffer_handle_long_m_data_set, doc=r"""m_data : std::shared_ptr<(long)>""")
    m_size = property(_teca_py.buffer_handle_long_m_size_get, _teca_py.buffer_handle_long_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_long_m_read_only_get, _teca_py.buffer_handle_long_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_long_m_cpu_accessible_get, _teca_py.buffer_handle_long_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_long_m_cuda_accessible_get, _teca_py.buffer_handle_long_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_long self) -> PyObject *"""
        return _teca_py.buffer_handle_long___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_long in _teca_py:
_teca_py.buffer_handle_long_swigregister(buffer_handle_long)

class buffer_handle_long_long(object):
    r"""Proxy of C++ hamr::buffer_handle< long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_long_long

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_long_long self) -> buffer_handle_long_long
        __init__(buffer_handle_long_long self, std::shared_ptr< long long > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_long_long

        Parameters
        ----------
        src: std::shared_ptr< long long > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_long_long self, buffer_handle_long_long other) -> buffer_handle_long_long

        Parameters
        ----------
        other: hamr::buffer_handle< long long > const &

        """
        _teca_py.buffer_handle_long_long_swiginit(self, _teca_py.new_buffer_handle_long_long(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_long_long self) -> PyObject *"""
        return _teca_py.buffer_handle_long_long_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_long_long self) -> PyObject *"""
        return _teca_py.buffer_handle_long_long_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_long_long self) -> PyObject *"""
        return _teca_py.buffer_handle_long_long_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_long_long self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_long_long_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_long_long_m_data_get, _teca_py.buffer_handle_long_long_m_data_set, doc=r"""m_data : std::shared_ptr<(long long)>""")
    m_size = property(_teca_py.buffer_handle_long_long_m_size_get, _teca_py.buffer_handle_long_long_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_long_long_m_read_only_get, _teca_py.buffer_handle_long_long_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_long_long_m_cpu_accessible_get, _teca_py.buffer_handle_long_long_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_long_long_m_cuda_accessible_get, _teca_py.buffer_handle_long_long_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_long_long self) -> PyObject *"""
        return _teca_py.buffer_handle_long_long___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_long_long in _teca_py:
_teca_py.buffer_handle_long_long_swigregister(buffer_handle_long_long)

class buffer_handle_unsigned_char(object):
    r"""Proxy of C++ hamr::buffer_handle< unsigned char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_unsigned_char

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_unsigned_char self) -> buffer_handle_unsigned_char
        __init__(buffer_handle_unsigned_char self, std::shared_ptr< unsigned char > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_unsigned_char

        Parameters
        ----------
        src: std::shared_ptr< unsigned char > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_unsigned_char self, buffer_handle_unsigned_char other) -> buffer_handle_unsigned_char

        Parameters
        ----------
        other: hamr::buffer_handle< unsigned char > const &

        """
        _teca_py.buffer_handle_unsigned_char_swiginit(self, _teca_py.new_buffer_handle_unsigned_char(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_unsigned_char self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_char_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_unsigned_char self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_char_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_unsigned_char self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_char_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_unsigned_char self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_unsigned_char_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_unsigned_char_m_data_get, _teca_py.buffer_handle_unsigned_char_m_data_set, doc=r"""m_data : std::shared_ptr<(unsigned char)>""")
    m_size = property(_teca_py.buffer_handle_unsigned_char_m_size_get, _teca_py.buffer_handle_unsigned_char_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_unsigned_char_m_read_only_get, _teca_py.buffer_handle_unsigned_char_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_unsigned_char_m_cpu_accessible_get, _teca_py.buffer_handle_unsigned_char_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_unsigned_char_m_cuda_accessible_get, _teca_py.buffer_handle_unsigned_char_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_unsigned_char self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_char___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_unsigned_char in _teca_py:
_teca_py.buffer_handle_unsigned_char_swigregister(buffer_handle_unsigned_char)

class buffer_handle_unsigned_short(object):
    r"""Proxy of C++ hamr::buffer_handle< unsigned short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_unsigned_short

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_unsigned_short self) -> buffer_handle_unsigned_short
        __init__(buffer_handle_unsigned_short self, std::shared_ptr< unsigned short > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_unsigned_short

        Parameters
        ----------
        src: std::shared_ptr< unsigned short > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_unsigned_short self, buffer_handle_unsigned_short other) -> buffer_handle_unsigned_short

        Parameters
        ----------
        other: hamr::buffer_handle< unsigned short > const &

        """
        _teca_py.buffer_handle_unsigned_short_swiginit(self, _teca_py.new_buffer_handle_unsigned_short(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_unsigned_short self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_short_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_unsigned_short self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_short_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_unsigned_short self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_short_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_unsigned_short self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_unsigned_short_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_unsigned_short_m_data_get, _teca_py.buffer_handle_unsigned_short_m_data_set, doc=r"""m_data : std::shared_ptr<(unsigned short)>""")
    m_size = property(_teca_py.buffer_handle_unsigned_short_m_size_get, _teca_py.buffer_handle_unsigned_short_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_unsigned_short_m_read_only_get, _teca_py.buffer_handle_unsigned_short_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_unsigned_short_m_cpu_accessible_get, _teca_py.buffer_handle_unsigned_short_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_unsigned_short_m_cuda_accessible_get, _teca_py.buffer_handle_unsigned_short_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_unsigned_short self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_short___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_unsigned_short in _teca_py:
_teca_py.buffer_handle_unsigned_short_swigregister(buffer_handle_unsigned_short)

class buffer_handle_unsigned_int(object):
    r"""Proxy of C++ hamr::buffer_handle< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_unsigned_int

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_unsigned_int self) -> buffer_handle_unsigned_int
        __init__(buffer_handle_unsigned_int self, std::shared_ptr< unsigned int > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_unsigned_int

        Parameters
        ----------
        src: std::shared_ptr< unsigned int > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_unsigned_int self, buffer_handle_unsigned_int other) -> buffer_handle_unsigned_int

        Parameters
        ----------
        other: hamr::buffer_handle< unsigned int > const &

        """
        _teca_py.buffer_handle_unsigned_int_swiginit(self, _teca_py.new_buffer_handle_unsigned_int(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_unsigned_int self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_int_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_unsigned_int self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_int_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_unsigned_int self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_int_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_unsigned_int self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_unsigned_int_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_unsigned_int_m_data_get, _teca_py.buffer_handle_unsigned_int_m_data_set, doc=r"""m_data : std::shared_ptr<(unsigned int)>""")
    m_size = property(_teca_py.buffer_handle_unsigned_int_m_size_get, _teca_py.buffer_handle_unsigned_int_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_unsigned_int_m_read_only_get, _teca_py.buffer_handle_unsigned_int_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_unsigned_int_m_cpu_accessible_get, _teca_py.buffer_handle_unsigned_int_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_unsigned_int_m_cuda_accessible_get, _teca_py.buffer_handle_unsigned_int_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_unsigned_int self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_int___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_unsigned_int in _teca_py:
_teca_py.buffer_handle_unsigned_int_swigregister(buffer_handle_unsigned_int)

class buffer_handle_unsigned_long(object):
    r"""Proxy of C++ hamr::buffer_handle< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_unsigned_long

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_unsigned_long self) -> buffer_handle_unsigned_long
        __init__(buffer_handle_unsigned_long self, std::shared_ptr< unsigned long > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_unsigned_long

        Parameters
        ----------
        src: std::shared_ptr< unsigned long > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_unsigned_long self, buffer_handle_unsigned_long other) -> buffer_handle_unsigned_long

        Parameters
        ----------
        other: hamr::buffer_handle< unsigned long > const &

        """
        _teca_py.buffer_handle_unsigned_long_swiginit(self, _teca_py.new_buffer_handle_unsigned_long(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_unsigned_long self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_long_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_unsigned_long self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_long_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_unsigned_long self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_long_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_unsigned_long self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_unsigned_long_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_unsigned_long_m_data_get, _teca_py.buffer_handle_unsigned_long_m_data_set, doc=r"""m_data : std::shared_ptr<(unsigned long)>""")
    m_size = property(_teca_py.buffer_handle_unsigned_long_m_size_get, _teca_py.buffer_handle_unsigned_long_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_unsigned_long_m_read_only_get, _teca_py.buffer_handle_unsigned_long_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_unsigned_long_m_cpu_accessible_get, _teca_py.buffer_handle_unsigned_long_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_unsigned_long_m_cuda_accessible_get, _teca_py.buffer_handle_unsigned_long_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_unsigned_long self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_long___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_unsigned_long in _teca_py:
_teca_py.buffer_handle_unsigned_long_swigregister(buffer_handle_unsigned_long)

class buffer_handle_unsigned_long_long(object):
    r"""Proxy of C++ hamr::buffer_handle< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_buffer_handle_unsigned_long_long

    def __init__(self, *args):
        r"""
        __init__(buffer_handle_unsigned_long_long self) -> buffer_handle_unsigned_long_long
        __init__(buffer_handle_unsigned_long_long self, std::shared_ptr< unsigned long long > const & src, size_t size, int read_only, int cpu_accessible, int cuda_accessible) -> buffer_handle_unsigned_long_long

        Parameters
        ----------
        src: std::shared_ptr< unsigned long long > const &
        size: size_t
        read_only: int
        cpu_accessible: int
        cuda_accessible: int

        __init__(buffer_handle_unsigned_long_long self, buffer_handle_unsigned_long_long other) -> buffer_handle_unsigned_long_long

        Parameters
        ----------
        other: hamr::buffer_handle< unsigned long long > const &

        """
        _teca_py.buffer_handle_unsigned_long_long_swiginit(self, _teca_py.new_buffer_handle_unsigned_long_long(*args))

    def get_cuda_array_interface(self):
        r"""get_cuda_array_interface(buffer_handle_unsigned_long_long self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_long_long_get_cuda_array_interface(self)

    def get_numpy_array_interface(self):
        r"""get_numpy_array_interface(buffer_handle_unsigned_long_long self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_long_long_get_numpy_array_interface(self)

    def get_array_interface(self):
        r"""get_array_interface(buffer_handle_unsigned_long_long self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_long_long_get_array_interface(self)

    def to_stream(self, os):
        r"""
        to_stream(buffer_handle_unsigned_long_long self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.buffer_handle_unsigned_long_long_to_stream(self, os)
    m_data = property(_teca_py.buffer_handle_unsigned_long_long_m_data_get, _teca_py.buffer_handle_unsigned_long_long_m_data_set, doc=r"""m_data : std::shared_ptr<(unsigned long long)>""")
    m_size = property(_teca_py.buffer_handle_unsigned_long_long_m_size_get, _teca_py.buffer_handle_unsigned_long_long_m_size_set, doc=r"""m_size : size_t""")
    m_read_only = property(_teca_py.buffer_handle_unsigned_long_long_m_read_only_get, _teca_py.buffer_handle_unsigned_long_long_m_read_only_set, doc=r"""m_read_only : int""")
    m_cpu_accessible = property(_teca_py.buffer_handle_unsigned_long_long_m_cpu_accessible_get, _teca_py.buffer_handle_unsigned_long_long_m_cpu_accessible_set, doc=r"""m_cpu_accessible : int""")
    m_cuda_accessible = property(_teca_py.buffer_handle_unsigned_long_long_m_cuda_accessible_get, _teca_py.buffer_handle_unsigned_long_long_m_cuda_accessible_set, doc=r"""m_cuda_accessible : int""")

    def __str__(self):
        r"""__str__(buffer_handle_unsigned_long_long self) -> PyObject *"""
        return _teca_py.buffer_handle_unsigned_long_long___str__(self)

    @property
    def __array_interface__(self):
        return self.get_numpy_array_interface()

    @property
    def __cuda_array_interface__(self):
        return self.get_cuda_array_interface()


# Register buffer_handle_unsigned_long_long in _teca_py:
_teca_py.buffer_handle_unsigned_long_long_swigregister(buffer_handle_unsigned_long_long)

variant_array_allocator_same = _teca_py.variant_array_allocator_same

variant_array_allocator_none = _teca_py.variant_array_allocator_none

variant_array_allocator_cpp = _teca_py.variant_array_allocator_cpp

variant_array_allocator_malloc = _teca_py.variant_array_allocator_malloc

variant_array_allocator_cuda = _teca_py.variant_array_allocator_cuda

variant_array_allocator_cuda_uva = _teca_py.variant_array_allocator_cuda_uva

variant_array_allocator_hip = _teca_py.variant_array_allocator_hip

variant_array_allocator_hip_uva = _teca_py.variant_array_allocator_hip_uva

variant_array_allocator_openmp = _teca_py.variant_array_allocator_openmp


def get_allocator_name(alloc):
    r"""
    get_allocator_name(hamr::buffer_allocator alloc) -> char const *

    Parameters
    ----------
    alloc: enum hamr::buffer_allocator

    """
    return _teca_py.get_allocator_name(alloc)

def cpu_accessible(alloc):
    r"""
    cpu_accessible(hamr::buffer_allocator alloc) -> int

    Parameters
    ----------
    alloc: enum hamr::buffer_allocator

    """
    return _teca_py.cpu_accessible(alloc)

def cuda_accessible(alloc):
    r"""
    cuda_accessible(hamr::buffer_allocator alloc) -> int

    Parameters
    ----------
    alloc: enum hamr::buffer_allocator

    """
    return _teca_py.cuda_accessible(alloc)

def hip_accessible(alloc):
    r"""
    hip_accessible(hamr::buffer_allocator alloc) -> int

    Parameters
    ----------
    alloc: enum hamr::buffer_allocator

    """
    return _teca_py.hip_accessible(alloc)

def openmp_accessible(alloc):
    r"""
    openmp_accessible(hamr::buffer_allocator alloc) -> int

    Parameters
    ----------
    alloc: enum hamr::buffer_allocator

    """
    return _teca_py.openmp_accessible(alloc)

def assert_valid_allocator(alloc):
    r"""
    assert_valid_allocator(hamr::buffer_allocator alloc)

    Parameters
    ----------
    alloc: enum hamr::buffer_allocator

    """
    return _teca_py.assert_valid_allocator(alloc)
class teca_profiler(object):
    r"""Proxy of C++ teca_profiler class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def initialize():
        r"""initialize() -> int"""
        return _teca_py.teca_profiler_initialize()

    @staticmethod
    def finalize():
        r"""finalize() -> int"""
        return _teca_py.teca_profiler_finalize()

    @staticmethod
    def flush():
        r"""flush() -> int"""
        return _teca_py.teca_profiler_flush()

    @staticmethod
    def set_communicator(comm):
        r"""
        set_communicator(MPI_Comm comm)

        Parameters
        ----------
        comm: MPI_Comm

        """
        return _teca_py.teca_profiler_set_communicator(comm)

    @staticmethod
    def set_timer_log_file(file_name):
        r"""
        set_timer_log_file(std::string const & file_name)

        Parameters
        ----------
        file_name: std::string const &

        """
        return _teca_py.teca_profiler_set_timer_log_file(file_name)

    @staticmethod
    def set_mem_prof_log_file(file_name):
        r"""
        set_mem_prof_log_file(std::string const & file_name)

        Parameters
        ----------
        file_name: std::string const &

        """
        return _teca_py.teca_profiler_set_mem_prof_log_file(file_name)

    @staticmethod
    def set_mem_prof_interval(interval):
        r"""
        set_mem_prof_interval(int interval)

        Parameters
        ----------
        interval: int

        """
        return _teca_py.teca_profiler_set_mem_prof_interval(interval)

    @staticmethod
    def enable(arg=0x03):
        r"""
        enable(int arg=0x03)

        Parameters
        ----------
        arg: int

        """
        return _teca_py.teca_profiler_enable(arg)

    @staticmethod
    def disable():
        r"""disable()"""
        return _teca_py.teca_profiler_disable()

    @staticmethod
    def enabled():
        r"""enabled() -> bool"""
        return _teca_py.teca_profiler_enabled()

    @staticmethod
    def start_event(eventname):
        r"""
        start_event(char const * eventname) -> int

        Parameters
        ----------
        eventname: char const *

        """
        return _teca_py.teca_profiler_start_event(eventname)

    @staticmethod
    def end_event(eventname):
        r"""
        end_event(char const * eventname) -> int

        Parameters
        ----------
        eventname: char const *

        """
        return _teca_py.teca_profiler_end_event(eventname)

    @staticmethod
    def write_c_stdio(file_name, mode, str):
        r"""
        write_c_stdio(char const * file_name, char const * mode, std::string const & str) -> int

        Parameters
        ----------
        file_name: char const *
        mode: char const *
        str: std::string const &

        """
        return _teca_py.teca_profiler_write_c_stdio(file_name, mode, str)

    @staticmethod
    def write_mpi_io(comm, file_name, str):
        r"""
        write_mpi_io(MPI_Comm comm, char const * file_name, std::string const & str) -> int

        Parameters
        ----------
        comm: MPI_Comm
        file_name: char const *
        str: std::string const &

        """
        return _teca_py.teca_profiler_write_mpi_io(comm, file_name, str)

    @staticmethod
    def validate():
        r"""validate() -> int"""
        return _teca_py.teca_profiler_validate()

    @staticmethod
    def to_stream(os):
        r"""
        to_stream(ostream os) -> int

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.teca_profiler_to_stream(os)

    def __init__(self):
        r"""__init__(teca_profiler self) -> teca_profiler"""
        _teca_py.teca_profiler_swiginit(self, _teca_py.new_teca_profiler())
    __swig_destroy__ = _teca_py.delete_teca_profiler

# Register teca_profiler in _teca_py:
_teca_py.teca_profiler_swigregister(teca_profiler)

def teca_profiler_initialize():
    r"""teca_profiler_initialize() -> int"""
    return _teca_py.teca_profiler_initialize()

def teca_profiler_finalize():
    r"""teca_profiler_finalize() -> int"""
    return _teca_py.teca_profiler_finalize()

def teca_profiler_flush():
    r"""teca_profiler_flush() -> int"""
    return _teca_py.teca_profiler_flush()

def teca_profiler_set_communicator(comm):
    r"""
    teca_profiler_set_communicator(MPI_Comm comm)

    Parameters
    ----------
    comm: MPI_Comm

    """
    return _teca_py.teca_profiler_set_communicator(comm)

def teca_profiler_set_timer_log_file(file_name):
    r"""
    teca_profiler_set_timer_log_file(std::string const & file_name)

    Parameters
    ----------
    file_name: std::string const &

    """
    return _teca_py.teca_profiler_set_timer_log_file(file_name)

def teca_profiler_set_mem_prof_log_file(file_name):
    r"""
    teca_profiler_set_mem_prof_log_file(std::string const & file_name)

    Parameters
    ----------
    file_name: std::string const &

    """
    return _teca_py.teca_profiler_set_mem_prof_log_file(file_name)

def teca_profiler_set_mem_prof_interval(interval):
    r"""
    teca_profiler_set_mem_prof_interval(int interval)

    Parameters
    ----------
    interval: int

    """
    return _teca_py.teca_profiler_set_mem_prof_interval(interval)

def teca_profiler_enable(arg=0x03):
    r"""
    teca_profiler_enable(int arg=0x03)

    Parameters
    ----------
    arg: int

    """
    return _teca_py.teca_profiler_enable(arg)

def teca_profiler_disable():
    r"""teca_profiler_disable()"""
    return _teca_py.teca_profiler_disable()

def teca_profiler_enabled():
    r"""teca_profiler_enabled() -> bool"""
    return _teca_py.teca_profiler_enabled()

def teca_profiler_start_event(eventname):
    r"""
    teca_profiler_start_event(char const * eventname) -> int

    Parameters
    ----------
    eventname: char const *

    """
    return _teca_py.teca_profiler_start_event(eventname)

def teca_profiler_end_event(eventname):
    r"""
    teca_profiler_end_event(char const * eventname) -> int

    Parameters
    ----------
    eventname: char const *

    """
    return _teca_py.teca_profiler_end_event(eventname)

def teca_profiler_write_c_stdio(file_name, mode, str):
    r"""
    teca_profiler_write_c_stdio(char const * file_name, char const * mode, std::string const & str) -> int

    Parameters
    ----------
    file_name: char const *
    mode: char const *
    str: std::string const &

    """
    return _teca_py.teca_profiler_write_c_stdio(file_name, mode, str)

def teca_profiler_write_mpi_io(comm, file_name, str):
    r"""
    teca_profiler_write_mpi_io(MPI_Comm comm, char const * file_name, std::string const & str) -> int

    Parameters
    ----------
    comm: MPI_Comm
    file_name: char const *
    str: std::string const &

    """
    return _teca_py.teca_profiler_write_mpi_io(comm, file_name, str)

def teca_profiler_validate():
    r"""teca_profiler_validate() -> int"""
    return _teca_py.teca_profiler_validate()

def teca_profiler_to_stream(os):
    r"""
    teca_profiler_to_stream(ostream os) -> int

    Parameters
    ----------
    os: std::ostream &

    """
    return _teca_py.teca_profiler_to_stream(os)

class teca_time_py_event(object):
    r"""Proxy of C++ teca_time_py_event class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name):
        r"""
        __init__(teca_time_py_event self, std::string const & name) -> teca_time_py_event

        Parameters
        ----------
        name: std::string const &

        """
        _teca_py.teca_time_py_event_swiginit(self, _teca_py.new_teca_time_py_event(name))
    __swig_destroy__ = _teca_py.delete_teca_time_py_event

# Register teca_time_py_event in _teca_py:
_teca_py.teca_time_py_event_swigregister(teca_time_py_event)

class teca_parallel_id(object):
    r"""Proxy of C++ teca_parallel_id class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __str__(self):
        r"""__str__(teca_parallel_id self) -> PyObject *"""
        return _teca_py.teca_parallel_id___str__(self)

    def __init__(self):
        r"""__init__(teca_parallel_id self) -> teca_parallel_id"""
        _teca_py.teca_parallel_id_swiginit(self, _teca_py.new_teca_parallel_id())
    __swig_destroy__ = _teca_py.delete_teca_parallel_id

# Register teca_parallel_id in _teca_py:
_teca_py.teca_parallel_id_swigregister(teca_parallel_id)

class teca_binary_stream(object):
    r"""Proxy of C++ teca_binary_stream class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_teca_binary_stream

    def __init__(self, *args):
        r"""
        __init__(teca_binary_stream self) -> teca_binary_stream
        __init__(teca_binary_stream self, teca_binary_stream s) -> teca_binary_stream

        Parameters
        ----------
        s: teca_binary_stream const &

        """
        _teca_py.teca_binary_stream_swiginit(self, _teca_py.new_teca_binary_stream(*args))

    def __nonzero__(self):
        return _teca_py.teca_binary_stream___nonzero__(self)
    __bool__ = __nonzero__



    def clear(self):
        r"""clear(teca_binary_stream self)"""
        return _teca_py.teca_binary_stream_clear(self)

    def resize(self, n_bytes):
        r"""
        resize(teca_binary_stream self, unsigned long n_bytes)

        Parameters
        ----------
        n_bytes: unsigned long

        """
        return _teca_py.teca_binary_stream_resize(self, n_bytes)

    def grow(self, n_bytes):
        r"""
        grow(teca_binary_stream self, unsigned long n_bytes)

        Parameters
        ----------
        n_bytes: unsigned long

        """
        return _teca_py.teca_binary_stream_grow(self, n_bytes)

    def size(self):
        r"""size(teca_binary_stream self) -> unsigned long"""
        return _teca_py.teca_binary_stream_size(self)

    def capacity(self):
        r"""capacity(teca_binary_stream self) -> unsigned long"""
        return _teca_py.teca_binary_stream_capacity(self)

    def set_read_pos(self, n):
        r"""
        set_read_pos(teca_binary_stream self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_binary_stream_set_read_pos(self, n)

    def set_write_pos(self, n):
        r"""
        set_write_pos(teca_binary_stream self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_binary_stream_set_write_pos(self, n)

    def swap(self, other):
        r"""
        swap(teca_binary_stream self, teca_binary_stream other)

        Parameters
        ----------
        other: teca_binary_stream &

        """
        return _teca_py.teca_binary_stream_swap(self, other)

    def pack(self, *args):
        r"""
        pack(teca_binary_stream self, std::string const * v, unsigned long n)

        Parameters
        ----------
        v: std::string const *
        n: unsigned long

        pack(teca_binary_stream self, std::string const & str)

        Parameters
        ----------
        str: std::string const &

        pack(teca_binary_stream self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _teca_py.teca_binary_stream_pack(self, *args)

    def unpack(self, *args):
        r"""
        unpack(teca_binary_stream self, std::string * v, unsigned long n)

        Parameters
        ----------
        v: std::string *
        n: unsigned long

        unpack(teca_binary_stream self, std::string & str)

        Parameters
        ----------
        str: std::string &

        unpack(teca_binary_stream self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > &

        """
        return _teca_py.teca_binary_stream_unpack(self, *args)

    def expect(self, str):
        r"""
        expect(teca_binary_stream self, char const * str) -> int

        Parameters
        ----------
        str: char const *

        """
        return _teca_py.teca_binary_stream_expect(self, str)

    def broadcast(self, comm, root_rank=0):
        r"""
        broadcast(teca_binary_stream self, MPI_Comm comm, int root_rank=0) -> int

        Parameters
        ----------
        comm: MPI_Comm
        root_rank: int

        """
        return _teca_py.teca_binary_stream_broadcast(self, comm, root_rank)

    def get_data(self):
        r"""get_data(teca_binary_stream self) -> PyObject *"""
        return _teca_py.teca_binary_stream_get_data(self)

    def set_data(self, obj):
        r"""
        set_data(teca_binary_stream self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_binary_stream_set_data(self, obj)

# Register teca_binary_stream in _teca_py:
_teca_py.teca_binary_stream_swigregister(teca_binary_stream)


def error_message(msg):
    r"""
    error_message(char const * msg)

    Parameters
    ----------
    msg: char const *

    """
    return _teca_py.error_message(msg)

def error_message_abort(msg):
    r"""
    error_message_abort(char const * msg)

    Parameters
    ----------
    msg: char const *

    """
    return _teca_py.error_message_abort(msg)

def set_error_handler(handler):
    r"""
    set_error_handler(p_teca_error_handler handler)

    Parameters
    ----------
    handler: p_teca_error_handler

    """
    return _teca_py.set_error_handler(handler)

def set_error_message_handler():
    r"""set_error_message_handler()"""
    return _teca_py.set_error_message_handler()

def set_error_message_abort_handler():
    r"""set_error_message_abort_handler()"""
    return _teca_py.set_error_message_abort_handler()

def __lshift__(os, vec):
    r"""
    __lshift__(ostream os, std_vector_string vec) -> ostream

    Parameters
    ----------
    os: std::ostream &
    vec: std::vector< std::string,std::allocator< std::string > > const &

    """
    return _teca_py.__lshift__(os, vec)

def have_tty():
    r"""have_tty() -> int"""
    return _teca_py.have_tty()
ANSI_RED = _teca_py.ANSI_RED

ANSI_GREEN = _teca_py.ANSI_GREEN

ANSI_YELLOW = _teca_py.ANSI_YELLOW

ANSI_WHITE = _teca_py.ANSI_WHITE

ANSI_OFF = _teca_py.ANSI_OFF

class teca_variant_array(object):
    r"""Proxy of C++ teca_variant_array class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_teca_variant_array

    def new_instance(self, *args):
        r"""
        new_instance(teca_variant_array self) -> p_teca_variant_array
        new_instance(teca_variant_array self, size_t n) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t

        new_instance(teca_variant_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_variant_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_variant_array_new_instance(self, *args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_variant_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_variant_array self) -> p_teca_variant_array
        new_copy(teca_variant_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        new_copy(teca_variant_array self, size_t src_start, size_t n_elem) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t

        """
        return _teca_py.teca_variant_array_new_copy(self, *args)

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_variant_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_variant_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_variant_array self) -> std::string"""
        return _teca_py.teca_variant_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_variant_array self)"""
        return _teca_py.teca_variant_array_initialize(self)

    def size(self):
        r"""size(teca_variant_array self) -> unsigned long"""
        return _teca_py.teca_variant_array_size(self)

    def resize(self, i):
        r"""
        resize(teca_variant_array self, unsigned long i)

        Parameters
        ----------
        i: unsigned long

        """
        return _teca_py.teca_variant_array_resize(self, i)

    def reserve(self, i):
        r"""
        reserve(teca_variant_array self, unsigned long i)

        Parameters
        ----------
        i: unsigned long

        """
        return _teca_py.teca_variant_array_reserve(self, i)

    def clear(self):
        r"""clear(teca_variant_array self)"""
        return _teca_py.teca_variant_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_variant_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_variant_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_variant_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_variant_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_variant_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_variant_array_from_stream(self, *args)

    def type_code(self):
        r"""type_code(teca_variant_array self) -> unsigned int"""
        return _teca_py.teca_variant_array_type_code(self)

    @staticmethod
    def New(obj):
        r"""
        New(PyObject * obj) -> p_teca_variant_array

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_variant_array_New(obj)

    def __str__(self):
        r"""__str__(teca_variant_array self) -> PyObject *"""
        return _teca_py.teca_variant_array___str__(self)

    def __len__(self):
        r"""__len__(teca_variant_array self) -> unsigned long"""
        return _teca_py.teca_variant_array___len__(self)

    def __setitem__(self, i, value):
        r"""
        __setitem__(teca_variant_array self, unsigned long i, PyObject * value) -> PyObject *

        Parameters
        ----------
        i: unsigned long
        value: PyObject *

        """
        return _teca_py.teca_variant_array___setitem__(self, i, value)

    def __getitem__(self, i):
        r"""
        __getitem__(teca_variant_array self, unsigned long i) -> PyObject *

        Parameters
        ----------
        i: unsigned long

        """
        return _teca_py.teca_variant_array___getitem__(self, i)

    def as_array(self):
        r"""as_array(teca_variant_array self) -> PyObject *"""
        return _teca_py.teca_variant_array_as_array(self)

    def get_cpu_accessible(self):
        r"""get_cpu_accessible(teca_variant_array self) -> PyObject *"""
        return _teca_py.teca_variant_array_get_cpu_accessible(self)

    def get_cuda_accessible_impl(self):
        r"""get_cuda_accessible_impl(teca_variant_array self) -> PyObject *"""
        return _teca_py.teca_variant_array_get_cuda_accessible_impl(self)

    def get_cuda_accessible(self):
        r""" return a handle exposing the data via the Numba CUDA array interface. """
        hvarr = self.get_cuda_accessible_impl()
        return cp_array(hvarr, copy=False)


    def append(self, obj):
        r"""
        append(teca_variant_array self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_variant_array_append(self, obj)

    def copy(self, obj):
        r"""
        copy(teca_variant_array self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_variant_array_copy(self, obj)

# Register teca_variant_array in _teca_py:
_teca_py.teca_variant_array_swigregister(teca_variant_array)

def teca_variant_array_New(obj):
    r"""
    teca_variant_array_New(PyObject * obj) -> p_teca_variant_array

    Parameters
    ----------
    obj: PyObject *

    """
    return _teca_py.teca_variant_array_New(obj)


from numpy import array as np_array
if get_teca_has_cupy():
    from cupy import array as cp_array

class teca_float_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< float > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< float > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< float > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< float > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_float_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_float_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_float_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_float_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_float_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_float_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_float_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_float_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_float_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_float_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_float_array self) -> std::string"""
        return _teca_py.teca_float_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_float_array self)"""
        return _teca_py.teca_float_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_float_array self) -> int"""
        return _teca_py.teca_float_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_float_array self) -> int"""
        return _teca_py.teca_float_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_float_array self) -> unsigned long"""
        return _teca_py.teca_float_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_float_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_float_array self, unsigned long n, float const & val)

        Parameters
        ----------
        n: unsigned long
        val: float const &

        """
        return _teca_py.teca_float_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_float_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_float_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_float_array self)"""
        return _teca_py.teca_float_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_float_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_float_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_float_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_float_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_float_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_float_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_float_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_float_array_get_allocator(self)

# Register teca_float_array in _teca_py:
_teca_py.teca_float_array_swigregister(teca_float_array)

def teca_float_array_New(*args):
    r"""
    teca_float_array_New() -> std::shared_ptr< teca_variant_array_impl< float > >
    teca_float_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< float > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_float_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< float > >

    Parameters
    ----------
    n: size_t

    teca_float_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< float > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_float_array_New(*args)

class teca_double_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< double > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< double > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< double > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< double > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_double_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_double_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_double_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_double_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_double_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_double_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_double_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_double_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_double_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_double_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_double_array self) -> std::string"""
        return _teca_py.teca_double_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_double_array self)"""
        return _teca_py.teca_double_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_double_array self) -> int"""
        return _teca_py.teca_double_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_double_array self) -> int"""
        return _teca_py.teca_double_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_double_array self) -> unsigned long"""
        return _teca_py.teca_double_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_double_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_double_array self, unsigned long n, double const & val)

        Parameters
        ----------
        n: unsigned long
        val: double const &

        """
        return _teca_py.teca_double_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_double_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_double_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_double_array self)"""
        return _teca_py.teca_double_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_double_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_double_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_double_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_double_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_double_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_double_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_double_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_double_array_get_allocator(self)

# Register teca_double_array in _teca_py:
_teca_py.teca_double_array_swigregister(teca_double_array)

def teca_double_array_New(*args):
    r"""
    teca_double_array_New() -> std::shared_ptr< teca_variant_array_impl< double > >
    teca_double_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< double > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_double_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< double > >

    Parameters
    ----------
    n: size_t

    teca_double_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< double > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_double_array_New(*args)

class teca_char_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< char > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< char > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< char > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< char > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_char_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_char_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_char_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_char_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_char_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_char_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_char_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_char_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_char_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_char_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_char_array self) -> std::string"""
        return _teca_py.teca_char_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_char_array self)"""
        return _teca_py.teca_char_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_char_array self) -> int"""
        return _teca_py.teca_char_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_char_array self) -> int"""
        return _teca_py.teca_char_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_char_array self) -> unsigned long"""
        return _teca_py.teca_char_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_char_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_char_array self, unsigned long n, char const & val)

        Parameters
        ----------
        n: unsigned long
        val: char const &

        """
        return _teca_py.teca_char_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_char_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_char_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_char_array self)"""
        return _teca_py.teca_char_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_char_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_char_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_char_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_char_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_char_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_char_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_char_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_char_array_get_allocator(self)

# Register teca_char_array in _teca_py:
_teca_py.teca_char_array_swigregister(teca_char_array)

def teca_char_array_New(*args):
    r"""
    teca_char_array_New() -> std::shared_ptr< teca_variant_array_impl< char > >
    teca_char_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< char > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_char_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< char > >

    Parameters
    ----------
    n: size_t

    teca_char_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< char > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_char_array_New(*args)

class teca_short_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< short > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< short > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< short > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< short > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_short_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_short_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_short_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_short_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_short_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_short_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_short_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_short_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_short_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_short_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_short_array self) -> std::string"""
        return _teca_py.teca_short_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_short_array self)"""
        return _teca_py.teca_short_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_short_array self) -> int"""
        return _teca_py.teca_short_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_short_array self) -> int"""
        return _teca_py.teca_short_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_short_array self) -> unsigned long"""
        return _teca_py.teca_short_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_short_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_short_array self, unsigned long n, short const & val)

        Parameters
        ----------
        n: unsigned long
        val: short const &

        """
        return _teca_py.teca_short_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_short_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_short_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_short_array self)"""
        return _teca_py.teca_short_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_short_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_short_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_short_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_short_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_short_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_short_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_short_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_short_array_get_allocator(self)

# Register teca_short_array in _teca_py:
_teca_py.teca_short_array_swigregister(teca_short_array)

def teca_short_array_New(*args):
    r"""
    teca_short_array_New() -> std::shared_ptr< teca_variant_array_impl< short > >
    teca_short_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< short > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_short_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< short > >

    Parameters
    ----------
    n: size_t

    teca_short_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< short > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_short_array_New(*args)

class teca_int_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< int > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< int > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< int > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< int > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_int_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_int_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_int_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_int_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_int_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_int_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_int_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_int_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_int_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_int_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_int_array self) -> std::string"""
        return _teca_py.teca_int_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_int_array self)"""
        return _teca_py.teca_int_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_int_array self) -> int"""
        return _teca_py.teca_int_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_int_array self) -> int"""
        return _teca_py.teca_int_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_int_array self) -> unsigned long"""
        return _teca_py.teca_int_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_int_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_int_array self, unsigned long n, int const & val)

        Parameters
        ----------
        n: unsigned long
        val: int const &

        """
        return _teca_py.teca_int_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_int_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_int_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_int_array self)"""
        return _teca_py.teca_int_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_int_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_int_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_int_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_int_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_int_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_int_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_int_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_int_array_get_allocator(self)

# Register teca_int_array in _teca_py:
_teca_py.teca_int_array_swigregister(teca_int_array)

def teca_int_array_New(*args):
    r"""
    teca_int_array_New() -> std::shared_ptr< teca_variant_array_impl< int > >
    teca_int_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< int > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_int_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< int > >

    Parameters
    ----------
    n: size_t

    teca_int_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< int > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_int_array_New(*args)

class teca_long_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< long > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< long > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< long > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< long > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_long_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_long_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_long_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_long_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_long_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_long_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_long_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_long_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_long_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_long_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_long_array self) -> std::string"""
        return _teca_py.teca_long_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_long_array self)"""
        return _teca_py.teca_long_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_long_array self) -> int"""
        return _teca_py.teca_long_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_long_array self) -> int"""
        return _teca_py.teca_long_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_long_array self) -> unsigned long"""
        return _teca_py.teca_long_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_long_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_long_array self, unsigned long n, long const & val)

        Parameters
        ----------
        n: unsigned long
        val: long const &

        """
        return _teca_py.teca_long_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_long_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_long_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_long_array self)"""
        return _teca_py.teca_long_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_long_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_long_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_long_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_long_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_long_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_long_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_long_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_long_array_get_allocator(self)

# Register teca_long_array in _teca_py:
_teca_py.teca_long_array_swigregister(teca_long_array)

def teca_long_array_New(*args):
    r"""
    teca_long_array_New() -> std::shared_ptr< teca_variant_array_impl< long > >
    teca_long_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< long > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_long_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< long > >

    Parameters
    ----------
    n: size_t

    teca_long_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< long > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_long_array_New(*args)

class teca_long_long_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< long long > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< long long > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< long long > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< long long > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_long_long_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_long_long_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_long_long_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_long_long_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_long_long_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_long_long_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_long_long_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_long_long_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_long_long_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_long_long_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_long_long_array self) -> std::string"""
        return _teca_py.teca_long_long_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_long_long_array self)"""
        return _teca_py.teca_long_long_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_long_long_array self) -> int"""
        return _teca_py.teca_long_long_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_long_long_array self) -> int"""
        return _teca_py.teca_long_long_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_long_long_array self) -> unsigned long"""
        return _teca_py.teca_long_long_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_long_long_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_long_long_array self, unsigned long n, long long const & val)

        Parameters
        ----------
        n: unsigned long
        val: long long const &

        """
        return _teca_py.teca_long_long_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_long_long_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_long_long_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_long_long_array self)"""
        return _teca_py.teca_long_long_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_long_long_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_long_long_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_long_long_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_long_long_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_long_long_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_long_long_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_long_long_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_long_long_array_get_allocator(self)

# Register teca_long_long_array in _teca_py:
_teca_py.teca_long_long_array_swigregister(teca_long_long_array)

def teca_long_long_array_New(*args):
    r"""
    teca_long_long_array_New() -> std::shared_ptr< teca_variant_array_impl< long long > >
    teca_long_long_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< long long > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_long_long_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< long long > >

    Parameters
    ----------
    n: size_t

    teca_long_long_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< long long > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_long_long_array_New(*args)

class teca_unsigned_char_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< unsigned char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< unsigned char > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned char > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned char > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned char > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_char_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_unsigned_char_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_unsigned_char_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_char_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_unsigned_char_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_unsigned_char_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_char_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_unsigned_char_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_unsigned_char_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_char_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_unsigned_char_array self) -> std::string"""
        return _teca_py.teca_unsigned_char_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_unsigned_char_array self)"""
        return _teca_py.teca_unsigned_char_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_unsigned_char_array self) -> int"""
        return _teca_py.teca_unsigned_char_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_unsigned_char_array self) -> int"""
        return _teca_py.teca_unsigned_char_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_unsigned_char_array self) -> unsigned long"""
        return _teca_py.teca_unsigned_char_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_unsigned_char_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_unsigned_char_array self, unsigned long n, unsigned char const & val)

        Parameters
        ----------
        n: unsigned long
        val: unsigned char const &

        """
        return _teca_py.teca_unsigned_char_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_unsigned_char_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_unsigned_char_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_unsigned_char_array self)"""
        return _teca_py.teca_unsigned_char_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_unsigned_char_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_unsigned_char_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_char_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_unsigned_char_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_unsigned_char_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_char_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_unsigned_char_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_unsigned_char_array_get_allocator(self)

# Register teca_unsigned_char_array in _teca_py:
_teca_py.teca_unsigned_char_array_swigregister(teca_unsigned_char_array)

def teca_unsigned_char_array_New(*args):
    r"""
    teca_unsigned_char_array_New() -> std::shared_ptr< teca_variant_array_impl< unsigned char > >
    teca_unsigned_char_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned char > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_unsigned_char_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned char > >

    Parameters
    ----------
    n: size_t

    teca_unsigned_char_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned char > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_unsigned_char_array_New(*args)

class teca_unsigned_short_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< unsigned short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< unsigned short > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned short > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned short > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned short > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_short_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_unsigned_short_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_unsigned_short_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_short_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_unsigned_short_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_unsigned_short_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_short_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_unsigned_short_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_unsigned_short_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_short_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_unsigned_short_array self) -> std::string"""
        return _teca_py.teca_unsigned_short_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_unsigned_short_array self)"""
        return _teca_py.teca_unsigned_short_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_unsigned_short_array self) -> int"""
        return _teca_py.teca_unsigned_short_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_unsigned_short_array self) -> int"""
        return _teca_py.teca_unsigned_short_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_unsigned_short_array self) -> unsigned long"""
        return _teca_py.teca_unsigned_short_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_unsigned_short_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_unsigned_short_array self, unsigned long n, unsigned short const & val)

        Parameters
        ----------
        n: unsigned long
        val: unsigned short const &

        """
        return _teca_py.teca_unsigned_short_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_unsigned_short_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_unsigned_short_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_unsigned_short_array self)"""
        return _teca_py.teca_unsigned_short_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_unsigned_short_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_unsigned_short_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_short_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_unsigned_short_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_unsigned_short_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_short_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_unsigned_short_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_unsigned_short_array_get_allocator(self)

# Register teca_unsigned_short_array in _teca_py:
_teca_py.teca_unsigned_short_array_swigregister(teca_unsigned_short_array)

def teca_unsigned_short_array_New(*args):
    r"""
    teca_unsigned_short_array_New() -> std::shared_ptr< teca_variant_array_impl< unsigned short > >
    teca_unsigned_short_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned short > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_unsigned_short_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned short > >

    Parameters
    ----------
    n: size_t

    teca_unsigned_short_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned short > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_unsigned_short_array_New(*args)

class teca_unsigned_int_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< unsigned int > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned int > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned int > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned int > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_int_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_unsigned_int_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_unsigned_int_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_int_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_unsigned_int_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_unsigned_int_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_int_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_unsigned_int_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_unsigned_int_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_int_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_unsigned_int_array self) -> std::string"""
        return _teca_py.teca_unsigned_int_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_unsigned_int_array self)"""
        return _teca_py.teca_unsigned_int_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_unsigned_int_array self) -> int"""
        return _teca_py.teca_unsigned_int_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_unsigned_int_array self) -> int"""
        return _teca_py.teca_unsigned_int_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_unsigned_int_array self) -> unsigned long"""
        return _teca_py.teca_unsigned_int_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_unsigned_int_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_unsigned_int_array self, unsigned long n, unsigned int const & val)

        Parameters
        ----------
        n: unsigned long
        val: unsigned int const &

        """
        return _teca_py.teca_unsigned_int_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_unsigned_int_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_unsigned_int_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_unsigned_int_array self)"""
        return _teca_py.teca_unsigned_int_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_unsigned_int_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_unsigned_int_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_int_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_unsigned_int_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_unsigned_int_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_int_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_unsigned_int_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_unsigned_int_array_get_allocator(self)

# Register teca_unsigned_int_array in _teca_py:
_teca_py.teca_unsigned_int_array_swigregister(teca_unsigned_int_array)

def teca_unsigned_int_array_New(*args):
    r"""
    teca_unsigned_int_array_New() -> std::shared_ptr< teca_variant_array_impl< unsigned int > >
    teca_unsigned_int_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned int > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_unsigned_int_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned int > >

    Parameters
    ----------
    n: size_t

    teca_unsigned_int_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned int > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_unsigned_int_array_New(*args)

class teca_unsigned_long_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< unsigned long > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned long > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned long > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned long > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_long_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_unsigned_long_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_unsigned_long_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_long_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_unsigned_long_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_unsigned_long_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_long_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_unsigned_long_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_unsigned_long_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_long_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_unsigned_long_array self) -> std::string"""
        return _teca_py.teca_unsigned_long_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_unsigned_long_array self)"""
        return _teca_py.teca_unsigned_long_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_unsigned_long_array self) -> int"""
        return _teca_py.teca_unsigned_long_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_unsigned_long_array self) -> int"""
        return _teca_py.teca_unsigned_long_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_unsigned_long_array self) -> unsigned long"""
        return _teca_py.teca_unsigned_long_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_unsigned_long_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_unsigned_long_array self, unsigned long n, unsigned long const & val)

        Parameters
        ----------
        n: unsigned long
        val: unsigned long const &

        """
        return _teca_py.teca_unsigned_long_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_unsigned_long_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_unsigned_long_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_unsigned_long_array self)"""
        return _teca_py.teca_unsigned_long_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_unsigned_long_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_unsigned_long_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_long_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_unsigned_long_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_unsigned_long_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_long_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_unsigned_long_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_unsigned_long_array_get_allocator(self)

# Register teca_unsigned_long_array in _teca_py:
_teca_py.teca_unsigned_long_array_swigregister(teca_unsigned_long_array)

def teca_unsigned_long_array_New(*args):
    r"""
    teca_unsigned_long_array_New() -> std::shared_ptr< teca_variant_array_impl< unsigned long > >
    teca_unsigned_long_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned long > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_unsigned_long_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned long > >

    Parameters
    ----------
    n: size_t

    teca_unsigned_long_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned long > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_unsigned_long_array_New(*args)

class teca_unsigned_long_long_array(teca_variant_array):
    r"""Proxy of C++ teca_variant_array_impl< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New(*args):
        r"""
        New() -> std::shared_ptr< teca_variant_array_impl< unsigned long long > >
        New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned long long > >

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned long long > >

        Parameters
        ----------
        n: size_t

        New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned long long > >

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_long_long_array_New(*args)

    def new_copy(self, *args):
        r"""
        new_copy(teca_unsigned_long_long_array self, teca_variant_array::allocator alloc=allocator::malloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_copy(teca_unsigned_long_long_array self, size_t src_start, size_t n_elem, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        src_start: size_t
        n_elem: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_long_long_array_new_copy(self, *args)

    def new_instance(self, *args):
        r"""
        new_instance(teca_unsigned_long_long_array self, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        new_instance(teca_unsigned_long_long_array self, size_t n, teca_variant_array::allocator alloc) -> p_teca_variant_array

        Parameters
        ----------
        n: size_t
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_long_long_array_new_instance(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_unsigned_long_long_array

    def set_allocator(self, alloc):
        r"""
        set_allocator(teca_unsigned_long_long_array self, teca_variant_array::allocator alloc) -> int

        Parameters
        ----------
        alloc: enum teca_variant_array::allocator

        """
        return _teca_py.teca_unsigned_long_long_array_set_allocator(self, alloc)

    def get_class_name(self):
        r"""get_class_name(teca_unsigned_long_long_array self) -> std::string"""
        return _teca_py.teca_unsigned_long_long_array_get_class_name(self)

    def initialize(self):
        r"""initialize(teca_unsigned_long_long_array self)"""
        return _teca_py.teca_unsigned_long_long_array_initialize(self)

    def cuda_accessible(self):
        r"""cuda_accessible(teca_unsigned_long_long_array self) -> int"""
        return _teca_py.teca_unsigned_long_long_array_cuda_accessible(self)

    def cpu_accessible(self):
        r"""cpu_accessible(teca_unsigned_long_long_array self) -> int"""
        return _teca_py.teca_unsigned_long_long_array_cpu_accessible(self)

    def size(self):
        r"""size(teca_unsigned_long_long_array self) -> unsigned long"""
        return _teca_py.teca_unsigned_long_long_array_size(self)

    def resize(self, *args):
        r"""
        resize(teca_unsigned_long_long_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        resize(teca_unsigned_long_long_array self, unsigned long n, unsigned long long const & val)

        Parameters
        ----------
        n: unsigned long
        val: unsigned long long const &

        """
        return _teca_py.teca_unsigned_long_long_array_resize(self, *args)

    def reserve(self, n):
        r"""
        reserve(teca_unsigned_long_long_array self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_unsigned_long_long_array_reserve(self, n)

    def clear(self):
        r"""clear(teca_unsigned_long_long_array self)"""
        return _teca_py.teca_unsigned_long_long_array_clear(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_unsigned_long_long_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_unsigned_long_long_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_long_long_array_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_unsigned_long_long_array self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_unsigned_long_long_array self, ostream s) -> int

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_unsigned_long_long_array_from_stream(self, *args)

    def get_allocator(self):
        r"""get_allocator(teca_unsigned_long_long_array self) -> teca_variant_array::allocator"""
        return _teca_py.teca_unsigned_long_long_array_get_allocator(self)

# Register teca_unsigned_long_long_array in _teca_py:
_teca_py.teca_unsigned_long_long_array_swigregister(teca_unsigned_long_long_array)

def teca_unsigned_long_long_array_New(*args):
    r"""
    teca_unsigned_long_long_array_New() -> std::shared_ptr< teca_variant_array_impl< unsigned long long > >
    teca_unsigned_long_long_array_New(teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned long long > >

    Parameters
    ----------
    alloc: enum teca_variant_array::allocator

    teca_unsigned_long_long_array_New(size_t n) -> std::shared_ptr< teca_variant_array_impl< unsigned long long > >

    Parameters
    ----------
    n: size_t

    teca_unsigned_long_long_array_New(size_t n, teca_variant_array::allocator alloc) -> std::shared_ptr< teca_variant_array_impl< unsigned long long > >

    Parameters
    ----------
    n: size_t
    alloc: enum teca_variant_array::allocator

    """
    return _teca_py.teca_unsigned_long_long_array_New(*args)

class teca_float_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_float_array_code_get()

    def __init__(self):
        r"""__init__(teca_float_array_code self) -> teca_float_array_code"""
        _teca_py.teca_float_array_code_swiginit(self, _teca_py.new_teca_float_array_code())
    __swig_destroy__ = _teca_py.delete_teca_float_array_code

# Register teca_float_array_code in _teca_py:
_teca_py.teca_float_array_code_swigregister(teca_float_array_code)

def teca_float_array_code_get():
    r"""teca_float_array_code_get() -> unsigned int"""
    return _teca_py.teca_float_array_code_get()

class teca_double_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_double_array_code_get()

    def __init__(self):
        r"""__init__(teca_double_array_code self) -> teca_double_array_code"""
        _teca_py.teca_double_array_code_swiginit(self, _teca_py.new_teca_double_array_code())
    __swig_destroy__ = _teca_py.delete_teca_double_array_code

# Register teca_double_array_code in _teca_py:
_teca_py.teca_double_array_code_swigregister(teca_double_array_code)

def teca_double_array_code_get():
    r"""teca_double_array_code_get() -> unsigned int"""
    return _teca_py.teca_double_array_code_get()

class teca_char_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_char_array_code_get()

    def __init__(self):
        r"""__init__(teca_char_array_code self) -> teca_char_array_code"""
        _teca_py.teca_char_array_code_swiginit(self, _teca_py.new_teca_char_array_code())
    __swig_destroy__ = _teca_py.delete_teca_char_array_code

# Register teca_char_array_code in _teca_py:
_teca_py.teca_char_array_code_swigregister(teca_char_array_code)

def teca_char_array_code_get():
    r"""teca_char_array_code_get() -> unsigned int"""
    return _teca_py.teca_char_array_code_get()

class teca_short_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_short_array_code_get()

    def __init__(self):
        r"""__init__(teca_short_array_code self) -> teca_short_array_code"""
        _teca_py.teca_short_array_code_swiginit(self, _teca_py.new_teca_short_array_code())
    __swig_destroy__ = _teca_py.delete_teca_short_array_code

# Register teca_short_array_code in _teca_py:
_teca_py.teca_short_array_code_swigregister(teca_short_array_code)

def teca_short_array_code_get():
    r"""teca_short_array_code_get() -> unsigned int"""
    return _teca_py.teca_short_array_code_get()

class teca_int_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_int_array_code_get()

    def __init__(self):
        r"""__init__(teca_int_array_code self) -> teca_int_array_code"""
        _teca_py.teca_int_array_code_swiginit(self, _teca_py.new_teca_int_array_code())
    __swig_destroy__ = _teca_py.delete_teca_int_array_code

# Register teca_int_array_code in _teca_py:
_teca_py.teca_int_array_code_swigregister(teca_int_array_code)

def teca_int_array_code_get():
    r"""teca_int_array_code_get() -> unsigned int"""
    return _teca_py.teca_int_array_code_get()

class teca_long_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_long_array_code_get()

    def __init__(self):
        r"""__init__(teca_long_array_code self) -> teca_long_array_code"""
        _teca_py.teca_long_array_code_swiginit(self, _teca_py.new_teca_long_array_code())
    __swig_destroy__ = _teca_py.delete_teca_long_array_code

# Register teca_long_array_code in _teca_py:
_teca_py.teca_long_array_code_swigregister(teca_long_array_code)

def teca_long_array_code_get():
    r"""teca_long_array_code_get() -> unsigned int"""
    return _teca_py.teca_long_array_code_get()

class teca_long_long_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_long_long_array_code_get()

    def __init__(self):
        r"""__init__(teca_long_long_array_code self) -> teca_long_long_array_code"""
        _teca_py.teca_long_long_array_code_swiginit(self, _teca_py.new_teca_long_long_array_code())
    __swig_destroy__ = _teca_py.delete_teca_long_long_array_code

# Register teca_long_long_array_code in _teca_py:
_teca_py.teca_long_long_array_code_swigregister(teca_long_long_array_code)

def teca_long_long_array_code_get():
    r"""teca_long_long_array_code_get() -> unsigned int"""
    return _teca_py.teca_long_long_array_code_get()

class teca_unsigned_char_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< unsigned char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_unsigned_char_array_code_get()

    def __init__(self):
        r"""__init__(teca_unsigned_char_array_code self) -> teca_unsigned_char_array_code"""
        _teca_py.teca_unsigned_char_array_code_swiginit(self, _teca_py.new_teca_unsigned_char_array_code())
    __swig_destroy__ = _teca_py.delete_teca_unsigned_char_array_code

# Register teca_unsigned_char_array_code in _teca_py:
_teca_py.teca_unsigned_char_array_code_swigregister(teca_unsigned_char_array_code)

def teca_unsigned_char_array_code_get():
    r"""teca_unsigned_char_array_code_get() -> unsigned int"""
    return _teca_py.teca_unsigned_char_array_code_get()

class teca_unsigned_short_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< unsigned short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_unsigned_short_array_code_get()

    def __init__(self):
        r"""__init__(teca_unsigned_short_array_code self) -> teca_unsigned_short_array_code"""
        _teca_py.teca_unsigned_short_array_code_swiginit(self, _teca_py.new_teca_unsigned_short_array_code())
    __swig_destroy__ = _teca_py.delete_teca_unsigned_short_array_code

# Register teca_unsigned_short_array_code in _teca_py:
_teca_py.teca_unsigned_short_array_code_swigregister(teca_unsigned_short_array_code)

def teca_unsigned_short_array_code_get():
    r"""teca_unsigned_short_array_code_get() -> unsigned int"""
    return _teca_py.teca_unsigned_short_array_code_get()

class teca_unsigned_int_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_unsigned_int_array_code_get()

    def __init__(self):
        r"""__init__(teca_unsigned_int_array_code self) -> teca_unsigned_int_array_code"""
        _teca_py.teca_unsigned_int_array_code_swiginit(self, _teca_py.new_teca_unsigned_int_array_code())
    __swig_destroy__ = _teca_py.delete_teca_unsigned_int_array_code

# Register teca_unsigned_int_array_code in _teca_py:
_teca_py.teca_unsigned_int_array_code_swigregister(teca_unsigned_int_array_code)

def teca_unsigned_int_array_code_get():
    r"""teca_unsigned_int_array_code_get() -> unsigned int"""
    return _teca_py.teca_unsigned_int_array_code_get()

class teca_unsigned_long_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_unsigned_long_array_code_get()

    def __init__(self):
        r"""__init__(teca_unsigned_long_array_code self) -> teca_unsigned_long_array_code"""
        _teca_py.teca_unsigned_long_array_code_swiginit(self, _teca_py.new_teca_unsigned_long_array_code())
    __swig_destroy__ = _teca_py.delete_teca_unsigned_long_array_code

# Register teca_unsigned_long_array_code in _teca_py:
_teca_py.teca_unsigned_long_array_code_swigregister(teca_unsigned_long_array_code)

def teca_unsigned_long_array_code_get():
    r"""teca_unsigned_long_array_code_get() -> unsigned int"""
    return _teca_py.teca_unsigned_long_array_code_get()

class teca_unsigned_long_long_array_code(object):
    r"""Proxy of C++ teca_variant_array_code< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get():
        r"""get() -> unsigned int"""
        return _teca_py.teca_unsigned_long_long_array_code_get()

    def __init__(self):
        r"""__init__(teca_unsigned_long_long_array_code self) -> teca_unsigned_long_long_array_code"""
        _teca_py.teca_unsigned_long_long_array_code_swiginit(self, _teca_py.new_teca_unsigned_long_long_array_code())
    __swig_destroy__ = _teca_py.delete_teca_unsigned_long_long_array_code

# Register teca_unsigned_long_long_array_code in _teca_py:
_teca_py.teca_unsigned_long_long_array_code_swigregister(teca_unsigned_long_long_array_code)

def teca_unsigned_long_long_array_code_get():
    r"""teca_unsigned_long_long_array_code_get() -> unsigned int"""
    return _teca_py.teca_unsigned_long_long_array_code_get()


def as_teca_double_array(in_inst):
    r"""
    as_teca_double_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< double > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_double_array(in_inst)

def as_const_teca_double_array(in_inst):
    r"""
    as_const_teca_double_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< double > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_double_array(in_inst)

def as_teca_float_array(in_inst):
    r"""
    as_teca_float_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< float > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_float_array(in_inst)

def as_const_teca_float_array(in_inst):
    r"""
    as_const_teca_float_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< float > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_float_array(in_inst)

def as_teca_char_array(in_inst):
    r"""
    as_teca_char_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< char > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_char_array(in_inst)

def as_const_teca_char_array(in_inst):
    r"""
    as_const_teca_char_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< char > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_char_array(in_inst)

def as_teca_short_array(in_inst):
    r"""
    as_teca_short_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< short > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_short_array(in_inst)

def as_const_teca_short_array(in_inst):
    r"""
    as_const_teca_short_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< short > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_short_array(in_inst)

def as_teca_int_array(in_inst):
    r"""
    as_teca_int_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< int > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_int_array(in_inst)

def as_const_teca_int_array(in_inst):
    r"""
    as_const_teca_int_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< int > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_int_array(in_inst)

def as_teca_long_array(in_inst):
    r"""
    as_teca_long_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< long > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_long_array(in_inst)

def as_const_teca_long_array(in_inst):
    r"""
    as_const_teca_long_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< long > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_long_array(in_inst)

def as_teca_long_long_array(in_inst):
    r"""
    as_teca_long_long_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< long long > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_long_long_array(in_inst)

def as_const_teca_long_long_array(in_inst):
    r"""
    as_const_teca_long_long_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< long long > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_long_long_array(in_inst)

def as_teca_unsigned_char_array(in_inst):
    r"""
    as_teca_unsigned_char_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned char > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_unsigned_char_array(in_inst)

def as_const_teca_unsigned_char_array(in_inst):
    r"""
    as_const_teca_unsigned_char_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned char > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_unsigned_char_array(in_inst)

def as_teca_unsigned_short_array(in_inst):
    r"""
    as_teca_unsigned_short_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned short > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_unsigned_short_array(in_inst)

def as_const_teca_unsigned_short_array(in_inst):
    r"""
    as_const_teca_unsigned_short_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned short > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_unsigned_short_array(in_inst)

def as_teca_unsigned_int_array(in_inst):
    r"""
    as_teca_unsigned_int_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned int > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_unsigned_int_array(in_inst)

def as_const_teca_unsigned_int_array(in_inst):
    r"""
    as_const_teca_unsigned_int_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned int > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_unsigned_int_array(in_inst)

def as_teca_unsigned_long_array(in_inst):
    r"""
    as_teca_unsigned_long_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned long > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_unsigned_long_array(in_inst)

def as_const_teca_unsigned_long_array(in_inst):
    r"""
    as_const_teca_unsigned_long_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned long > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_unsigned_long_array(in_inst)

def as_teca_unsigned_long_long_array(in_inst):
    r"""
    as_teca_unsigned_long_long_array(p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned long long > >

    Parameters
    ----------
    in_inst: p_teca_variant_array

    """
    return _teca_py.as_teca_unsigned_long_long_array(in_inst)

def as_const_teca_unsigned_long_long_array(in_inst):
    r"""
    as_const_teca_unsigned_long_long_array(const_p_teca_variant_array in_inst) -> std::shared_ptr< teca_variant_array_impl< unsigned long long > const >

    Parameters
    ----------
    in_inst: const_p_teca_variant_array

    """
    return _teca_py.as_const_teca_unsigned_long_long_array(in_inst)
class teca_metadata(object):
    r"""Proxy of C++ teca_metadata class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_teca_metadata

    def __init__(self, *args):
        r"""
        __init__(teca_metadata self) -> teca_metadata
        __init__(teca_metadata self, teca_metadata other) -> teca_metadata

        Parameters
        ----------
        other: teca_metadata const &

        """
        _teca_py.teca_metadata_swiginit(self, _teca_py.new_teca_metadata(*args))

    def size(self, *args):
        r"""
        size(teca_metadata self) -> unsigned int
        size(teca_metadata self, std::string const & name, unsigned int & size) -> int

        Parameters
        ----------
        name: std::string const &
        size: unsigned int &

        """
        return _teca_py.teca_metadata_size(self, *args)

    def resize(self, name, n):
        r"""
        resize(teca_metadata self, std::string const & name, unsigned int n)

        Parameters
        ----------
        name: std::string const &
        n: unsigned int

        """
        return _teca_py.teca_metadata_resize(self, name, n)

    def update(self, name, prop_val):
        r"""
        update(teca_metadata self, std::string const & name, p_teca_variant_array prop_val) -> int

        Parameters
        ----------
        name: std::string const &
        prop_val: p_teca_variant_array

        """
        return _teca_py.teca_metadata_update(self, name, prop_val)

    def get_name(self, i, name):
        r"""
        get_name(teca_metadata self, unsigned long i, std::string & name) -> int

        Parameters
        ----------
        i: unsigned long
        name: std::string &

        """
        return _teca_py.teca_metadata_get_name(self, i, name)

    def get_names(self, names):
        r"""
        get_names(teca_metadata self, std_vector_string names) -> int

        Parameters
        ----------
        names: std::vector< std::string,std::allocator< std::string > > &

        """
        return _teca_py.teca_metadata_get_names(self, names)

    def remove(self, name):
        r"""
        remove(teca_metadata self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_metadata_remove(self, name)

    def clear(self):
        r"""clear(teca_metadata self)"""
        return _teca_py.teca_metadata_clear(self)

    def has(self, name):
        r"""
        has(teca_metadata self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_metadata_has(self, name)

    def empty(self):
        r"""empty(teca_metadata self) -> int"""
        return _teca_py.teca_metadata_empty(self)

    def __nonzero__(self):
        return _teca_py.teca_metadata___nonzero__(self)
    __bool__ = __nonzero__



    def to_stream(self, *args):
        r"""
        to_stream(teca_metadata self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_metadata self, ostream os) -> int

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.teca_metadata_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_metadata self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_metadata self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_metadata_from_stream(self, *args)

    def __str__(self):
        r"""__str__(teca_metadata self) -> PyObject *"""
        return _teca_py.teca_metadata___str__(self)

    def __setitem__(self, name, value):
        r"""
        __setitem__(teca_metadata self, std::string const & name, PyObject * value) -> PyObject *

        Parameters
        ----------
        name: std::string const &
        value: PyObject *

        """
        return _teca_py.teca_metadata___setitem__(self, name, value)

    def set(self, *args):
        r"""
        set(teca_metadata self, std::string const & name, p_teca_variant_array const & prop_val) -> int

        Parameters
        ----------
        name: std::string const &
        prop_val: p_teca_variant_array const &

        set(teca_metadata self, std::string const & name, PyObject * value) -> PyObject *

        Parameters
        ----------
        name: std::string const &
        value: PyObject *

        """
        return _teca_py.teca_metadata_set(self, *args)

    def __getitem__(self, name):
        r"""
        __getitem__(teca_metadata self, std::string const & name) -> PyObject *

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_metadata___getitem__(self, name)

    def get(self, name):
        r"""
        get(teca_metadata self, std::string const & name) -> PyObject *

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_metadata_get(self, name)

    def append(self, name, obj):
        r"""
        append(teca_metadata self, std::string const & name, PyObject * obj) -> PyObject *

        Parameters
        ----------
        name: std::string const &
        obj: PyObject *

        """
        return _teca_py.teca_metadata_append(self, name, obj)

# Register teca_metadata in _teca_py:
_teca_py.teca_metadata_swigregister(teca_metadata)

class std_vector_metadata(object):
    r"""Proxy of C++ std::vector< teca_metadata > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_metadata self) -> SwigPyIterator"""
        return _teca_py.std_vector_metadata_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_metadata self) -> bool"""
        return _teca_py.std_vector_metadata___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_metadata self) -> bool"""
        return _teca_py.std_vector_metadata___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_metadata self) -> std::vector< teca_metadata >::size_type"""
        return _teca_py.std_vector_metadata___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_metadata self, std::vector< teca_metadata >::difference_type i, std::vector< teca_metadata >::difference_type j) -> std_vector_metadata

        Parameters
        ----------
        i: std::vector< teca_metadata >::difference_type
        j: std::vector< teca_metadata >::difference_type

        """
        return _teca_py.std_vector_metadata___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_metadata self, std::vector< teca_metadata >::difference_type i, std::vector< teca_metadata >::difference_type j)

        Parameters
        ----------
        i: std::vector< teca_metadata >::difference_type
        j: std::vector< teca_metadata >::difference_type

        __setslice__(std_vector_metadata self, std::vector< teca_metadata >::difference_type i, std::vector< teca_metadata >::difference_type j, std_vector_metadata v)

        Parameters
        ----------
        i: std::vector< teca_metadata >::difference_type
        j: std::vector< teca_metadata >::difference_type
        v: std::vector< teca_metadata,std::allocator< teca_metadata > > const &

        """
        return _teca_py.std_vector_metadata___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_metadata self, std::vector< teca_metadata >::difference_type i, std::vector< teca_metadata >::difference_type j)

        Parameters
        ----------
        i: std::vector< teca_metadata >::difference_type
        j: std::vector< teca_metadata >::difference_type

        """
        return _teca_py.std_vector_metadata___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_metadata self, std::vector< teca_metadata >::difference_type i)

        Parameters
        ----------
        i: std::vector< teca_metadata >::difference_type

        __delitem__(std_vector_metadata self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_metadata___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_metadata self, PySliceObject * slice) -> std_vector_metadata

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_metadata self, std::vector< teca_metadata >::difference_type i) -> teca_metadata

        Parameters
        ----------
        i: std::vector< teca_metadata >::difference_type

        """
        return _teca_py.std_vector_metadata___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_metadata self, PySliceObject * slice, std_vector_metadata v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< teca_metadata,std::allocator< teca_metadata > > const &

        __setitem__(std_vector_metadata self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_metadata self, std::vector< teca_metadata >::difference_type i, teca_metadata x)

        Parameters
        ----------
        i: std::vector< teca_metadata >::difference_type
        x: std::vector< teca_metadata >::value_type const &

        """
        return _teca_py.std_vector_metadata___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_metadata self) -> teca_metadata"""
        return _teca_py.std_vector_metadata_pop(self)

    def append(self, x):
        r"""
        append(std_vector_metadata self, teca_metadata x)

        Parameters
        ----------
        x: std::vector< teca_metadata >::value_type const &

        """
        return _teca_py.std_vector_metadata_append(self, x)

    def empty(self):
        r"""empty(std_vector_metadata self) -> bool"""
        return _teca_py.std_vector_metadata_empty(self)

    def size(self):
        r"""size(std_vector_metadata self) -> std::vector< teca_metadata >::size_type"""
        return _teca_py.std_vector_metadata_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_metadata self, std_vector_metadata v)

        Parameters
        ----------
        v: std::vector< teca_metadata > &

        """
        return _teca_py.std_vector_metadata_swap(self, v)

    def begin(self):
        r"""begin(std_vector_metadata self) -> std::vector< teca_metadata >::iterator"""
        return _teca_py.std_vector_metadata_begin(self)

    def end(self):
        r"""end(std_vector_metadata self) -> std::vector< teca_metadata >::iterator"""
        return _teca_py.std_vector_metadata_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_metadata self) -> std::vector< teca_metadata >::reverse_iterator"""
        return _teca_py.std_vector_metadata_rbegin(self)

    def rend(self):
        r"""rend(std_vector_metadata self) -> std::vector< teca_metadata >::reverse_iterator"""
        return _teca_py.std_vector_metadata_rend(self)

    def clear(self):
        r"""clear(std_vector_metadata self)"""
        return _teca_py.std_vector_metadata_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_metadata self) -> std::vector< teca_metadata >::allocator_type"""
        return _teca_py.std_vector_metadata_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_metadata self)"""
        return _teca_py.std_vector_metadata_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_metadata self, std::vector< teca_metadata >::iterator pos) -> std::vector< teca_metadata >::iterator

        Parameters
        ----------
        pos: std::vector< teca_metadata >::iterator

        erase(std_vector_metadata self, std::vector< teca_metadata >::iterator first, std::vector< teca_metadata >::iterator last) -> std::vector< teca_metadata >::iterator

        Parameters
        ----------
        first: std::vector< teca_metadata >::iterator
        last: std::vector< teca_metadata >::iterator

        """
        return _teca_py.std_vector_metadata_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_metadata self) -> std_vector_metadata
        __init__(std_vector_metadata self, std_vector_metadata other) -> std_vector_metadata

        Parameters
        ----------
        other: std::vector< teca_metadata > const &

        __init__(std_vector_metadata self, std::vector< teca_metadata >::size_type size) -> std_vector_metadata

        Parameters
        ----------
        size: std::vector< teca_metadata >::size_type

        __init__(std_vector_metadata self, std::vector< teca_metadata >::size_type size, teca_metadata value) -> std_vector_metadata

        Parameters
        ----------
        size: std::vector< teca_metadata >::size_type
        value: std::vector< teca_metadata >::value_type const &

        """
        _teca_py.std_vector_metadata_swiginit(self, _teca_py.new_std_vector_metadata(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_metadata self, teca_metadata x)

        Parameters
        ----------
        x: std::vector< teca_metadata >::value_type const &

        """
        return _teca_py.std_vector_metadata_push_back(self, x)

    def front(self):
        r"""front(std_vector_metadata self) -> teca_metadata"""
        return _teca_py.std_vector_metadata_front(self)

    def back(self):
        r"""back(std_vector_metadata self) -> teca_metadata"""
        return _teca_py.std_vector_metadata_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_metadata self, std::vector< teca_metadata >::size_type n, teca_metadata x)

        Parameters
        ----------
        n: std::vector< teca_metadata >::size_type
        x: std::vector< teca_metadata >::value_type const &

        """
        return _teca_py.std_vector_metadata_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_metadata self, std::vector< teca_metadata >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< teca_metadata >::size_type

        resize(std_vector_metadata self, std::vector< teca_metadata >::size_type new_size, teca_metadata x)

        Parameters
        ----------
        new_size: std::vector< teca_metadata >::size_type
        x: std::vector< teca_metadata >::value_type const &

        """
        return _teca_py.std_vector_metadata_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_metadata self, std::vector< teca_metadata >::iterator pos, teca_metadata x) -> std::vector< teca_metadata >::iterator

        Parameters
        ----------
        pos: std::vector< teca_metadata >::iterator
        x: std::vector< teca_metadata >::value_type const &

        insert(std_vector_metadata self, std::vector< teca_metadata >::iterator pos, std::vector< teca_metadata >::size_type n, teca_metadata x)

        Parameters
        ----------
        pos: std::vector< teca_metadata >::iterator
        n: std::vector< teca_metadata >::size_type
        x: std::vector< teca_metadata >::value_type const &

        """
        return _teca_py.std_vector_metadata_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_metadata self, std::vector< teca_metadata >::size_type n)

        Parameters
        ----------
        n: std::vector< teca_metadata >::size_type

        """
        return _teca_py.std_vector_metadata_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_metadata self) -> std::vector< teca_metadata >::size_type"""
        return _teca_py.std_vector_metadata_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_metadata

# Register std_vector_metadata in _teca_py:
_teca_py.std_vector_metadata_swigregister(std_vector_metadata)

class teca_dataset(object):
    r"""Proxy of C++ teca_dataset class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_teca_dataset

    def set_index_request_key(self, *args):
        r"""
        set_index_request_key(teca_dataset self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_index_request_key(teca_dataset self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_index_request_key(teca_dataset self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_index_request_key(teca_dataset self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        """
        return _teca_py.teca_dataset_set_index_request_key(self, *args)

    def get_index_request_key(self, *args):
        r"""
        get_index_request_key(teca_dataset self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_index_request_key(teca_dataset self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_index_request_key(teca_dataset self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_index_request_key(teca_dataset self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        """
        return _teca_py.teca_dataset_get_index_request_key(self, *args)

    def get_request_index(self, val):
        r"""
        get_request_index(teca_dataset self, long & val) -> int

        Parameters
        ----------
        val: long &

        """
        return _teca_py.teca_dataset_get_request_index(self, val)

    def set_request_index(self, *args):
        r"""
        set_request_index(teca_dataset self, std::string const & key, long val) -> int

        Parameters
        ----------
        key: std::string const &
        val: long

        set_request_index(teca_dataset self, long val) -> int

        Parameters
        ----------
        val: long

        """
        return _teca_py.teca_dataset_set_request_index(self, *args)

    def __nonzero__(self):
        return _teca_py.teca_dataset___nonzero__(self)
    __bool__ = __nonzero__



    def empty(self):
        r"""empty(teca_dataset self) -> bool"""
        return _teca_py.teca_dataset_empty(self)

    def new_instance(self):
        r"""new_instance(teca_dataset self) -> p_teca_dataset"""
        return _teca_py.teca_dataset_new_instance(self)

    def new_copy(self, *args):
        r"""
        new_copy(teca_dataset self, teca_dataset::allocator alloc=malloc) -> p_teca_dataset

        Parameters
        ----------
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_dataset_new_copy(self, *args)

    def new_shallow_copy(self):
        r"""new_shallow_copy(teca_dataset self) -> p_teca_dataset"""
        return _teca_py.teca_dataset_new_shallow_copy(self)

    def get_class_name(self):
        r"""get_class_name(teca_dataset self) -> std::string"""
        return _teca_py.teca_dataset_get_class_name(self)

    def get_type_code(self):
        r"""get_type_code(teca_dataset self) -> int"""
        return _teca_py.teca_dataset_get_type_code(self)

    def copy(self, *args):
        r"""
        copy(teca_dataset self, const_p_teca_dataset const & other, teca_dataset::allocator alloc=malloc)

        Parameters
        ----------
        other: const_p_teca_dataset const &
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_dataset_copy(self, *args)

    def shallow_copy(self, other):
        r"""
        shallow_copy(teca_dataset self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_dataset_shallow_copy(self, other)

    def copy_metadata(self, other):
        r"""
        copy_metadata(teca_dataset self, const_p_teca_dataset const & other)

        Parameters
        ----------
        other: const_p_teca_dataset const &

        """
        return _teca_py.teca_dataset_copy_metadata(self, other)

    def swap(self, other):
        r"""
        swap(teca_dataset self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_dataset_swap(self, other)

    def get_metadata(self, *args):
        r"""
        get_metadata(teca_dataset self) -> teca_metadata
        get_metadata(teca_dataset self) -> teca_metadata
        """
        return _teca_py.teca_dataset_get_metadata(self, *args)

    def set_metadata(self, md):
        r"""
        set_metadata(teca_dataset self, teca_metadata md)

        Parameters
        ----------
        md: teca_metadata const &

        """
        return _teca_py.teca_dataset_set_metadata(self, md)

    def to_stream(self, *args):
        r"""
        to_stream(teca_dataset self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        to_stream(teca_dataset self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_dataset_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_dataset self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        from_stream(teca_dataset self, istream arg2) -> int

        Parameters
        ----------
        arg2: std::istream &

        """
        return _teca_py.teca_dataset_from_stream(self, *args)

    def __str__(self):
        r"""__str__(teca_dataset self) -> PyObject *"""
        return _teca_py.teca_dataset___str__(self)

# Register teca_dataset in _teca_py:
_teca_py.teca_dataset_swigregister(teca_dataset)


def as_non_const_teca_dataset(in_inst):
    r"""
    as_non_const_teca_dataset(const_p_teca_dataset in_inst) -> p_teca_dataset

    Parameters
    ----------
    in_inst: const_p_teca_dataset

    """
    return _teca_py.as_non_const_teca_dataset(in_inst)
class std_vector_dataset(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< teca_dataset > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(std_vector_dataset self) -> SwigPyIterator"""
        return _teca_py.std_vector_dataset_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(std_vector_dataset self) -> bool"""
        return _teca_py.std_vector_dataset___nonzero__(self)

    def __bool__(self):
        r"""__bool__(std_vector_dataset self) -> bool"""
        return _teca_py.std_vector_dataset___bool__(self)

    def __len__(self):
        r"""__len__(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::size_type"""
        return _teca_py.std_vector_dataset___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::difference_type i, std::vector< std::shared_ptr< teca_dataset > >::difference_type j) -> std_vector_dataset

        Parameters
        ----------
        i: std::vector< std::shared_ptr< teca_dataset > >::difference_type
        j: std::vector< std::shared_ptr< teca_dataset > >::difference_type

        """
        return _teca_py.std_vector_dataset___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::difference_type i, std::vector< std::shared_ptr< teca_dataset > >::difference_type j)

        Parameters
        ----------
        i: std::vector< std::shared_ptr< teca_dataset > >::difference_type
        j: std::vector< std::shared_ptr< teca_dataset > >::difference_type

        __setslice__(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::difference_type i, std::vector< std::shared_ptr< teca_dataset > >::difference_type j, std_vector_dataset v)

        Parameters
        ----------
        i: std::vector< std::shared_ptr< teca_dataset > >::difference_type
        j: std::vector< std::shared_ptr< teca_dataset > >::difference_type
        v: std::vector< std::shared_ptr< teca_dataset >,std::allocator< std::shared_ptr< teca_dataset > > > const &

        """
        return _teca_py.std_vector_dataset___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::difference_type i, std::vector< std::shared_ptr< teca_dataset > >::difference_type j)

        Parameters
        ----------
        i: std::vector< std::shared_ptr< teca_dataset > >::difference_type
        j: std::vector< std::shared_ptr< teca_dataset > >::difference_type

        """
        return _teca_py.std_vector_dataset___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::difference_type i)

        Parameters
        ----------
        i: std::vector< std::shared_ptr< teca_dataset > >::difference_type

        __delitem__(std_vector_dataset self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _teca_py.std_vector_dataset___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(std_vector_dataset self, PySliceObject * slice) -> std_vector_dataset

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::difference_type i) -> std::vector< std::shared_ptr< teca_dataset > >::value_type const &

        Parameters
        ----------
        i: std::vector< std::shared_ptr< teca_dataset > >::difference_type

        """
        return _teca_py.std_vector_dataset___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(std_vector_dataset self, PySliceObject * slice, std_vector_dataset v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::shared_ptr< teca_dataset >,std::allocator< std::shared_ptr< teca_dataset > > > const &

        __setitem__(std_vector_dataset self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::difference_type i, std::vector< std::shared_ptr< teca_dataset > >::value_type const & x)

        Parameters
        ----------
        i: std::vector< std::shared_ptr< teca_dataset > >::difference_type
        x: std::vector< std::shared_ptr< teca_dataset > >::value_type const &

        """
        return _teca_py.std_vector_dataset___setitem__(self, *args)

    def pop(self):
        r"""pop(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::value_type"""
        return _teca_py.std_vector_dataset_pop(self)

    def append(self, x):
        r"""
        append(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::value_type const & x)

        Parameters
        ----------
        x: std::vector< std::shared_ptr< teca_dataset > >::value_type const &

        """
        return _teca_py.std_vector_dataset_append(self, x)

    def empty(self):
        r"""empty(std_vector_dataset self) -> bool"""
        return _teca_py.std_vector_dataset_empty(self)

    def size(self):
        r"""size(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::size_type"""
        return _teca_py.std_vector_dataset_size(self)

    def swap(self, v):
        r"""
        swap(std_vector_dataset self, std_vector_dataset v)

        Parameters
        ----------
        v: std::vector< std::shared_ptr< teca_dataset > > &

        """
        return _teca_py.std_vector_dataset_swap(self, v)

    def begin(self):
        r"""begin(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::iterator"""
        return _teca_py.std_vector_dataset_begin(self)

    def end(self):
        r"""end(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::iterator"""
        return _teca_py.std_vector_dataset_end(self)

    def rbegin(self):
        r"""rbegin(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::reverse_iterator"""
        return _teca_py.std_vector_dataset_rbegin(self)

    def rend(self):
        r"""rend(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::reverse_iterator"""
        return _teca_py.std_vector_dataset_rend(self)

    def clear(self):
        r"""clear(std_vector_dataset self)"""
        return _teca_py.std_vector_dataset_clear(self)

    def get_allocator(self):
        r"""get_allocator(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::allocator_type"""
        return _teca_py.std_vector_dataset_get_allocator(self)

    def pop_back(self):
        r"""pop_back(std_vector_dataset self)"""
        return _teca_py.std_vector_dataset_pop_back(self)

    def erase(self, *args):
        r"""
        erase(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::iterator pos) -> std::vector< std::shared_ptr< teca_dataset > >::iterator

        Parameters
        ----------
        pos: std::vector< std::shared_ptr< teca_dataset > >::iterator

        erase(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::iterator first, std::vector< std::shared_ptr< teca_dataset > >::iterator last) -> std::vector< std::shared_ptr< teca_dataset > >::iterator

        Parameters
        ----------
        first: std::vector< std::shared_ptr< teca_dataset > >::iterator
        last: std::vector< std::shared_ptr< teca_dataset > >::iterator

        """
        return _teca_py.std_vector_dataset_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(std_vector_dataset self) -> std_vector_dataset
        __init__(std_vector_dataset self, std_vector_dataset other) -> std_vector_dataset

        Parameters
        ----------
        other: std::vector< std::shared_ptr< teca_dataset > > const &

        __init__(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::size_type size) -> std_vector_dataset

        Parameters
        ----------
        size: std::vector< std::shared_ptr< teca_dataset > >::size_type

        __init__(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::size_type size, std::vector< std::shared_ptr< teca_dataset > >::value_type const & value) -> std_vector_dataset

        Parameters
        ----------
        size: std::vector< std::shared_ptr< teca_dataset > >::size_type
        value: std::vector< std::shared_ptr< teca_dataset > >::value_type const &

        """
        _teca_py.std_vector_dataset_swiginit(self, _teca_py.new_std_vector_dataset(*args))

    def push_back(self, x):
        r"""
        push_back(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::value_type const & x)

        Parameters
        ----------
        x: std::vector< std::shared_ptr< teca_dataset > >::value_type const &

        """
        return _teca_py.std_vector_dataset_push_back(self, x)

    def front(self):
        r"""front(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::value_type const &"""
        return _teca_py.std_vector_dataset_front(self)

    def back(self):
        r"""back(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::value_type const &"""
        return _teca_py.std_vector_dataset_back(self)

    def assign(self, n, x):
        r"""
        assign(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::size_type n, std::vector< std::shared_ptr< teca_dataset > >::value_type const & x)

        Parameters
        ----------
        n: std::vector< std::shared_ptr< teca_dataset > >::size_type
        x: std::vector< std::shared_ptr< teca_dataset > >::value_type const &

        """
        return _teca_py.std_vector_dataset_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< std::shared_ptr< teca_dataset > >::size_type

        resize(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::size_type new_size, std::vector< std::shared_ptr< teca_dataset > >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< std::shared_ptr< teca_dataset > >::size_type
        x: std::vector< std::shared_ptr< teca_dataset > >::value_type const &

        """
        return _teca_py.std_vector_dataset_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::iterator pos, std::vector< std::shared_ptr< teca_dataset > >::value_type const & x) -> std::vector< std::shared_ptr< teca_dataset > >::iterator

        Parameters
        ----------
        pos: std::vector< std::shared_ptr< teca_dataset > >::iterator
        x: std::vector< std::shared_ptr< teca_dataset > >::value_type const &

        insert(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::iterator pos, std::vector< std::shared_ptr< teca_dataset > >::size_type n, std::vector< std::shared_ptr< teca_dataset > >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< std::shared_ptr< teca_dataset > >::iterator
        n: std::vector< std::shared_ptr< teca_dataset > >::size_type
        x: std::vector< std::shared_ptr< teca_dataset > >::value_type const &

        """
        return _teca_py.std_vector_dataset_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(std_vector_dataset self, std::vector< std::shared_ptr< teca_dataset > >::size_type n)

        Parameters
        ----------
        n: std::vector< std::shared_ptr< teca_dataset > >::size_type

        """
        return _teca_py.std_vector_dataset_reserve(self, n)

    def capacity(self):
        r"""capacity(std_vector_dataset self) -> std::vector< std::shared_ptr< teca_dataset > >::size_type"""
        return _teca_py.std_vector_dataset_capacity(self)
    __swig_destroy__ = _teca_py.delete_std_vector_dataset

# Register std_vector_dataset in _teca_py:
_teca_py.std_vector_dataset_swigregister(std_vector_dataset)

class teca_algorithm_executive(object):
    r"""Proxy of C++ teca_algorithm_executive class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_algorithm_executive"""
        return _teca_py.teca_algorithm_executive_New()
    __swig_destroy__ = _teca_py.delete_teca_algorithm_executive

    def initialize(self, comm, md):
        r"""
        initialize(teca_algorithm_executive self, MPI_Comm comm, teca_metadata md) -> int

        Parameters
        ----------
        comm: MPI_Comm
        md: teca_metadata const &

        """
        return _teca_py.teca_algorithm_executive_initialize(self, comm, md)

    def get_next_request(self):
        r"""get_next_request(teca_algorithm_executive self) -> teca_metadata"""
        return _teca_py.teca_algorithm_executive_get_next_request(self)

    def set_verbose(self, a_verbose):
        r"""
        set_verbose(teca_algorithm_executive self, int a_verbose)

        Parameters
        ----------
        a_verbose: int

        """
        return _teca_py.teca_algorithm_executive_set_verbose(self, a_verbose)

    def get_verbose(self):
        r"""get_verbose(teca_algorithm_executive self) -> int"""
        return _teca_py.teca_algorithm_executive_get_verbose(self)

# Register teca_algorithm_executive in _teca_py:
_teca_py.teca_algorithm_executive_swigregister(teca_algorithm_executive)

def teca_algorithm_executive_New():
    r"""teca_algorithm_executive_New() -> p_teca_algorithm_executive"""
    return _teca_py.teca_algorithm_executive_New()

class teca_index_executive(teca_algorithm_executive):
    r"""Proxy of C++ teca_index_executive class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_index_executive"""
        return _teca_py.teca_index_executive_New()

    def initialize(self, comm, md):
        r"""
        initialize(teca_index_executive self, MPI_Comm comm, teca_metadata md) -> int

        Parameters
        ----------
        comm: MPI_Comm
        md: teca_metadata const &

        """
        return _teca_py.teca_index_executive_initialize(self, comm, md)

    def get_next_request(self):
        r"""get_next_request(teca_index_executive self) -> teca_metadata"""
        return _teca_py.teca_index_executive_get_next_request(self)

    def set_index(self, s):
        r"""
        set_index(teca_index_executive self, long s)

        Parameters
        ----------
        s: long

        """
        return _teca_py.teca_index_executive_set_index(self, s)

    def set_start_index(self, s):
        r"""
        set_start_index(teca_index_executive self, long s)

        Parameters
        ----------
        s: long

        """
        return _teca_py.teca_index_executive_set_start_index(self, s)

    def set_end_index(self, s):
        r"""
        set_end_index(teca_index_executive self, long s)

        Parameters
        ----------
        s: long

        """
        return _teca_py.teca_index_executive_set_end_index(self, s)

    def set_stride(self, s):
        r"""
        set_stride(teca_index_executive self, long s)

        Parameters
        ----------
        s: long

        """
        return _teca_py.teca_index_executive_set_stride(self, s)

    def set_extent(self, *args):
        r"""
        set_extent(teca_index_executive self, unsigned long * ext)

        Parameters
        ----------
        ext: unsigned long *

        set_extent(teca_index_executive self, std_vector_ulong ext)

        Parameters
        ----------
        ext: std::vector< unsigned long,std::allocator< unsigned long > > const &

        """
        return _teca_py.teca_index_executive_set_extent(self, *args)

    def set_bounds(self, *args):
        r"""
        set_bounds(teca_index_executive self, double * bounds)

        Parameters
        ----------
        bounds: double *

        set_bounds(teca_index_executive self, std_vector_double bounds)

        Parameters
        ----------
        bounds: std::vector< double,std::allocator< double > > const &

        """
        return _teca_py.teca_index_executive_set_bounds(self, *args)

    def set_arrays(self, arrays):
        r"""
        set_arrays(teca_index_executive self, std_vector_string arrays)

        Parameters
        ----------
        arrays: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _teca_py.teca_index_executive_set_arrays(self, arrays)
    __swig_destroy__ = _teca_py.delete_teca_index_executive

# Register teca_index_executive in _teca_py:
_teca_py.teca_index_executive_swigregister(teca_index_executive)

def teca_index_executive_New():
    r"""teca_index_executive_New() -> p_teca_index_executive"""
    return _teca_py.teca_index_executive_New()

class teca_output_port_type(object):
    r"""Proxy of C++ std::pair< std::shared_ptr< teca_algorithm >,unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(teca_output_port_type self) -> teca_output_port_type
        __init__(teca_output_port_type self, std::shared_ptr< teca_algorithm > first, unsigned int second) -> teca_output_port_type

        Parameters
        ----------
        first: std::shared_ptr< teca_algorithm >
        second: unsigned int

        __init__(teca_output_port_type self, teca_output_port_type other) -> teca_output_port_type

        Parameters
        ----------
        other: std::pair< std::shared_ptr< teca_algorithm >,unsigned int > const &

        """
        _teca_py.teca_output_port_type_swiginit(self, _teca_py.new_teca_output_port_type(*args))
    first = property(_teca_py.teca_output_port_type_first_get, _teca_py.teca_output_port_type_first_set, doc=r"""first : std::shared_ptr<(teca_algorithm)>""")
    second = property(_teca_py.teca_output_port_type_second_get, _teca_py.teca_output_port_type_second_set, doc=r"""second : unsigned int""")
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _teca_py.delete_teca_output_port_type

# Register teca_output_port_type in _teca_py:
_teca_py.teca_output_port_type_swigregister(teca_output_port_type)


def get_algorithm(op):
    r"""
    get_algorithm(teca_output_port_type op) -> p_teca_algorithm &

    Parameters
    ----------
    op: teca_algorithm_output_port &

    """
    return _teca_py.get_algorithm(op)

def get_port(op):
    r"""
    get_port(teca_output_port_type op) -> unsigned int &

    Parameters
    ----------
    op: teca_algorithm_output_port &

    """
    return _teca_py.get_port(op)
class teca_algorithm(object):
    r"""Proxy of C++ teca_algorithm class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_teca_algorithm

    def get_class_name(self):
        r"""get_class_name(teca_algorithm self) -> char const *"""
        return _teca_py.teca_algorithm_get_class_name(self)

    def set_communicator(self, comm):
        r"""
        set_communicator(teca_algorithm self, MPI_Comm comm)

        Parameters
        ----------
        comm: MPI_Comm

        """
        return _teca_py.teca_algorithm_set_communicator(self, comm)

    def get_communicator(self):
        r"""get_communicator(teca_algorithm self) -> MPI_Comm"""
        return _teca_py.teca_algorithm_get_communicator(self)

    def get_properties_description(self, prefix, opts):
        r"""
        get_properties_description(teca_algorithm self, std::string const & prefix, options_description & opts)

        Parameters
        ----------
        prefix: std::string const &
        opts: options_description &

        """
        return _teca_py.teca_algorithm_get_properties_description(self, prefix, opts)

    def set_properties(self, prefix, opts):
        r"""
        set_properties(teca_algorithm self, std::string const & prefix, variables_map & opts)

        Parameters
        ----------
        prefix: std::string const &
        opts: variables_map &

        """
        return _teca_py.teca_algorithm_set_properties(self, prefix, opts)

    def set_verbose(self, v):
        r"""
        set_verbose(teca_algorithm self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_algorithm_set_verbose(self, v)

    def get_verbose(self):
        r"""get_verbose(teca_algorithm self) -> int const &"""
        return _teca_py.teca_algorithm_get_verbose(self)

    def get_output_port(self, port=0):
        r"""
        get_output_port(teca_algorithm self, unsigned int port=0) -> teca_output_port_type

        Parameters
        ----------
        port: unsigned int

        """
        return _teca_py.teca_algorithm_get_output_port(self, port)

    def set_input_connection(self, *args):
        r"""
        set_input_connection(teca_algorithm self, teca_output_port_type port)

        Parameters
        ----------
        port: teca_algorithm_output_port const &

        set_input_connection(teca_algorithm self, unsigned int id, teca_output_port_type port)

        Parameters
        ----------
        id: unsigned int
        port: teca_algorithm_output_port const &

        """
        return _teca_py.teca_algorithm_set_input_connection(self, *args)

    def remove_input_connection(self, id):
        r"""
        remove_input_connection(teca_algorithm self, unsigned int id)

        Parameters
        ----------
        id: unsigned int

        """
        return _teca_py.teca_algorithm_remove_input_connection(self, id)

    def clear_input_connections(self):
        r"""clear_input_connections(teca_algorithm self)"""
        return _teca_py.teca_algorithm_clear_input_connections(self)

    def get_output_data(self, port=0):
        r"""
        get_output_data(teca_algorithm self, unsigned int port=0) -> const_p_teca_dataset

        Parameters
        ----------
        port: unsigned int

        """
        return _teca_py.teca_algorithm_get_output_data(self, port)

    def pop_cache(self, port=0, top=0):
        r"""
        pop_cache(teca_algorithm self, unsigned int port=0, int top=0)

        Parameters
        ----------
        port: unsigned int
        top: int

        """
        return _teca_py.teca_algorithm_pop_cache(self, port, top)

    def set_cache_size(self, n):
        r"""
        set_cache_size(teca_algorithm self, unsigned int n)

        Parameters
        ----------
        n: unsigned int

        """
        return _teca_py.teca_algorithm_set_cache_size(self, n)

    def update(self, *args):
        r"""
        update(teca_algorithm self) -> int
        update(teca_algorithm self, unsigned int port) -> int

        Parameters
        ----------
        port: unsigned int

        """
        return _teca_py.teca_algorithm_update(self, *args)

    def update_metadata(self, port=0):
        r"""
        update_metadata(teca_algorithm self, unsigned int port=0) -> teca_metadata

        Parameters
        ----------
        port: unsigned int

        """
        return _teca_py.teca_algorithm_update_metadata(self, port)

    def set_executive(self, exe):
        r"""
        set_executive(teca_algorithm self, p_teca_algorithm_executive exe)

        Parameters
        ----------
        exe: p_teca_algorithm_executive

        """
        return _teca_py.teca_algorithm_set_executive(self, exe)

    def get_executive(self):
        r"""get_executive(teca_algorithm self) -> p_teca_algorithm_executive"""
        return _teca_py.teca_algorithm_get_executive(self)

    def to_stream(self, s):
        r"""
        to_stream(teca_algorithm self, ostream s)

        Parameters
        ----------
        s: std::ostream &

        """
        return _teca_py.teca_algorithm_to_stream(self, s)

    def from_stream(self, s):
        r"""
        from_stream(teca_algorithm self, istream s)

        Parameters
        ----------
        s: std::istream &

        """
        return _teca_py.teca_algorithm_from_stream(self, s)

# Register teca_algorithm in _teca_py:
_teca_py.teca_algorithm_swigregister(teca_algorithm)


def new_teca_data_request_queue(comm, n_threads, n_threads_per_device, bind, verbose):
    r"""
    new_teca_data_request_queue(MPI_Comm comm, int n_threads, int n_threads_per_device, bool bind, bool verbose) -> p_teca_data_request_queue

    Parameters
    ----------
    comm: MPI_Comm
    n_threads: int
    n_threads_per_device: int
    bind: bool
    verbose: bool

    """
    return _teca_py.new_teca_data_request_queue(comm, n_threads, n_threads_per_device, bind, verbose)
class teca_threaded_algorithm(teca_algorithm):
    r"""Proxy of C++ teca_threaded_algorithm class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_threaded_algorithm"""
        return _teca_py.teca_threaded_algorithm_New()

    def get_class_name(self):
        r"""get_class_name(teca_threaded_algorithm self) -> char const *"""
        return _teca_py.teca_threaded_algorithm_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_threaded_algorithm

    def set_thread_pool_size(self, n_threads):
        r"""
        set_thread_pool_size(teca_threaded_algorithm self, int n_threads)

        Parameters
        ----------
        n_threads: int

        """
        return _teca_py.teca_threaded_algorithm_set_thread_pool_size(self, n_threads)

    def get_thread_pool_size(self):
        r"""get_thread_pool_size(teca_threaded_algorithm self) -> unsigned int"""
        return _teca_py.teca_threaded_algorithm_get_thread_pool_size(self)

    def set_verbose(self, v):
        r"""
        set_verbose(teca_threaded_algorithm self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_threaded_algorithm_set_verbose(self, v)

    def get_verbose(self):
        r"""get_verbose(teca_threaded_algorithm self) -> int const &"""
        return _teca_py.teca_threaded_algorithm_get_verbose(self)

    def set_bind_threads(self, v):
        r"""
        set_bind_threads(teca_threaded_algorithm self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_threaded_algorithm_set_bind_threads(self, v)

    def get_bind_threads(self):
        r"""get_bind_threads(teca_threaded_algorithm self) -> int const &"""
        return _teca_py.teca_threaded_algorithm_get_bind_threads(self)

    def set_stream_size(self, v):
        r"""
        set_stream_size(teca_threaded_algorithm self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_threaded_algorithm_set_stream_size(self, v)

    def get_stream_size(self):
        r"""get_stream_size(teca_threaded_algorithm self) -> int const &"""
        return _teca_py.teca_threaded_algorithm_get_stream_size(self)

    def set_poll_interval(self, v):
        r"""
        set_poll_interval(teca_threaded_algorithm self, long long const & v)

        Parameters
        ----------
        v: long long const &

        """
        return _teca_py.teca_threaded_algorithm_set_poll_interval(self, v)

    def get_poll_interval(self):
        r"""get_poll_interval(teca_threaded_algorithm self) -> long long const &"""
        return _teca_py.teca_threaded_algorithm_get_poll_interval(self)

    def set_threads_per_cuda_device(self, v):
        r"""
        set_threads_per_cuda_device(teca_threaded_algorithm self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_threaded_algorithm_set_threads_per_cuda_device(self, v)

    def get_threads_per_cuda_device(self):
        r"""get_threads_per_cuda_device(teca_threaded_algorithm self) -> int const &"""
        return _teca_py.teca_threaded_algorithm_get_threads_per_cuda_device(self)

    def set_data_request_queue(self, queue):
        r"""
        set_data_request_queue(teca_threaded_algorithm self, p_teca_data_request_queue const & queue)

        Parameters
        ----------
        queue: p_teca_data_request_queue const &

        """
        return _teca_py.teca_threaded_algorithm_set_data_request_queue(self, queue)

# Register teca_threaded_algorithm in _teca_py:
_teca_py.teca_threaded_algorithm_swigregister(teca_threaded_algorithm)

def teca_threaded_algorithm_New():
    r"""teca_threaded_algorithm_New() -> p_teca_threaded_algorithm"""
    return _teca_py.teca_threaded_algorithm_New()

class teca_index_reduce(teca_threaded_algorithm):
    r"""Proxy of C++ teca_index_reduce class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_teca_index_reduce

    def set_start_index(self, v):
        r"""
        set_start_index(teca_index_reduce self, long const & v)

        Parameters
        ----------
        v: long const &

        """
        return _teca_py.teca_index_reduce_set_start_index(self, v)

    def get_start_index(self):
        r"""get_start_index(teca_index_reduce self) -> long const &"""
        return _teca_py.teca_index_reduce_get_start_index(self)

    def set_end_index(self, v):
        r"""
        set_end_index(teca_index_reduce self, long const & v)

        Parameters
        ----------
        v: long const &

        """
        return _teca_py.teca_index_reduce_set_end_index(self, v)

    def get_end_index(self):
        r"""get_end_index(teca_index_reduce self) -> long const &"""
        return _teca_py.teca_index_reduce_get_end_index(self)

# Register teca_index_reduce in _teca_py:
_teca_py.teca_index_reduce_swigregister(teca_index_reduce)

class teca_programmable_algorithm(teca_algorithm):
    r"""Proxy of C++ teca_programmable_algorithm class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_programmable_algorithm"""
        return _teca_py.teca_programmable_algorithm_New()
    __swig_destroy__ = _teca_py.delete_teca_programmable_algorithm

    def set_name(self, name):
        r"""
        set_name(teca_programmable_algorithm self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_programmable_algorithm_set_name(self, name)

    def get_class_name(self):
        r"""get_class_name(teca_programmable_algorithm self) -> char const *"""
        return _teca_py.teca_programmable_algorithm_get_class_name(self)

    def set_number_of_input_connections(self, n):
        r"""
        set_number_of_input_connections(teca_programmable_algorithm self, unsigned int n)

        Parameters
        ----------
        n: unsigned int

        """
        return _teca_py.teca_programmable_algorithm_set_number_of_input_connections(self, n)

    def set_number_of_output_ports(self, n):
        r"""
        set_number_of_output_ports(teca_programmable_algorithm self, unsigned int n)

        Parameters
        ----------
        n: unsigned int

        """
        return _teca_py.teca_programmable_algorithm_set_number_of_output_ports(self, n)

    def use_default_report_action(self):
        r"""use_default_report_action(teca_programmable_algorithm self)"""
        return _teca_py.teca_programmable_algorithm_use_default_report_action(self)

    def use_default_request_action(self):
        r"""use_default_request_action(teca_programmable_algorithm self)"""
        return _teca_py.teca_programmable_algorithm_use_default_request_action(self)

    def use_default_execute_action(self):
        r"""use_default_execute_action(teca_programmable_algorithm self)"""
        return _teca_py.teca_programmable_algorithm_use_default_execute_action(self)

    def set_report_callback(self, f):
        r"""
        set_report_callback(teca_programmable_algorithm self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_programmable_algorithm_set_report_callback(self, f)

    def set_request_callback(self, f):
        r"""
        set_request_callback(teca_programmable_algorithm self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_programmable_algorithm_set_request_callback(self, f)

    def set_execute_callback(self, f):
        r"""
        set_execute_callback(teca_programmable_algorithm self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_programmable_algorithm_set_execute_callback(self, f)

# Register teca_programmable_algorithm in _teca_py:
_teca_py.teca_programmable_algorithm_swigregister(teca_programmable_algorithm)

def teca_programmable_algorithm_New():
    r"""teca_programmable_algorithm_New() -> p_teca_programmable_algorithm"""
    return _teca_py.teca_programmable_algorithm_New()

class teca_threaded_programmable_algorithm(teca_threaded_algorithm):
    r"""Proxy of C++ teca_threaded_programmable_algorithm class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_threaded_programmable_algorithm"""
        return _teca_py.teca_threaded_programmable_algorithm_New()
    __swig_destroy__ = _teca_py.delete_teca_threaded_programmable_algorithm

    def set_name(self, name):
        r"""
        set_name(teca_threaded_programmable_algorithm self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_threaded_programmable_algorithm_set_name(self, name)

    def get_class_name(self):
        r"""get_class_name(teca_threaded_programmable_algorithm self) -> char const *"""
        return _teca_py.teca_threaded_programmable_algorithm_get_class_name(self)

    def set_number_of_input_connections(self, n):
        r"""
        set_number_of_input_connections(teca_threaded_programmable_algorithm self, unsigned int n)

        Parameters
        ----------
        n: unsigned int

        """
        return _teca_py.teca_threaded_programmable_algorithm_set_number_of_input_connections(self, n)

    def set_number_of_output_ports(self, n):
        r"""
        set_number_of_output_ports(teca_threaded_programmable_algorithm self, unsigned int n)

        Parameters
        ----------
        n: unsigned int

        """
        return _teca_py.teca_threaded_programmable_algorithm_set_number_of_output_ports(self, n)

    def set_thread_pool_size(self, n_threads):
        r"""
        set_thread_pool_size(teca_threaded_programmable_algorithm self, int n_threads)

        Parameters
        ----------
        n_threads: int

        """
        return _teca_py.teca_threaded_programmable_algorithm_set_thread_pool_size(self, n_threads)

    def set_stream_size(self, v):
        r"""
        set_stream_size(teca_threaded_programmable_algorithm self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_threaded_programmable_algorithm_set_stream_size(self, v)

    def use_default_report_action(self):
        r"""use_default_report_action(teca_threaded_programmable_algorithm self)"""
        return _teca_py.teca_threaded_programmable_algorithm_use_default_report_action(self)

    def use_default_request_action(self):
        r"""use_default_request_action(teca_threaded_programmable_algorithm self)"""
        return _teca_py.teca_threaded_programmable_algorithm_use_default_request_action(self)

    def use_default_execute_action(self):
        r"""use_default_execute_action(teca_threaded_programmable_algorithm self)"""
        return _teca_py.teca_threaded_programmable_algorithm_use_default_execute_action(self)

    def set_report_callback(self, f):
        r"""
        set_report_callback(teca_threaded_programmable_algorithm self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_threaded_programmable_algorithm_set_report_callback(self, f)

    def set_request_callback(self, f):
        r"""
        set_request_callback(teca_threaded_programmable_algorithm self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_threaded_programmable_algorithm_set_request_callback(self, f)

    def set_execute_callback(self, f):
        r"""
        set_execute_callback(teca_threaded_programmable_algorithm self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_threaded_programmable_algorithm_set_execute_callback(self, f)

# Register teca_threaded_programmable_algorithm in _teca_py:
_teca_py.teca_threaded_programmable_algorithm_swigregister(teca_threaded_programmable_algorithm)

def teca_threaded_programmable_algorithm_New():
    r"""teca_threaded_programmable_algorithm_New() -> p_teca_threaded_programmable_algorithm"""
    return _teca_py.teca_threaded_programmable_algorithm_New()

class teca_programmable_reduce(teca_index_reduce):
    r"""Proxy of C++ teca_programmable_reduce class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_programmable_reduce"""
        return _teca_py.teca_programmable_reduce_New()
    __swig_destroy__ = _teca_py.delete_teca_programmable_reduce

    def set_name(self, name):
        r"""
        set_name(teca_programmable_reduce self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_programmable_reduce_set_name(self, name)

    def get_class_name(self):
        r"""get_class_name(teca_programmable_reduce self) -> char const *"""
        return _teca_py.teca_programmable_reduce_get_class_name(self)

    def set_report_callback(self, f):
        r"""
        set_report_callback(teca_programmable_reduce self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_programmable_reduce_set_report_callback(self, f)

    def set_request_callback(self, f):
        r"""
        set_request_callback(teca_programmable_reduce self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_programmable_reduce_set_request_callback(self, f)

    def set_reduce_callback(self, f):
        r"""
        set_reduce_callback(teca_programmable_reduce self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_programmable_reduce_set_reduce_callback(self, f)

    def set_finalize_callback(self, f):
        r"""
        set_finalize_callback(teca_programmable_reduce self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_programmable_reduce_set_finalize_callback(self, f)

# Register teca_programmable_reduce in _teca_py:
_teca_py.teca_programmable_reduce_swigregister(teca_programmable_reduce)

def teca_programmable_reduce_New():
    r"""teca_programmable_reduce_New() -> p_teca_programmable_reduce"""
    return _teca_py.teca_programmable_reduce_New()


class teca_python_algorithm(object):
    """
    The base class used for writing new algorithms in Python.  Contains
    plumbing that connects user provided overrides to an instance of
    teca_programmable_algorithm. Users are expected to override one or more of
    report, request, and/or execute.
    """

    @classmethod
    def New(derived_class):
        """
        factory method returns an instance of the derived type
        """
        dc = derived_class()
        dc.initialize_implementation()
        return dc

    def initialize_implementation(self):
        """
        Initializes the instance and wires up the plumbing.
        """
# call overridable methods to get number of inputs/outputs
        n_inputs = self.get_number_of_input_connections()
        n_outputs = self.get_number_of_output_ports()

# call overrides to get implementation for teca execution
# phase implementations
        self.impl = teca_programmable_algorithm.New()
        self.impl.set_number_of_input_connections(n_inputs)
        self.impl.set_number_of_output_ports(n_outputs)
        self.impl.set_name(self.__class__.__name__)
        self.impl.set_report_callback(self.get_report_callback())
        self.impl.set_request_callback(self.get_request_callback())
        self.impl.set_execute_callback(self.get_execute_callback())

    def __getattr__(self, name):
        """
        forward calls to the programmable algorithm
        """

# guard against confusing infinite recursion that
# occurs if impl is not present. one common way
# that this occurs is if the instance was not
# created with the New method
        if name == 'impl':
            raise RuntimeError('The teca_python_algorithm ' \
                'was imporperly initialized. Did you use the ' \
                'factory method, New(), to create this ' \
                'instance of %s?'%(self.__class__.__name__))

# forward to the teca_programmable_algorithm
        return self.impl.__getattribute__(name)

    def get_report_callback(self):
        """
        returns a callback to be used by the programmable algorithm that
        forwards calls to the class method.
        """
        def report_callback(port, md_in):
            return self.report(port, md_in)
        return report_callback

    def get_request_callback(self):
        """
        returns a callback to be used by the programmable algorithm that
        forwards calls to the class method.
        """
        def request_callback(port, md_in, req_in):
            return self.request(port, md_in, req_in)
        return request_callback

    def get_execute_callback(self):
        """
        returns a callback to be used by the programmable algorithm that
        forwards calls to the class method.
        """
        def execute_callback(port, data_in, req_in):
            return self.execute(port, data_in, req_in)
        return execute_callback

    def get_number_of_input_connections(self):
        """
        return the number of input connections this algorithm needs.
        The default is 1, override to modify.
        """
        return 1

    def get_number_of_output_ports(self):
        """
        return the number of output ports this algorithm provides.
        The default is 1, override to modify.
        """
        return 1

    def report(self, port, md_in):
        """
        return the metadata decribing the data available for consumption.
        Override this to customize the behavior of the report phase of
        execution. The default passes metadata on the first input through.
        """
        return teca_metadata(md_in[0])

    def request(self, port, md_in, req_in):
        """
        return the request for needed data for execution. Override this to
        customize the behavior of the request phase of execution. The default
        passes the request on the first input port through.
        """
        return [teca_metadata(req_in)]

    def execute(self, port, data_in, req_in):
        """
        return the processed data. Override this to customize the behavior of
        the execute phase of execution. The default passes the dataset on the
        first input port through.
        """
        if len(data_in):
            data_out = data_in[0].new_instance()
            data_out.shallow_copy(as_non_const_teca_dataset(data_out))
        return data_out


class teca_threaded_python_algorithm(object):
    """
    The base class used for writing new threaded algorithms in Python.
    Threaded algorithms execute upstream requests using a thread pool.  This is
    most useful for algorithms that make multiple requests.  For those not
    doing so, use the teca_python_algorithm instead.  See
    teca_threaded_algorithm for more information.  Contains plumbing that
    connects user provided overrides to an instance of
    teca_programmable_algorithm. Users are expected to override one or more of
    report, request, and/or execute.
    """

    @classmethod
    def New(derived_class):
        """
        factory method returns an instance of the derived type
        """
        dc = derived_class()
        dc.initialize_implementation()
        return dc

    def initialize_implementation(self):
        """
        Initializes the instance and wires up the plumbing.
        """
# call overridable methods to get number of inputs/outputs
        n_inputs = self.get_number_of_input_connections()
        n_outputs = self.get_number_of_output_ports()

# call overrides to get implementation for teca execution
# phase implementations
        self.impl = teca_threaded_programmable_algorithm.New()
        self.impl.set_number_of_input_connections(n_inputs)
        self.impl.set_number_of_output_ports(n_outputs)
        self.impl.set_name(self.__class__.__name__)
        self.impl.set_report_callback(self.get_report_callback())
        self.impl.set_request_callback(self.get_request_callback())
        self.impl.set_execute_callback(self.get_execute_callback())

    def __getattr__(self, name):
        """
        forward calls to the programmable algorithm
        """

# guard against confusing infinite recursion that
# occurs if impl is not present. one common way
# that this occurs is if the instance was not
# created with the New method
        if name == 'impl':
            raise RuntimeError('The teca_python_algorithm ' \
                'was imporperly initialized. Did you use the ' \
                'factory method, New(), to create this ' \
                'instance of %s?'%(self.__class__.__name__))

# forward to the teca_programmable_algorithm
        return self.impl.__getattribute__(name)

    def get_report_callback(self):
        """
        returns a callback to be used by the programmable algorithm that
        forwards calls to the class method.
        """
        def report_callback(port, md_in):
            return self.report(port, md_in)
        return report_callback

    def get_request_callback(self):
        """
        returns a callback to be used by the programmable algorithm that
        forwards calls to the class method.
        """
        def request_callback(port, md_in, req_in):
            return self.request(port, md_in, req_in)
        return request_callback

    def get_execute_callback(self):
        """
        returns a callback to be used by the programmable algorithm that
        forwards calls to the class method.
        """
        def execute_callback(port, data_in, req_in, streaming):
            return self.execute(port, data_in, req_in, streaming)
        return execute_callback

    def get_number_of_input_connections(self):
        """
        return the number of input connections this algorithm needs.
        The default is 1, override to modify.
        """
        return 1

    def get_number_of_output_ports(self):
        """
        return the number of output ports this algorithm provides.
        The default is 1, override to modify.
        """
        return 1

    def report(self, port, md_in):
        """
        return the metadata decribing the data available for consumption.
        Override this to customize the behavior of the report phase of
        execution. The default passes metadata on the first input through.
        """
        return teca_metadata(md_in[0])

    def request(self, port, md_in, req_in):
        """
        return the request for needed data for execution. Override this to
        customize the behavior of the request phase of execution. The default
        passes the request on the first input port through.
        """
        return [teca_metadata(req_in)]

    def execute(self, port, data_in, req_in, streaming):
        """
        return the processed data. Override this to customize the behavior of
        the execute phase of execution. The default passes the dataset on the
        first input port through.
        """
        if len(data_in):
            data_out = data_in[0].new_instance()
            data_out.shallow_copy(as_non_const_teca_dataset(data_out))
        return data_out


class teca_python_reduce(object):
    """
    The base class used for writing new reductions in Python.  Contains
    plumbing that connects user provided overrides to an instance of
    teca_programmable_reduce. Users are expected to override one or more of
    report, request, reduce, and/or finalize methods.
    """

    @classmethod
    def New(derived_class):
        """
        factory method returns an instance of the derived type
        """
        dc = derived_class()
        dc.initialize_implementation()
        return dc

    def initialize_implementation(self):
        """
        Initializes the instance and wires up the plumbing.
        """
# call overrides to get implementation for teca execution
# phase implementations
        self.impl = teca_programmable_reduce.New()
        self.impl.set_name(self.__class__.__name__)
        self.impl.set_report_callback(self.get_report_callback())
        self.impl.set_request_callback(self.get_request_callback())
        self.impl.set_reduce_callback(self.get_reduce_callback())
        self.impl.set_finalize_callback(self.get_finalize_callback())

    def __getattr__(self, name):
        """
        forward calls to the programmable reduce
        """

# guard against confusing infinite recursion that
# occurs if impl is not present. one common way
# that this occurs is if the instance was not
# created with the New method
        if name == 'impl':
            raise RuntimeError('The teca_python_reduce ' \
                'was imporperly initialized. Did you use the ' \
                'factory method, New(), to create this ' \
                'instance of %s?'%(self.__class__.__name__))

# forward to the teca_programmable_reduce
        return self.impl.__getattribute__(name)

    def get_report_callback(self):
        """
        returns a callback to be used by the programmable reduce that
        forwards calls to the class method.
        """
        def report_callback(port, md_in):
            return self.report(port, md_in)
        return report_callback

    def get_request_callback(self):
        """
        returns a callback to be used by the programmable reduce that
        forwards calls to the class method.
        """
        def request_callback(port, md_in, req_in):
            return self.request(port, md_in, req_in)
        return request_callback

    def get_execute_callback(self):
        """
        returns a callback to be used by the programmable reduce that
        forwards calls to the class method.
        """
        def execute_callback(port, data_in, req_in):
            return self.execute(port, data_in, req_in)
        return execute_callback

    def get_reduce_callback(self):
        """
        returns a callback used by the programmable reduce that forwards
        calls to the class method
        """
        def reduce_callback(dev, left, right):
            return self.reduce(dev, left, right)
        return reduce_callback

    def get_finalize_callback(self):
        """
        returns a callback used by the programmable reduce that forwards
        calls to the class method
        """
        def finalize_callback(dev, data):
            return self.finalize(dev, data)
        return finalize_callback

    def report(self, port, md_in):
        """
        return the metadata decribing the data available for consumption.
        Override this to customize the behavior of the report phase of
        execution. The default passes metadata on the first input through.
        """
        return teca_metadata(md_in[0])

    def request(self, port, md_in, req_in):
        """
        return the request for needed data for execution. Override this to
        customize the behavior of the request phase of execution. The default
        passes the request on the first input port through.
        """
        return [teca_metadata(req_in)]

    def reduce(self, dev, left, right):
        """
        given two input datasets return the reduced data. Override this to customize
        the behavior of the reduction. the default raises an exception, this must be
        overridden.
        """
        raise RuntimeError('%s::reduce method was not overridden'%(self.get_class_name()))

    def finalize(self, dev, data_in):
        """
        Called after the reduction is complete. Override this method to customize the
        finalization of the reduction. the default passes the dataset through.
        """
        return data_in

class teca_dataset_source(teca_algorithm):
    r"""Proxy of C++ teca_dataset_source class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_dataset_source"""
        return _teca_py.teca_dataset_source_New()

    def get_class_name(self):
        r"""get_class_name(teca_dataset_source self) -> char const *"""
        return _teca_py.teca_dataset_source_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_dataset_source

    def get_number_of_datasets(self):
        r"""get_number_of_datasets(teca_dataset_source self) -> size_t"""
        return _teca_py.teca_dataset_source_get_number_of_datasets(self)

    def append_dataset(self, v):
        r"""
        append_dataset(teca_dataset_source self, p_teca_dataset const & v)

        Parameters
        ----------
        v: p_teca_dataset const &

        """
        return _teca_py.teca_dataset_source_append_dataset(self, v)

    def set_datasets(self, *args):
        r"""
        set_datasets(teca_dataset_source self, std_vector_dataset v)

        Parameters
        ----------
        v: std::vector< p_teca_dataset,std::allocator< p_teca_dataset > > const &

        set_datasets(teca_dataset_source self, std::initializer_list< p_teca_dataset > const && l)

        Parameters
        ----------
        l: std::initializer_list< p_teca_dataset > const &&

        """
        return _teca_py.teca_dataset_source_set_datasets(self, *args)

    def get_dataset(self, i):
        r"""
        get_dataset(teca_dataset_source self, size_t i) -> p_teca_dataset const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_dataset_source_get_dataset(self, i)

    def get_datasets(self):
        r"""get_datasets(teca_dataset_source self) -> std_vector_dataset"""
        return _teca_py.teca_dataset_source_get_datasets(self)

    def clear_datasets(self):
        r"""clear_datasets(teca_dataset_source self)"""
        return _teca_py.teca_dataset_source_clear_datasets(self)

    def set_dataset(self, *args):
        r"""
        set_dataset(teca_dataset_source self, size_t i, p_teca_dataset const & v)

        Parameters
        ----------
        i: size_t
        v: p_teca_dataset const &

        set_dataset(teca_dataset_source self, p_teca_dataset const & ds)

        Parameters
        ----------
        ds: p_teca_dataset const &

        """
        return _teca_py.teca_dataset_source_set_dataset(self, *args)

    def set_metadata(self, v):
        r"""
        set_metadata(teca_dataset_source self, teca_metadata v)

        Parameters
        ----------
        v: teca_metadata const &

        """
        return _teca_py.teca_dataset_source_set_metadata(self, v)

    def get_metadata(self):
        r"""get_metadata(teca_dataset_source self) -> teca_metadata"""
        return _teca_py.teca_dataset_source_get_metadata(self)

# Register teca_dataset_source in _teca_py:
_teca_py.teca_dataset_source_swigregister(teca_dataset_source)

def teca_dataset_source_New():
    r"""teca_dataset_source_New() -> p_teca_dataset_source"""
    return _teca_py.teca_dataset_source_New()

class teca_dataset_capture(teca_algorithm):
    r"""Proxy of C++ teca_dataset_capture class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_dataset_capture"""
        return _teca_py.teca_dataset_capture_New()

    def get_class_name(self):
        r"""get_class_name(teca_dataset_capture self) -> char const *"""
        return _teca_py.teca_dataset_capture_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_dataset_capture

    def set_dataset(self, v):
        r"""
        set_dataset(teca_dataset_capture self, const_p_teca_dataset const & v)

        Parameters
        ----------
        v: const_p_teca_dataset const &

        """
        return _teca_py.teca_dataset_capture_set_dataset(self, v)

    def get_dataset(self):
        r"""get_dataset(teca_dataset_capture self) -> const_p_teca_dataset const &"""
        return _teca_py.teca_dataset_capture_get_dataset(self)

# Register teca_dataset_capture in _teca_py:
_teca_py.teca_dataset_capture_swigregister(teca_dataset_capture)

def teca_dataset_capture_New():
    r"""teca_dataset_capture_New() -> p_teca_dataset_capture"""
    return _teca_py.teca_dataset_capture_New()

class calendar_util(object):
    r"""Proxy of C++ calendar_util class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def date(offset, units, calendar):
        r"""
        date(double offset, char const * units, char const * calendar) -> PyObject *

        Parameters
        ----------
        offset: double
        units: char const *
        calendar: char const *

        """
        return _teca_py.calendar_util_date(offset, units, calendar)

    @staticmethod
    def is_leap_year(calendar, units, year):
        r"""
        is_leap_year(char const * calendar, char const * units, int year) -> PyObject *

        Parameters
        ----------
        calendar: char const *
        units: char const *
        year: int

        """
        return _teca_py.calendar_util_is_leap_year(calendar, units, year)

    @staticmethod
    def days_in_month(calendar, units, year, month):
        r"""
        days_in_month(char const * calendar, char const * units, int year, int month) -> PyObject *

        Parameters
        ----------
        calendar: char const *
        units: char const *
        year: int
        month: int

        """
        return _teca_py.calendar_util_days_in_month(calendar, units, year, month)

    def __init__(self):
        r"""__init__(calendar_util self) -> calendar_util"""
        _teca_py.calendar_util_swiginit(self, _teca_py.new_calendar_util())
    __swig_destroy__ = _teca_py.delete_calendar_util

# Register calendar_util in _teca_py:
_teca_py.calendar_util_swigregister(calendar_util)

def calendar_util_date(offset, units, calendar):
    r"""
    calendar_util_date(double offset, char const * units, char const * calendar) -> PyObject *

    Parameters
    ----------
    offset: double
    units: char const *
    calendar: char const *

    """
    return _teca_py.calendar_util_date(offset, units, calendar)

def calendar_util_is_leap_year(calendar, units, year):
    r"""
    calendar_util_is_leap_year(char const * calendar, char const * units, int year) -> PyObject *

    Parameters
    ----------
    calendar: char const *
    units: char const *
    year: int

    """
    return _teca_py.calendar_util_is_leap_year(calendar, units, year)

def calendar_util_days_in_month(calendar, units, year, month):
    r"""
    calendar_util_days_in_month(char const * calendar, char const * units, int year, int month) -> PyObject *

    Parameters
    ----------
    calendar: char const *
    units: char const *
    year: int
    month: int

    """
    return _teca_py.calendar_util_days_in_month(calendar, units, year, month)

class thread_util(object):
    r"""Proxy of C++ thread_util class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def thread_parameters(comm, n_requested, bind, n_per_device, verbose):
        r"""
        thread_parameters(MPI_Comm comm, int n_requested, int bind, int n_per_device, int verbose) -> PyObject *

        Parameters
        ----------
        comm: MPI_Comm
        n_requested: int
        bind: int
        n_per_device: int
        verbose: int

        """
        return _teca_py.thread_util_thread_parameters(comm, n_requested, bind, n_per_device, verbose)

    def __init__(self):
        r"""__init__(thread_util self) -> thread_util"""
        _teca_py.thread_util_swiginit(self, _teca_py.new_thread_util())
    __swig_destroy__ = _teca_py.delete_thread_util

# Register thread_util in _teca_py:
_teca_py.thread_util_swigregister(thread_util)

def thread_util_thread_parameters(comm, n_requested, bind, n_per_device, verbose):
    r"""
    thread_util_thread_parameters(MPI_Comm comm, int n_requested, int bind, int n_per_device, int verbose) -> PyObject *

    Parameters
    ----------
    comm: MPI_Comm
    n_requested: int
    bind: int
    n_per_device: int
    verbose: int

    """
    return _teca_py.thread_util_thread_parameters(comm, n_requested, bind, n_per_device, verbose)

class system_util(object):
    r"""Proxy of C++ system_util class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get_environment_variable_bool(str, _def):
        r"""
        get_environment_variable_bool(char const * str, int _def) -> PyObject *

        Parameters
        ----------
        str: char const *
        def: int

        """
        return _teca_py.system_util_get_environment_variable_bool(str, _def)

    def __init__(self):
        r"""__init__(system_util self) -> system_util"""
        _teca_py.system_util_swiginit(self, _teca_py.new_system_util())
    __swig_destroy__ = _teca_py.delete_system_util

# Register system_util in _teca_py:
_teca_py.system_util_swigregister(system_util)

def system_util_get_environment_variable_bool(str, _def):
    r"""
    system_util_get_environment_variable_bool(char const * str, int _def) -> PyObject *

    Parameters
    ----------
    str: char const *
    def: int

    """
    return _teca_py.system_util_get_environment_variable_bool(str, _def)

class teca_array_attributes(object):
    r"""Proxy of C++ teca_array_attributes class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def as_metadata(self):
        r"""as_metadata(teca_array_attributes self) -> teca_metadata"""
        return _teca_py.teca_array_attributes_as_metadata(self)

    def merge_to(self, md):
        r"""
        merge_to(teca_array_attributes self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata &

        """
        return _teca_py.teca_array_attributes_merge_to(self, md)

    def from_metadata(self, md):
        r"""
        from_metadata(teca_array_attributes self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata const &

        """
        return _teca_py.teca_array_attributes_from_metadata(self, md)

    def to_stream(self, os):
        r"""
        to_stream(teca_array_attributes self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.teca_array_attributes_to_stream(self, os)
    invalid_value = _teca_py.teca_array_attributes_invalid_value
    
    cell_centering = _teca_py.teca_array_attributes_cell_centering
    
    x_face_centering = _teca_py.teca_array_attributes_x_face_centering
    
    y_face_centering = _teca_py.teca_array_attributes_y_face_centering
    
    z_face_centering = _teca_py.teca_array_attributes_z_face_centering
    
    x_edge_centering = _teca_py.teca_array_attributes_x_edge_centering
    
    y_edge_centering = _teca_py.teca_array_attributes_y_edge_centering
    
    z_edge_centering = _teca_py.teca_array_attributes_z_edge_centering
    
    point_centering = _teca_py.teca_array_attributes_point_centering
    
    no_centering = _teca_py.teca_array_attributes_no_centering
    

    @staticmethod
    def centering_to_string(cen):
        r"""
        centering_to_string(int cen) -> char const *

        Parameters
        ----------
        cen: int

        """
        return _teca_py.teca_array_attributes_centering_to_string(cen)
    type_code = property(_teca_py.teca_array_attributes_type_code_get, _teca_py.teca_array_attributes_type_code_set, doc=r"""type_code : unsigned int""")
    centering = property(_teca_py.teca_array_attributes_centering_get, _teca_py.teca_array_attributes_centering_set, doc=r"""centering : unsigned int""")
    size = property(_teca_py.teca_array_attributes_size_get, _teca_py.teca_array_attributes_size_set, doc=r"""size : unsigned long""")
    units = property(_teca_py.teca_array_attributes_units_get, _teca_py.teca_array_attributes_units_set, doc=r"""units : std::string""")
    long_name = property(_teca_py.teca_array_attributes_long_name_get, _teca_py.teca_array_attributes_long_name_set, doc=r"""long_name : std::string""")
    description = property(_teca_py.teca_array_attributes_description_get, _teca_py.teca_array_attributes_description_set, doc=r"""description : std::string""")
    have_fill_value = property(_teca_py.teca_array_attributes_have_fill_value_get, _teca_py.teca_array_attributes_have_fill_value_set, doc=r"""have_fill_value : int""")
    fill_value = property(_teca_py.teca_array_attributes_fill_value_get, _teca_py.teca_array_attributes_fill_value_set, doc=r"""fill_value : teca_array_attributes::fill_value_t""")

    def __str__(self):
        r"""__str__(teca_array_attributes self) -> PyObject *"""
        return _teca_py.teca_array_attributes___str__(self)

    def to_metadata(self, *args):
        r"""
        to_metadata(teca_array_attributes self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata &

        to_metadata(teca_array_attributes self) -> teca_metadata
        """
        return _teca_py.teca_array_attributes_to_metadata(self, *args)

    def __init__(self, *args):
        r"""
        __init__(teca_array_attributes self) -> teca_array_attributes
        __init__(teca_array_attributes self, teca_array_attributes arg2) -> teca_array_attributes

        Parameters
        ----------
        arg2: teca_array_attributes const &

        __init__(teca_array_attributes self, teca_metadata md) -> teca_array_attributes

        Parameters
        ----------
        md: teca_metadata const &

        __init__(teca_array_attributes self, unsigned int tc, unsigned int cen, unsigned long n, std::string const & un, std::string const & ln, std::string const & descr, PyObject * fv) -> teca_array_attributes

        Parameters
        ----------
        tc: unsigned int
        cen: unsigned int
        n: unsigned long
        un: std::string const &
        ln: std::string const &
        descr: std::string const &
        fv: PyObject *

        """
        _teca_py.teca_array_attributes_swiginit(self, _teca_py.new_teca_array_attributes(*args))

    def set_fill_value(self, fv):
        r"""
        set_fill_value(teca_array_attributes self, PyObject * fv)

        Parameters
        ----------
        fv: PyObject *

        """
        return _teca_py.teca_array_attributes_set_fill_value(self, fv)
    __swig_destroy__ = _teca_py.delete_teca_array_attributes

# Register teca_array_attributes in _teca_py:
_teca_py.teca_array_attributes_swigregister(teca_array_attributes)

def teca_array_attributes_centering_to_string(cen):
    r"""
    teca_array_attributes_centering_to_string(int cen) -> char const *

    Parameters
    ----------
    cen: int

    """
    return _teca_py.teca_array_attributes_centering_to_string(cen)

class teca_array_collection(teca_dataset):
    r"""Proxy of C++ teca_array_collection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_array_collection"""
        return _teca_py.teca_array_collection_New()

    def new_instance(self):
        r"""new_instance(teca_array_collection self) -> p_teca_dataset"""
        return _teca_py.teca_array_collection_new_instance(self)

    def new_copy(self, *args):
        r"""
        new_copy(teca_array_collection self, teca_dataset::allocator alloc=allocator::malloc) -> p_teca_dataset

        Parameters
        ----------
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_array_collection_new_copy(self, *args)

    def new_shallow_copy(self):
        r"""new_shallow_copy(teca_array_collection self) -> p_teca_dataset"""
        return _teca_py.teca_array_collection_new_shallow_copy(self)

    def set_attributes(self, *args):
        r"""
        set_attributes(teca_array_collection self, std_vector_metadata vals)

        Parameters
        ----------
        vals: std::vector< teca_metadata,std::allocator< teca_metadata > > const &

        set_attributes(teca_array_collection self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_attributes(teca_array_collection self, std::initializer_list< teca_metadata > const & l)

        Parameters
        ----------
        l: std::initializer_list< teca_metadata > const &

        set_attributes(teca_array_collection self, teca_metadata val_1)

        Parameters
        ----------
        val_1: teca_metadata const &

        """
        return _teca_py.teca_array_collection_set_attributes(self, *args)

    def clear(self):
        r"""clear(teca_array_collection self)"""
        return _teca_py.teca_array_collection_clear(self)

    def set_default_allocator(self, alloc):
        r"""
        set_default_allocator(teca_array_collection self, teca_dataset::allocator alloc)

        Parameters
        ----------
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_array_collection_set_default_allocator(self, alloc)

    def set(self, *args):
        r"""
        set(teca_array_collection self, unsigned int i, p_teca_variant_array array) -> int

        Parameters
        ----------
        i: unsigned int
        array: p_teca_variant_array

        set(teca_array_collection self, std::string const & name, p_teca_variant_array array) -> int

        Parameters
        ----------
        name: std::string const &
        array: p_teca_variant_array

        """
        return _teca_py.teca_array_collection_set(self, *args)

    def remove(self, *args):
        r"""
        remove(teca_array_collection self, unsigned int i) -> int

        Parameters
        ----------
        i: unsigned int

        remove(teca_array_collection self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_array_collection_remove(self, *args)

    def size(self):
        r"""size(teca_array_collection self) -> unsigned int"""
        return _teca_py.teca_array_collection_size(self)

    def has(self, name):
        r"""
        has(teca_array_collection self, std::string const & name) -> bool

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_array_collection_has(self, name)

    def get(self, *args):
        r"""
        get(teca_array_collection self, unsigned int i) -> p_teca_variant_array

        Parameters
        ----------
        i: unsigned int

        get(teca_array_collection self, unsigned int i) -> const_p_teca_variant_array

        Parameters
        ----------
        i: unsigned int

        get(teca_array_collection self, std::string const & name) -> p_teca_variant_array

        Parameters
        ----------
        name: std::string const &

        get(teca_array_collection self, std::string const & name) -> const_p_teca_variant_array

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_array_collection_get(self, *args)

    def get_name(self, *args):
        r"""
        get_name(teca_array_collection self, unsigned int i) -> std::string

        Parameters
        ----------
        i: unsigned int

        get_name(teca_array_collection self, unsigned int i) -> std::string const &

        Parameters
        ----------
        i: unsigned int

        """
        return _teca_py.teca_array_collection_get_name(self, *args)

    def get_names(self, *args):
        r"""
        get_names(teca_array_collection self) -> std_vector_string
        get_names(teca_array_collection self) -> std_vector_string
        """
        return _teca_py.teca_array_collection_get_names(self, *args)

    def get_class_name(self):
        r"""get_class_name(teca_array_collection self) -> std::string"""
        return _teca_py.teca_array_collection_get_class_name(self)

    def get_type_code(self):
        r"""get_type_code(teca_array_collection self) -> int"""
        return _teca_py.teca_array_collection_get_type_code(self)

    def copy(self, *args):
        r"""
        copy(teca_array_collection self, const_p_teca_dataset const & other, teca_dataset::allocator alloc=allocator::malloc)

        Parameters
        ----------
        other: const_p_teca_dataset const &
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_array_collection_copy(self, *args)

    def shallow_copy(self, other):
        r"""
        shallow_copy(teca_array_collection self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_array_collection_shallow_copy(self, other)

    def shallow_append(self, other):
        r"""
        shallow_append(teca_array_collection self, p_teca_array_collection const & other) -> int

        Parameters
        ----------
        other: p_teca_array_collection const &

        """
        return _teca_py.teca_array_collection_shallow_append(self, other)

    def swap(self, other):
        r"""
        swap(teca_array_collection self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_array_collection_swap(self, other)

    def to_stream(self, *args):
        r"""
        to_stream(teca_array_collection self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_array_collection self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_array_collection_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_array_collection self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_array_collection self, istream arg2) -> int

        Parameters
        ----------
        arg2: std::istream &

        """
        return _teca_py.teca_array_collection_from_stream(self, *args)

    def __str__(self):
        r"""__str__(teca_array_collection self) -> PyObject *"""
        return _teca_py.teca_array_collection___str__(self)

    def set_time(self, *args):
        r"""
        set_time(teca_array_collection self, std_vector_double vals)

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > const &

        set_time(teca_array_collection self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_time(teca_array_collection self, std::initializer_list< double > const & l)

        Parameters
        ----------
        l: std::initializer_list< double > const &

        set_time(teca_array_collection self, double const * vals)

        Parameters
        ----------
        vals: double const *

        set_time(teca_array_collection self, double const & val_1)

        Parameters
        ----------
        val_1: double const &

        set_time(teca_array_collection self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_array_collection_set_time(self, *args)

    def get_time(self, *args):
        r"""
        get_time(teca_array_collection self, std_vector_double vals) -> int

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > &

        get_time(teca_array_collection self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_time(teca_array_collection self, double & val_1) -> int

        Parameters
        ----------
        val_1: double &

        get_time(teca_array_collection self) -> PyObject *
        """
        return _teca_py.teca_array_collection_get_time(self, *args)

    def set_time_step(self, *args):
        r"""
        set_time_step(teca_array_collection self, std_vector_ulong vals)

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_time_step(teca_array_collection self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_time_step(teca_array_collection self, std::initializer_list< unsigned long > const & l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &

        set_time_step(teca_array_collection self, unsigned long const * vals)

        Parameters
        ----------
        vals: unsigned long const *

        set_time_step(teca_array_collection self, unsigned long const & val_1)

        Parameters
        ----------
        val_1: unsigned long const &

        set_time_step(teca_array_collection self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_array_collection_set_time_step(self, *args)

    def get_time_step(self, *args):
        r"""
        get_time_step(teca_array_collection self, std_vector_ulong vals) -> int

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > &

        get_time_step(teca_array_collection self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_time_step(teca_array_collection self, unsigned long & val_1) -> int

        Parameters
        ----------
        val_1: unsigned long &

        get_time_step(teca_array_collection self) -> PyObject *
        """
        return _teca_py.teca_array_collection_get_time_step(self, *args)

    def set_calendar(self, *args):
        r"""
        set_calendar(teca_array_collection self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_calendar(teca_array_collection self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_calendar(teca_array_collection self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_calendar(teca_array_collection self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_calendar(teca_array_collection self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_array_collection_set_calendar(self, *args)

    def get_calendar(self, *args):
        r"""
        get_calendar(teca_array_collection self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_calendar(teca_array_collection self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_calendar(teca_array_collection self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_calendar(teca_array_collection self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_calendar(teca_array_collection self) -> PyObject *
        """
        return _teca_py.teca_array_collection_get_calendar(self, *args)

    def set_time_units(self, *args):
        r"""
        set_time_units(teca_array_collection self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_time_units(teca_array_collection self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_time_units(teca_array_collection self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_time_units(teca_array_collection self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_time_units(teca_array_collection self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_array_collection_set_time_units(self, *args)

    def get_time_units(self, *args):
        r"""
        get_time_units(teca_array_collection self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_time_units(teca_array_collection self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_time_units(teca_array_collection self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_time_units(teca_array_collection self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_time_units(teca_array_collection self) -> PyObject *
        """
        return _teca_py.teca_array_collection_get_time_units(self, *args)

    def get_attributes(self, *args):
        r"""
        get_attributes(teca_array_collection self, std_vector_metadata vals) -> int

        Parameters
        ----------
        vals: std::vector< teca_metadata,std::allocator< teca_metadata > > &

        get_attributes(teca_array_collection self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_attributes(teca_array_collection self, teca_metadata val_1) -> int

        Parameters
        ----------
        val_1: teca_metadata &

        get_attributes(teca_array_collection self) -> teca_metadata
        """
        return _teca_py.teca_array_collection_get_attributes(self, *args)

    def __setitem__(self, name, array):
        r"""
        __setitem__(teca_array_collection self, std::string const & name, PyObject * array) -> PyObject *

        Parameters
        ----------
        name: std::string const &
        array: PyObject *

        """
        return _teca_py.teca_array_collection___setitem__(self, name, array)

    def __getitem__(self, name):
       r""" returns the array by name. The returned array will always be
       accessible on the CPU. Use get if you need an array that is accessible
       on the GPU  """
       return self.get(name)


    def append(self, *args):
        r"""
        append(teca_array_collection self, p_teca_variant_array array) -> int

        Parameters
        ----------
        array: p_teca_variant_array

        append(teca_array_collection self, std::string const & name, p_teca_variant_array array) -> int

        Parameters
        ----------
        name: std::string const &
        array: p_teca_variant_array

        append(teca_array_collection self, const_p_teca_array_collection const & other) -> int

        Parameters
        ----------
        other: const_p_teca_array_collection const &

        append(teca_array_collection self, std::string const & name, PyObject * array)

        Parameters
        ----------
        name: std::string const &
        array: PyObject *

        """
        return _teca_py.teca_array_collection_append(self, *args)
    __swig_destroy__ = _teca_py.delete_teca_array_collection

# Register teca_array_collection in _teca_py:
_teca_py.teca_array_collection_swigregister(teca_array_collection)

def teca_array_collection_New():
    r"""teca_array_collection_New() -> p_teca_array_collection"""
    return _teca_py.teca_array_collection_New()


def as_teca_array_collection(in_inst):
    r"""
    as_teca_array_collection(p_teca_dataset in_inst) -> p_teca_array_collection

    Parameters
    ----------
    in_inst: p_teca_dataset

    """
    return _teca_py.as_teca_array_collection(in_inst)

def as_const_teca_array_collection(inst):
    r"""
    as_const_teca_array_collection(const_p_teca_dataset inst) -> const_p_teca_array_collection

    Parameters
    ----------
    inst: const_p_teca_dataset

    """
    return _teca_py.as_const_teca_array_collection(inst)

def as_non_const_teca_array_collection(in_inst):
    r"""
    as_non_const_teca_array_collection(const_p_teca_array_collection in_inst) -> p_teca_array_collection

    Parameters
    ----------
    in_inst: const_p_teca_array_collection

    """
    return _teca_py.as_non_const_teca_array_collection(in_inst)
class teca_mesh(teca_dataset):
    r"""Proxy of C++ teca_mesh class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _teca_py.delete_teca_mesh

    def set_attributes(self, *args):
        r"""
        set_attributes(teca_mesh self, std_vector_metadata vals)

        Parameters
        ----------
        vals: std::vector< teca_metadata,std::allocator< teca_metadata > > const &

        set_attributes(teca_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_attributes(teca_mesh self, std::initializer_list< teca_metadata > const & l)

        Parameters
        ----------
        l: std::initializer_list< teca_metadata > const &

        set_attributes(teca_mesh self, teca_metadata val_1)

        Parameters
        ----------
        val_1: teca_metadata const &

        """
        return _teca_py.teca_mesh_set_attributes(self, *args)

    def get_arrays(self, centering):
        r"""
        get_arrays(teca_mesh self, int centering) -> p_teca_array_collection &

        Parameters
        ----------
        centering: int

        """
        return _teca_py.teca_mesh_get_arrays(self, centering)

    def get_point_arrays(self):
        r"""get_point_arrays(teca_mesh self) -> p_teca_array_collection &"""
        return _teca_py.teca_mesh_get_point_arrays(self)

    def get_cell_arrays(self):
        r"""get_cell_arrays(teca_mesh self) -> p_teca_array_collection &"""
        return _teca_py.teca_mesh_get_cell_arrays(self)

    def get_x_edge_arrays(self):
        r"""get_x_edge_arrays(teca_mesh self) -> p_teca_array_collection &"""
        return _teca_py.teca_mesh_get_x_edge_arrays(self)

    def get_y_edge_arrays(self):
        r"""get_y_edge_arrays(teca_mesh self) -> p_teca_array_collection &"""
        return _teca_py.teca_mesh_get_y_edge_arrays(self)

    def get_z_edge_arrays(self):
        r"""get_z_edge_arrays(teca_mesh self) -> p_teca_array_collection &"""
        return _teca_py.teca_mesh_get_z_edge_arrays(self)

    def get_x_face_arrays(self):
        r"""get_x_face_arrays(teca_mesh self) -> p_teca_array_collection &"""
        return _teca_py.teca_mesh_get_x_face_arrays(self)

    def get_y_face_arrays(self):
        r"""get_y_face_arrays(teca_mesh self) -> p_teca_array_collection &"""
        return _teca_py.teca_mesh_get_y_face_arrays(self)

    def get_z_face_arrays(self):
        r"""get_z_face_arrays(teca_mesh self) -> p_teca_array_collection &"""
        return _teca_py.teca_mesh_get_z_face_arrays(self)

    def get_information_arrays(self):
        r"""get_information_arrays(teca_mesh self) -> p_teca_array_collection &"""
        return _teca_py.teca_mesh_get_information_arrays(self)

    def get_number_of_points(self):
        r"""get_number_of_points(teca_mesh self) -> unsigned long"""
        return _teca_py.teca_mesh_get_number_of_points(self)

    def get_number_of_cells(self):
        r"""get_number_of_cells(teca_mesh self) -> unsigned long"""
        return _teca_py.teca_mesh_get_number_of_cells(self)

    def empty(self):
        r"""empty(teca_mesh self) -> bool"""
        return _teca_py.teca_mesh_empty(self)

    def copy(self, *args):
        r"""
        copy(teca_mesh self, const_p_teca_dataset const & other, teca_dataset::allocator alloc=allocator::malloc)

        Parameters
        ----------
        other: const_p_teca_dataset const &
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_mesh_copy(self, *args)

    def shallow_copy(self, other):
        r"""
        shallow_copy(teca_mesh self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_mesh_shallow_copy(self, other)

    def append_arrays(self, arg2):
        r"""
        append_arrays(teca_mesh self, const_p_teca_mesh const & arg2)

        Parameters
        ----------
        arg2: const_p_teca_mesh const &

        """
        return _teca_py.teca_mesh_append_arrays(self, arg2)

    def shallow_append_arrays(self, arg2):
        r"""
        shallow_append_arrays(teca_mesh self, p_teca_mesh const & arg2)

        Parameters
        ----------
        arg2: p_teca_mesh const &

        """
        return _teca_py.teca_mesh_shallow_append_arrays(self, arg2)

    def swap(self, arg2):
        r"""
        swap(teca_mesh self, p_teca_dataset const & arg2)

        Parameters
        ----------
        arg2: p_teca_dataset const &

        """
        return _teca_py.teca_mesh_swap(self, arg2)

    def to_stream(self, *args):
        r"""
        to_stream(teca_mesh self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        to_stream(teca_mesh self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_mesh_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_mesh self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        from_stream(teca_mesh self, istream arg2) -> int

        Parameters
        ----------
        arg2: std::istream &

        """
        return _teca_py.teca_mesh_from_stream(self, *args)
    m_impl = property(_teca_py.teca_mesh_m_impl_get, _teca_py.teca_mesh_m_impl_set, doc=r"""m_impl : std::shared_ptr<(teca_mesh::impl_t)>""")

    def __str__(self):
        r"""__str__(teca_mesh self) -> PyObject *"""
        return _teca_py.teca_mesh___str__(self)

    def set_time(self, *args):
        r"""
        set_time(teca_mesh self, std_vector_double vals)

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > const &

        set_time(teca_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_time(teca_mesh self, std::initializer_list< double > const & l)

        Parameters
        ----------
        l: std::initializer_list< double > const &

        set_time(teca_mesh self, double const * vals)

        Parameters
        ----------
        vals: double const *

        set_time(teca_mesh self, double const & val_1)

        Parameters
        ----------
        val_1: double const &

        set_time(teca_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_mesh_set_time(self, *args)

    def get_time(self, *args):
        r"""
        get_time(teca_mesh self, std_vector_double vals) -> int

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > &

        get_time(teca_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_time(teca_mesh self, double & val_1) -> int

        Parameters
        ----------
        val_1: double &

        get_time(teca_mesh self) -> PyObject *
        """
        return _teca_py.teca_mesh_get_time(self, *args)

    def set_time_step(self, *args):
        r"""
        set_time_step(teca_mesh self, std_vector_ulong vals)

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_time_step(teca_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_time_step(teca_mesh self, std::initializer_list< unsigned long > const & l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &

        set_time_step(teca_mesh self, unsigned long const * vals)

        Parameters
        ----------
        vals: unsigned long const *

        set_time_step(teca_mesh self, unsigned long const & val_1)

        Parameters
        ----------
        val_1: unsigned long const &

        set_time_step(teca_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_mesh_set_time_step(self, *args)

    def get_time_step(self, *args):
        r"""
        get_time_step(teca_mesh self, std_vector_ulong vals) -> int

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > &

        get_time_step(teca_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_time_step(teca_mesh self, unsigned long & val_1) -> int

        Parameters
        ----------
        val_1: unsigned long &

        get_time_step(teca_mesh self) -> PyObject *
        """
        return _teca_py.teca_mesh_get_time_step(self, *args)

    def set_calendar(self, *args):
        r"""
        set_calendar(teca_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_calendar(teca_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_calendar(teca_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_calendar(teca_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_calendar(teca_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_mesh_set_calendar(self, *args)

    def get_calendar(self, *args):
        r"""
        get_calendar(teca_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_calendar(teca_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_calendar(teca_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_calendar(teca_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_calendar(teca_mesh self) -> PyObject *
        """
        return _teca_py.teca_mesh_get_calendar(self, *args)

    def set_time_units(self, *args):
        r"""
        set_time_units(teca_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_time_units(teca_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_time_units(teca_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_time_units(teca_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_time_units(teca_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_mesh_set_time_units(self, *args)

    def get_time_units(self, *args):
        r"""
        get_time_units(teca_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_time_units(teca_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_time_units(teca_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_time_units(teca_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_time_units(teca_mesh self) -> PyObject *
        """
        return _teca_py.teca_mesh_get_time_units(self, *args)

    def get_attributes(self, *args):
        r"""
        get_attributes(teca_mesh self, std_vector_metadata vals) -> int

        Parameters
        ----------
        vals: std::vector< teca_metadata,std::allocator< teca_metadata > > &

        get_attributes(teca_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_attributes(teca_mesh self, teca_metadata val_1) -> int

        Parameters
        ----------
        val_1: teca_metadata &

        get_attributes(teca_mesh self) -> teca_metadata
        """
        return _teca_py.teca_mesh_get_attributes(self, *args)

# Register teca_mesh in _teca_py:
_teca_py.teca_mesh_swigregister(teca_mesh)


def as_teca_mesh(in_inst):
    r"""
    as_teca_mesh(p_teca_dataset in_inst) -> p_teca_mesh

    Parameters
    ----------
    in_inst: p_teca_dataset

    """
    return _teca_py.as_teca_mesh(in_inst)

def as_const_teca_mesh(inst):
    r"""
    as_const_teca_mesh(const_p_teca_dataset inst) -> const_p_teca_mesh

    Parameters
    ----------
    inst: const_p_teca_dataset

    """
    return _teca_py.as_const_teca_mesh(inst)

def as_non_const_teca_mesh(in_inst):
    r"""
    as_non_const_teca_mesh(const_p_teca_mesh in_inst) -> p_teca_mesh

    Parameters
    ----------
    in_inst: const_p_teca_mesh

    """
    return _teca_py.as_non_const_teca_mesh(in_inst)
class teca_cartesian_mesh(teca_mesh):
    r"""Proxy of C++ teca_cartesian_mesh class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_cartesian_mesh"""
        return _teca_py.teca_cartesian_mesh_New()

    def new_instance(self):
        r"""new_instance(teca_cartesian_mesh self) -> p_teca_dataset"""
        return _teca_py.teca_cartesian_mesh_new_instance(self)

    def new_copy(self, *args):
        r"""
        new_copy(teca_cartesian_mesh self, teca_dataset::allocator alloc=allocator::malloc) -> p_teca_dataset

        Parameters
        ----------
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_cartesian_mesh_new_copy(self, *args)

    def new_shallow_copy(self):
        r"""new_shallow_copy(teca_cartesian_mesh self) -> p_teca_dataset"""
        return _teca_py.teca_cartesian_mesh_new_shallow_copy(self)
    __swig_destroy__ = _teca_py.delete_teca_cartesian_mesh

    def get_array_extent(self, array_name, array_extent):
        r"""
        get_array_extent(teca_cartesian_mesh self, std::string const & array_name, unsigned long [6] array_extent) -> int

        Parameters
        ----------
        array_name: std::string const &
        array_extent: unsigned long [6]

        """
        return _teca_py.teca_cartesian_mesh_get_array_extent(self, array_name, array_extent)

    def get_number_of_points(self):
        r"""get_number_of_points(teca_cartesian_mesh self) -> unsigned long"""
        return _teca_py.teca_cartesian_mesh_get_number_of_points(self)

    def get_number_of_cells(self):
        r"""get_number_of_cells(teca_cartesian_mesh self) -> unsigned long"""
        return _teca_py.teca_cartesian_mesh_get_number_of_cells(self)

    def get_x_coordinates(self, *args):
        r"""
        get_x_coordinates(teca_cartesian_mesh self) -> p_teca_variant_array
        get_x_coordinates(teca_cartesian_mesh self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_cartesian_mesh_get_x_coordinates(self, *args)

    def get_y_coordinates(self, *args):
        r"""
        get_y_coordinates(teca_cartesian_mesh self) -> p_teca_variant_array
        get_y_coordinates(teca_cartesian_mesh self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_cartesian_mesh_get_y_coordinates(self, *args)

    def get_z_coordinates(self, *args):
        r"""
        get_z_coordinates(teca_cartesian_mesh self) -> p_teca_variant_array
        get_z_coordinates(teca_cartesian_mesh self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_cartesian_mesh_get_z_coordinates(self, *args)

    def set_x_coordinates(self, name, array):
        r"""
        set_x_coordinates(teca_cartesian_mesh self, std::string const & name, p_teca_variant_array const & array)

        Parameters
        ----------
        name: std::string const &
        array: p_teca_variant_array const &

        """
        return _teca_py.teca_cartesian_mesh_set_x_coordinates(self, name, array)

    def set_y_coordinates(self, name, array):
        r"""
        set_y_coordinates(teca_cartesian_mesh self, std::string const & name, p_teca_variant_array const & array)

        Parameters
        ----------
        name: std::string const &
        array: p_teca_variant_array const &

        """
        return _teca_py.teca_cartesian_mesh_set_y_coordinates(self, name, array)

    def set_z_coordinates(self, name, array):
        r"""
        set_z_coordinates(teca_cartesian_mesh self, std::string const & name, p_teca_variant_array const & array)

        Parameters
        ----------
        name: std::string const &
        array: p_teca_variant_array const &

        """
        return _teca_py.teca_cartesian_mesh_set_z_coordinates(self, name, array)

    def update_x_coordinates(self, array):
        r"""
        update_x_coordinates(teca_cartesian_mesh self, p_teca_variant_array const & array)

        Parameters
        ----------
        array: p_teca_variant_array const &

        """
        return _teca_py.teca_cartesian_mesh_update_x_coordinates(self, array)

    def update_y_coordinates(self, array):
        r"""
        update_y_coordinates(teca_cartesian_mesh self, p_teca_variant_array const & array)

        Parameters
        ----------
        array: p_teca_variant_array const &

        """
        return _teca_py.teca_cartesian_mesh_update_y_coordinates(self, array)

    def update_z_coordinates(self, array):
        r"""
        update_z_coordinates(teca_cartesian_mesh self, p_teca_variant_array const & array)

        Parameters
        ----------
        array: p_teca_variant_array const &

        """
        return _teca_py.teca_cartesian_mesh_update_z_coordinates(self, array)

    def get_class_name(self):
        r"""get_class_name(teca_cartesian_mesh self) -> std::string"""
        return _teca_py.teca_cartesian_mesh_get_class_name(self)

    def get_type_code(self):
        r"""get_type_code(teca_cartesian_mesh self) -> int"""
        return _teca_py.teca_cartesian_mesh_get_type_code(self)

    def copy(self, *args):
        r"""
        copy(teca_cartesian_mesh self, const_p_teca_dataset const & other, teca_dataset::allocator alloc=allocator::malloc)

        Parameters
        ----------
        other: const_p_teca_dataset const &
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_cartesian_mesh_copy(self, *args)

    def shallow_copy(self, other):
        r"""
        shallow_copy(teca_cartesian_mesh self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_cartesian_mesh_shallow_copy(self, other)

    def copy_metadata(self, other):
        r"""
        copy_metadata(teca_cartesian_mesh self, const_p_teca_dataset const & other)

        Parameters
        ----------
        other: const_p_teca_dataset const &

        """
        return _teca_py.teca_cartesian_mesh_copy_metadata(self, other)

    def swap(self, arg2):
        r"""
        swap(teca_cartesian_mesh self, p_teca_dataset const & arg2)

        Parameters
        ----------
        arg2: p_teca_dataset const &

        """
        return _teca_py.teca_cartesian_mesh_swap(self, arg2)

    def to_stream(self, *args):
        r"""
        to_stream(teca_cartesian_mesh self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        to_stream(teca_cartesian_mesh self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_cartesian_mesh_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_cartesian_mesh self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        from_stream(teca_cartesian_mesh self, istream arg2) -> int

        Parameters
        ----------
        arg2: std::istream &

        """
        return _teca_py.teca_cartesian_mesh_from_stream(self, *args)

    def __str__(self):
        r"""__str__(teca_cartesian_mesh self) -> PyObject *"""
        return _teca_py.teca_cartesian_mesh___str__(self)

    def get_extent(self, *args):
        r"""
        get_extent(teca_cartesian_mesh self, std_vector_ulong vals) -> int

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > &

        get_extent(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_extent(teca_cartesian_mesh self, unsigned long * vals) -> int

        Parameters
        ----------
        vals: unsigned long *

        get_extent(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_extent(self, *args)

    def set_extent(self, *args):
        r"""
        set_extent(teca_cartesian_mesh self, std_vector_ulong vals)

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_extent(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_extent(teca_cartesian_mesh self, std::initializer_list< unsigned long > const & l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &

        set_extent(teca_cartesian_mesh self, unsigned long const * vals)

        Parameters
        ----------
        vals: unsigned long const *

        set_extent(teca_cartesian_mesh self, unsigned long const & val_1, unsigned long const & val_2, unsigned long const & val_3, unsigned long const & val_4, unsigned long const & val_5, unsigned long const & val_6)

        Parameters
        ----------
        val_1: unsigned long const &
        val_2: unsigned long const &
        val_3: unsigned long const &
        val_4: unsigned long const &
        val_5: unsigned long const &
        val_6: unsigned long const &

        set_extent(teca_cartesian_mesh self, PyObject * array) -> PyObject *

        Parameters
        ----------
        array: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_extent(self, *args)

    def get_whole_extent(self, *args):
        r"""
        get_whole_extent(teca_cartesian_mesh self, std_vector_ulong vals) -> int

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > &

        get_whole_extent(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_whole_extent(teca_cartesian_mesh self, unsigned long * vals) -> int

        Parameters
        ----------
        vals: unsigned long *

        get_whole_extent(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_whole_extent(self, *args)

    def set_whole_extent(self, *args):
        r"""
        set_whole_extent(teca_cartesian_mesh self, std_vector_ulong vals)

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_whole_extent(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_whole_extent(teca_cartesian_mesh self, std::initializer_list< unsigned long > const & l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &

        set_whole_extent(teca_cartesian_mesh self, unsigned long const * vals)

        Parameters
        ----------
        vals: unsigned long const *

        set_whole_extent(teca_cartesian_mesh self, unsigned long const & val_1, unsigned long const & val_2, unsigned long const & val_3, unsigned long const & val_4, unsigned long const & val_5, unsigned long const & val_6)

        Parameters
        ----------
        val_1: unsigned long const &
        val_2: unsigned long const &
        val_3: unsigned long const &
        val_4: unsigned long const &
        val_5: unsigned long const &
        val_6: unsigned long const &

        set_whole_extent(teca_cartesian_mesh self, PyObject * array) -> PyObject *

        Parameters
        ----------
        array: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_whole_extent(self, *args)

    def get_bounds(self, *args):
        r"""
        get_bounds(teca_cartesian_mesh self, std_vector_double vals) -> int

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > &

        get_bounds(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_bounds(teca_cartesian_mesh self, double * vals) -> int

        Parameters
        ----------
        vals: double *

        get_bounds(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_bounds(self, *args)

    def set_bounds(self, *args):
        r"""
        set_bounds(teca_cartesian_mesh self, std_vector_double vals)

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > const &

        set_bounds(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_bounds(teca_cartesian_mesh self, std::initializer_list< double > const & l)

        Parameters
        ----------
        l: std::initializer_list< double > const &

        set_bounds(teca_cartesian_mesh self, double const * vals)

        Parameters
        ----------
        vals: double const *

        set_bounds(teca_cartesian_mesh self, double const & val_1, double const & val_2, double const & val_3, double const & val_4, double const & val_5, double const & val_6)

        Parameters
        ----------
        val_1: double const &
        val_2: double const &
        val_3: double const &
        val_4: double const &
        val_5: double const &
        val_6: double const &

        set_bounds(teca_cartesian_mesh self, PyObject * array) -> PyObject *

        Parameters
        ----------
        array: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_bounds(self, *args)

    def set_periodic_in_x(self, *args):
        r"""
        set_periodic_in_x(teca_cartesian_mesh self, std_vector_int vals)

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > const &

        set_periodic_in_x(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_periodic_in_x(teca_cartesian_mesh self, std::initializer_list< int > const & l)

        Parameters
        ----------
        l: std::initializer_list< int > const &

        set_periodic_in_x(teca_cartesian_mesh self, int const * vals)

        Parameters
        ----------
        vals: int const *

        set_periodic_in_x(teca_cartesian_mesh self, int const & val_1)

        Parameters
        ----------
        val_1: int const &

        set_periodic_in_x(teca_cartesian_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_periodic_in_x(self, *args)

    def get_periodic_in_x(self, *args):
        r"""
        get_periodic_in_x(teca_cartesian_mesh self, std_vector_int vals) -> int

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > &

        get_periodic_in_x(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_periodic_in_x(teca_cartesian_mesh self, int & val_1) -> int

        Parameters
        ----------
        val_1: int &

        get_periodic_in_x(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_periodic_in_x(self, *args)

    def set_periodic_in_y(self, *args):
        r"""
        set_periodic_in_y(teca_cartesian_mesh self, std_vector_int vals)

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > const &

        set_periodic_in_y(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_periodic_in_y(teca_cartesian_mesh self, std::initializer_list< int > const & l)

        Parameters
        ----------
        l: std::initializer_list< int > const &

        set_periodic_in_y(teca_cartesian_mesh self, int const * vals)

        Parameters
        ----------
        vals: int const *

        set_periodic_in_y(teca_cartesian_mesh self, int const & val_1)

        Parameters
        ----------
        val_1: int const &

        set_periodic_in_y(teca_cartesian_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_periodic_in_y(self, *args)

    def get_periodic_in_y(self, *args):
        r"""
        get_periodic_in_y(teca_cartesian_mesh self, std_vector_int vals) -> int

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > &

        get_periodic_in_y(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_periodic_in_y(teca_cartesian_mesh self, int & val_1) -> int

        Parameters
        ----------
        val_1: int &

        get_periodic_in_y(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_periodic_in_y(self, *args)

    def set_periodic_in_z(self, *args):
        r"""
        set_periodic_in_z(teca_cartesian_mesh self, std_vector_int vals)

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > const &

        set_periodic_in_z(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_periodic_in_z(teca_cartesian_mesh self, std::initializer_list< int > const & l)

        Parameters
        ----------
        l: std::initializer_list< int > const &

        set_periodic_in_z(teca_cartesian_mesh self, int const * vals)

        Parameters
        ----------
        vals: int const *

        set_periodic_in_z(teca_cartesian_mesh self, int const & val_1)

        Parameters
        ----------
        val_1: int const &

        set_periodic_in_z(teca_cartesian_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_periodic_in_z(self, *args)

    def get_periodic_in_z(self, *args):
        r"""
        get_periodic_in_z(teca_cartesian_mesh self, std_vector_int vals) -> int

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > &

        get_periodic_in_z(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_periodic_in_z(teca_cartesian_mesh self, int & val_1) -> int

        Parameters
        ----------
        val_1: int &

        get_periodic_in_z(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_periodic_in_z(self, *args)

    def set_x_coordinate_variable(self, *args):
        r"""
        set_x_coordinate_variable(teca_cartesian_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_x_coordinate_variable(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_x_coordinate_variable(teca_cartesian_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_x_coordinate_variable(teca_cartesian_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_x_coordinate_variable(teca_cartesian_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_x_coordinate_variable(self, *args)

    def get_x_coordinate_variable(self, *args):
        r"""
        get_x_coordinate_variable(teca_cartesian_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_x_coordinate_variable(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_x_coordinate_variable(teca_cartesian_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_x_coordinate_variable(teca_cartesian_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_x_coordinate_variable(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_x_coordinate_variable(self, *args)

    def set_y_coordinate_variable(self, *args):
        r"""
        set_y_coordinate_variable(teca_cartesian_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_y_coordinate_variable(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_y_coordinate_variable(teca_cartesian_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_y_coordinate_variable(teca_cartesian_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_y_coordinate_variable(teca_cartesian_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_y_coordinate_variable(self, *args)

    def get_y_coordinate_variable(self, *args):
        r"""
        get_y_coordinate_variable(teca_cartesian_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_y_coordinate_variable(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_y_coordinate_variable(teca_cartesian_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_y_coordinate_variable(teca_cartesian_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_y_coordinate_variable(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_y_coordinate_variable(self, *args)

    def set_z_coordinate_variable(self, *args):
        r"""
        set_z_coordinate_variable(teca_cartesian_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_z_coordinate_variable(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_z_coordinate_variable(teca_cartesian_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_z_coordinate_variable(teca_cartesian_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_z_coordinate_variable(teca_cartesian_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_z_coordinate_variable(self, *args)

    def get_z_coordinate_variable(self, *args):
        r"""
        get_z_coordinate_variable(teca_cartesian_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_z_coordinate_variable(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_z_coordinate_variable(teca_cartesian_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_z_coordinate_variable(teca_cartesian_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_z_coordinate_variable(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_z_coordinate_variable(self, *args)

    def set_t_coordinate_variable(self, *args):
        r"""
        set_t_coordinate_variable(teca_cartesian_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_t_coordinate_variable(teca_cartesian_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_t_coordinate_variable(teca_cartesian_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_t_coordinate_variable(teca_cartesian_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_t_coordinate_variable(teca_cartesian_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_cartesian_mesh_set_t_coordinate_variable(self, *args)

    def get_t_coordinate_variable(self, *args):
        r"""
        get_t_coordinate_variable(teca_cartesian_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_t_coordinate_variable(teca_cartesian_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_t_coordinate_variable(teca_cartesian_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_t_coordinate_variable(teca_cartesian_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_t_coordinate_variable(teca_cartesian_mesh self) -> PyObject *
        """
        return _teca_py.teca_cartesian_mesh_get_t_coordinate_variable(self, *args)

# Register teca_cartesian_mesh in _teca_py:
_teca_py.teca_cartesian_mesh_swigregister(teca_cartesian_mesh)

def teca_cartesian_mesh_New():
    r"""teca_cartesian_mesh_New() -> p_teca_cartesian_mesh"""
    return _teca_py.teca_cartesian_mesh_New()


def as_teca_cartesian_mesh(in_inst):
    r"""
    as_teca_cartesian_mesh(p_teca_dataset in_inst) -> p_teca_cartesian_mesh

    Parameters
    ----------
    in_inst: p_teca_dataset

    """
    return _teca_py.as_teca_cartesian_mesh(in_inst)

def as_const_teca_cartesian_mesh(inst):
    r"""
    as_const_teca_cartesian_mesh(const_p_teca_dataset inst) -> const_p_teca_cartesian_mesh

    Parameters
    ----------
    inst: const_p_teca_dataset

    """
    return _teca_py.as_const_teca_cartesian_mesh(inst)

def as_non_const_teca_cartesian_mesh(in_inst):
    r"""
    as_non_const_teca_cartesian_mesh(const_p_teca_cartesian_mesh in_inst) -> p_teca_cartesian_mesh

    Parameters
    ----------
    in_inst: const_p_teca_cartesian_mesh

    """
    return _teca_py.as_non_const_teca_cartesian_mesh(in_inst)
class teca_curvilinear_mesh(teca_mesh):
    r"""Proxy of C++ teca_curvilinear_mesh class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_curvilinear_mesh"""
        return _teca_py.teca_curvilinear_mesh_New()

    def new_instance(self):
        r"""new_instance(teca_curvilinear_mesh self) -> p_teca_dataset"""
        return _teca_py.teca_curvilinear_mesh_new_instance(self)

    def new_copy(self, *args):
        r"""
        new_copy(teca_curvilinear_mesh self, teca_dataset::allocator alloc=allocator::malloc) -> p_teca_dataset

        Parameters
        ----------
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_curvilinear_mesh_new_copy(self, *args)

    def new_shallow_copy(self):
        r"""new_shallow_copy(teca_curvilinear_mesh self) -> p_teca_dataset"""
        return _teca_py.teca_curvilinear_mesh_new_shallow_copy(self)
    __swig_destroy__ = _teca_py.delete_teca_curvilinear_mesh

    def get_class_name(self):
        r"""get_class_name(teca_curvilinear_mesh self) -> std::string"""
        return _teca_py.teca_curvilinear_mesh_get_class_name(self)

    def get_type_code(self):
        r"""get_type_code(teca_curvilinear_mesh self) -> int"""
        return _teca_py.teca_curvilinear_mesh_get_type_code(self)

    def get_bounds(self, *args):
        r"""
        get_bounds(teca_curvilinear_mesh self, std_vector_double vals) -> int

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > &

        get_bounds(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_bounds(teca_curvilinear_mesh self, double * vals) -> int

        Parameters
        ----------
        vals: double *

        """
        return _teca_py.teca_curvilinear_mesh_get_bounds(self, *args)

    def set_bounds(self, *args):
        r"""
        set_bounds(teca_curvilinear_mesh self, std_vector_double vals)

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > const &

        set_bounds(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_bounds(teca_curvilinear_mesh self, std::initializer_list< double > const & l)

        Parameters
        ----------
        l: std::initializer_list< double > const &

        set_bounds(teca_curvilinear_mesh self, double const * vals)

        Parameters
        ----------
        vals: double const *

        set_bounds(teca_curvilinear_mesh self, double const & val_1, double const & val_2, double const & val_3, double const & val_4, double const & val_5, double const & val_6)

        Parameters
        ----------
        val_1: double const &
        val_2: double const &
        val_3: double const &
        val_4: double const &
        val_5: double const &
        val_6: double const &

        """
        return _teca_py.teca_curvilinear_mesh_set_bounds(self, *args)

    def get_number_of_points(self):
        r"""get_number_of_points(teca_curvilinear_mesh self) -> unsigned long"""
        return _teca_py.teca_curvilinear_mesh_get_number_of_points(self)

    def get_number_of_cells(self):
        r"""get_number_of_cells(teca_curvilinear_mesh self) -> unsigned long"""
        return _teca_py.teca_curvilinear_mesh_get_number_of_cells(self)

    def get_x_coordinates(self, *args):
        r"""
        get_x_coordinates(teca_curvilinear_mesh self) -> p_teca_variant_array
        get_x_coordinates(teca_curvilinear_mesh self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_curvilinear_mesh_get_x_coordinates(self, *args)

    def get_y_coordinates(self, *args):
        r"""
        get_y_coordinates(teca_curvilinear_mesh self) -> p_teca_variant_array
        get_y_coordinates(teca_curvilinear_mesh self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_curvilinear_mesh_get_y_coordinates(self, *args)

    def get_z_coordinates(self, *args):
        r"""
        get_z_coordinates(teca_curvilinear_mesh self) -> p_teca_variant_array
        get_z_coordinates(teca_curvilinear_mesh self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_curvilinear_mesh_get_z_coordinates(self, *args)

    def set_x_coordinates(self, name, array):
        r"""
        set_x_coordinates(teca_curvilinear_mesh self, std::string const & name, p_teca_variant_array const & array)

        Parameters
        ----------
        name: std::string const &
        array: p_teca_variant_array const &

        """
        return _teca_py.teca_curvilinear_mesh_set_x_coordinates(self, name, array)

    def set_y_coordinates(self, name, array):
        r"""
        set_y_coordinates(teca_curvilinear_mesh self, std::string const & name, p_teca_variant_array const & array)

        Parameters
        ----------
        name: std::string const &
        array: p_teca_variant_array const &

        """
        return _teca_py.teca_curvilinear_mesh_set_y_coordinates(self, name, array)

    def set_z_coordinates(self, name, array):
        r"""
        set_z_coordinates(teca_curvilinear_mesh self, std::string const & name, p_teca_variant_array const & array)

        Parameters
        ----------
        name: std::string const &
        array: p_teca_variant_array const &

        """
        return _teca_py.teca_curvilinear_mesh_set_z_coordinates(self, name, array)

    def copy(self, *args):
        r"""
        copy(teca_curvilinear_mesh self, const_p_teca_dataset const & other, teca_dataset::allocator alloc=allocator::malloc)

        Parameters
        ----------
        other: const_p_teca_dataset const &
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_curvilinear_mesh_copy(self, *args)

    def shallow_copy(self, other):
        r"""
        shallow_copy(teca_curvilinear_mesh self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_curvilinear_mesh_shallow_copy(self, other)

    def copy_metadata(self, other):
        r"""
        copy_metadata(teca_curvilinear_mesh self, const_p_teca_dataset const & other)

        Parameters
        ----------
        other: const_p_teca_dataset const &

        """
        return _teca_py.teca_curvilinear_mesh_copy_metadata(self, other)

    def swap(self, arg2):
        r"""
        swap(teca_curvilinear_mesh self, p_teca_dataset const & arg2)

        Parameters
        ----------
        arg2: p_teca_dataset const &

        """
        return _teca_py.teca_curvilinear_mesh_swap(self, arg2)

    def to_stream(self, *args):
        r"""
        to_stream(teca_curvilinear_mesh self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        to_stream(teca_curvilinear_mesh self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_curvilinear_mesh_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_curvilinear_mesh self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        from_stream(teca_curvilinear_mesh self, istream arg2) -> int

        Parameters
        ----------
        arg2: std::istream &

        """
        return _teca_py.teca_curvilinear_mesh_from_stream(self, *args)

    def __str__(self):
        r"""__str__(teca_curvilinear_mesh self) -> PyObject *"""
        return _teca_py.teca_curvilinear_mesh___str__(self)

    def get_extent(self, *args):
        r"""
        get_extent(teca_curvilinear_mesh self, std_vector_ulong vals) -> int

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > &

        get_extent(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_extent(teca_curvilinear_mesh self, unsigned long * vals) -> int

        Parameters
        ----------
        vals: unsigned long *

        get_extent(teca_curvilinear_mesh self) -> PyObject *
        """
        return _teca_py.teca_curvilinear_mesh_get_extent(self, *args)

    def set_extent(self, *args):
        r"""
        set_extent(teca_curvilinear_mesh self, std_vector_ulong vals)

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_extent(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_extent(teca_curvilinear_mesh self, std::initializer_list< unsigned long > const & l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &

        set_extent(teca_curvilinear_mesh self, unsigned long const * vals)

        Parameters
        ----------
        vals: unsigned long const *

        set_extent(teca_curvilinear_mesh self, unsigned long const & val_1, unsigned long const & val_2, unsigned long const & val_3, unsigned long const & val_4, unsigned long const & val_5, unsigned long const & val_6)

        Parameters
        ----------
        val_1: unsigned long const &
        val_2: unsigned long const &
        val_3: unsigned long const &
        val_4: unsigned long const &
        val_5: unsigned long const &
        val_6: unsigned long const &

        set_extent(teca_curvilinear_mesh self, PyObject * array) -> PyObject *

        Parameters
        ----------
        array: PyObject *

        """
        return _teca_py.teca_curvilinear_mesh_set_extent(self, *args)

    def get_whole_extent(self, *args):
        r"""
        get_whole_extent(teca_curvilinear_mesh self, std_vector_ulong vals) -> int

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > &

        get_whole_extent(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_whole_extent(teca_curvilinear_mesh self, unsigned long * vals) -> int

        Parameters
        ----------
        vals: unsigned long *

        get_whole_extent(teca_curvilinear_mesh self) -> PyObject *
        """
        return _teca_py.teca_curvilinear_mesh_get_whole_extent(self, *args)

    def set_whole_extent(self, *args):
        r"""
        set_whole_extent(teca_curvilinear_mesh self, std_vector_ulong vals)

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_whole_extent(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_whole_extent(teca_curvilinear_mesh self, std::initializer_list< unsigned long > const & l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &

        set_whole_extent(teca_curvilinear_mesh self, unsigned long const * vals)

        Parameters
        ----------
        vals: unsigned long const *

        set_whole_extent(teca_curvilinear_mesh self, unsigned long const & val_1, unsigned long const & val_2, unsigned long const & val_3, unsigned long const & val_4, unsigned long const & val_5, unsigned long const & val_6)

        Parameters
        ----------
        val_1: unsigned long const &
        val_2: unsigned long const &
        val_3: unsigned long const &
        val_4: unsigned long const &
        val_5: unsigned long const &
        val_6: unsigned long const &

        set_whole_extent(teca_curvilinear_mesh self, PyObject * array) -> PyObject *

        Parameters
        ----------
        array: PyObject *

        """
        return _teca_py.teca_curvilinear_mesh_set_whole_extent(self, *args)

    def set_periodic_in_x(self, *args):
        r"""
        set_periodic_in_x(teca_curvilinear_mesh self, std_vector_int vals)

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > const &

        set_periodic_in_x(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_periodic_in_x(teca_curvilinear_mesh self, std::initializer_list< int > const & l)

        Parameters
        ----------
        l: std::initializer_list< int > const &

        set_periodic_in_x(teca_curvilinear_mesh self, int const * vals)

        Parameters
        ----------
        vals: int const *

        set_periodic_in_x(teca_curvilinear_mesh self, int const & val_1)

        Parameters
        ----------
        val_1: int const &

        set_periodic_in_x(teca_curvilinear_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_curvilinear_mesh_set_periodic_in_x(self, *args)

    def get_periodic_in_x(self, *args):
        r"""
        get_periodic_in_x(teca_curvilinear_mesh self, std_vector_int vals) -> int

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > &

        get_periodic_in_x(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_periodic_in_x(teca_curvilinear_mesh self, int & val_1) -> int

        Parameters
        ----------
        val_1: int &

        get_periodic_in_x(teca_curvilinear_mesh self) -> PyObject *
        """
        return _teca_py.teca_curvilinear_mesh_get_periodic_in_x(self, *args)

    def set_periodic_in_y(self, *args):
        r"""
        set_periodic_in_y(teca_curvilinear_mesh self, std_vector_int vals)

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > const &

        set_periodic_in_y(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_periodic_in_y(teca_curvilinear_mesh self, std::initializer_list< int > const & l)

        Parameters
        ----------
        l: std::initializer_list< int > const &

        set_periodic_in_y(teca_curvilinear_mesh self, int const * vals)

        Parameters
        ----------
        vals: int const *

        set_periodic_in_y(teca_curvilinear_mesh self, int const & val_1)

        Parameters
        ----------
        val_1: int const &

        set_periodic_in_y(teca_curvilinear_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_curvilinear_mesh_set_periodic_in_y(self, *args)

    def get_periodic_in_y(self, *args):
        r"""
        get_periodic_in_y(teca_curvilinear_mesh self, std_vector_int vals) -> int

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > &

        get_periodic_in_y(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_periodic_in_y(teca_curvilinear_mesh self, int & val_1) -> int

        Parameters
        ----------
        val_1: int &

        get_periodic_in_y(teca_curvilinear_mesh self) -> PyObject *
        """
        return _teca_py.teca_curvilinear_mesh_get_periodic_in_y(self, *args)

    def set_periodic_in_z(self, *args):
        r"""
        set_periodic_in_z(teca_curvilinear_mesh self, std_vector_int vals)

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > const &

        set_periodic_in_z(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_periodic_in_z(teca_curvilinear_mesh self, std::initializer_list< int > const & l)

        Parameters
        ----------
        l: std::initializer_list< int > const &

        set_periodic_in_z(teca_curvilinear_mesh self, int const * vals)

        Parameters
        ----------
        vals: int const *

        set_periodic_in_z(teca_curvilinear_mesh self, int const & val_1)

        Parameters
        ----------
        val_1: int const &

        set_periodic_in_z(teca_curvilinear_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_curvilinear_mesh_set_periodic_in_z(self, *args)

    def get_periodic_in_z(self, *args):
        r"""
        get_periodic_in_z(teca_curvilinear_mesh self, std_vector_int vals) -> int

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > &

        get_periodic_in_z(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_periodic_in_z(teca_curvilinear_mesh self, int & val_1) -> int

        Parameters
        ----------
        val_1: int &

        get_periodic_in_z(teca_curvilinear_mesh self) -> PyObject *
        """
        return _teca_py.teca_curvilinear_mesh_get_periodic_in_z(self, *args)

    def set_x_coordinate_variable(self, *args):
        r"""
        set_x_coordinate_variable(teca_curvilinear_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_x_coordinate_variable(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_x_coordinate_variable(teca_curvilinear_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_x_coordinate_variable(teca_curvilinear_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_x_coordinate_variable(teca_curvilinear_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_curvilinear_mesh_set_x_coordinate_variable(self, *args)

    def get_x_coordinate_variable(self, *args):
        r"""
        get_x_coordinate_variable(teca_curvilinear_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_x_coordinate_variable(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_x_coordinate_variable(teca_curvilinear_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_x_coordinate_variable(teca_curvilinear_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_x_coordinate_variable(teca_curvilinear_mesh self) -> PyObject *
        """
        return _teca_py.teca_curvilinear_mesh_get_x_coordinate_variable(self, *args)

    def set_y_coordinate_variable(self, *args):
        r"""
        set_y_coordinate_variable(teca_curvilinear_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_y_coordinate_variable(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_y_coordinate_variable(teca_curvilinear_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_y_coordinate_variable(teca_curvilinear_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_y_coordinate_variable(teca_curvilinear_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_curvilinear_mesh_set_y_coordinate_variable(self, *args)

    def get_y_coordinate_variable(self, *args):
        r"""
        get_y_coordinate_variable(teca_curvilinear_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_y_coordinate_variable(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_y_coordinate_variable(teca_curvilinear_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_y_coordinate_variable(teca_curvilinear_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_y_coordinate_variable(teca_curvilinear_mesh self) -> PyObject *
        """
        return _teca_py.teca_curvilinear_mesh_get_y_coordinate_variable(self, *args)

    def set_z_coordinate_variable(self, *args):
        r"""
        set_z_coordinate_variable(teca_curvilinear_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_z_coordinate_variable(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_z_coordinate_variable(teca_curvilinear_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_z_coordinate_variable(teca_curvilinear_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_z_coordinate_variable(teca_curvilinear_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_curvilinear_mesh_set_z_coordinate_variable(self, *args)

    def get_z_coordinate_variable(self, *args):
        r"""
        get_z_coordinate_variable(teca_curvilinear_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_z_coordinate_variable(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_z_coordinate_variable(teca_curvilinear_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_z_coordinate_variable(teca_curvilinear_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_z_coordinate_variable(teca_curvilinear_mesh self) -> PyObject *
        """
        return _teca_py.teca_curvilinear_mesh_get_z_coordinate_variable(self, *args)

    def set_t_coordinate_variable(self, *args):
        r"""
        set_t_coordinate_variable(teca_curvilinear_mesh self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_t_coordinate_variable(teca_curvilinear_mesh self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_t_coordinate_variable(teca_curvilinear_mesh self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_t_coordinate_variable(teca_curvilinear_mesh self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_t_coordinate_variable(teca_curvilinear_mesh self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_curvilinear_mesh_set_t_coordinate_variable(self, *args)

    def get_t_coordinate_variable(self, *args):
        r"""
        get_t_coordinate_variable(teca_curvilinear_mesh self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_t_coordinate_variable(teca_curvilinear_mesh self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_t_coordinate_variable(teca_curvilinear_mesh self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_t_coordinate_variable(teca_curvilinear_mesh self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_t_coordinate_variable(teca_curvilinear_mesh self) -> PyObject *
        """
        return _teca_py.teca_curvilinear_mesh_get_t_coordinate_variable(self, *args)

# Register teca_curvilinear_mesh in _teca_py:
_teca_py.teca_curvilinear_mesh_swigregister(teca_curvilinear_mesh)

def teca_curvilinear_mesh_New():
    r"""teca_curvilinear_mesh_New() -> p_teca_curvilinear_mesh"""
    return _teca_py.teca_curvilinear_mesh_New()


def as_teca_curvilinear_mesh(in_inst):
    r"""
    as_teca_curvilinear_mesh(p_teca_dataset in_inst) -> p_teca_curvilinear_mesh

    Parameters
    ----------
    in_inst: p_teca_dataset

    """
    return _teca_py.as_teca_curvilinear_mesh(in_inst)

def as_const_teca_curvilinear_mesh(inst):
    r"""
    as_const_teca_curvilinear_mesh(const_p_teca_dataset inst) -> const_p_teca_curvilinear_mesh

    Parameters
    ----------
    inst: const_p_teca_dataset

    """
    return _teca_py.as_const_teca_curvilinear_mesh(inst)

def as_non_const_teca_curvilinear_mesh(in_inst):
    r"""
    as_non_const_teca_curvilinear_mesh(const_p_teca_curvilinear_mesh in_inst) -> p_teca_curvilinear_mesh

    Parameters
    ----------
    in_inst: const_p_teca_curvilinear_mesh

    """
    return _teca_py.as_non_const_teca_curvilinear_mesh(in_inst)
class teca_arakawa_c_grid(teca_mesh):
    r"""Proxy of C++ teca_arakawa_c_grid class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_arakawa_c_grid"""
        return _teca_py.teca_arakawa_c_grid_New()

    def new_instance(self):
        r"""new_instance(teca_arakawa_c_grid self) -> p_teca_dataset"""
        return _teca_py.teca_arakawa_c_grid_new_instance(self)

    def new_copy(self, *args):
        r"""
        new_copy(teca_arakawa_c_grid self, teca_dataset::allocator alloc=allocator::malloc) -> p_teca_dataset

        Parameters
        ----------
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_arakawa_c_grid_new_copy(self, *args)

    def new_shallow_copy(self):
        r"""new_shallow_copy(teca_arakawa_c_grid self) -> p_teca_dataset"""
        return _teca_py.teca_arakawa_c_grid_new_shallow_copy(self)
    __swig_destroy__ = _teca_py.delete_teca_arakawa_c_grid

    def get_bounds(self, *args):
        r"""
        get_bounds(teca_arakawa_c_grid self, std_vector_double vals) -> int

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > &

        get_bounds(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_bounds(teca_arakawa_c_grid self, double * vals) -> int

        Parameters
        ----------
        vals: double *

        """
        return _teca_py.teca_arakawa_c_grid_get_bounds(self, *args)

    def set_bounds(self, *args):
        r"""
        set_bounds(teca_arakawa_c_grid self, std_vector_double vals)

        Parameters
        ----------
        vals: std::vector< double,std::allocator< double > > const &

        set_bounds(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_bounds(teca_arakawa_c_grid self, std::initializer_list< double > const & l)

        Parameters
        ----------
        l: std::initializer_list< double > const &

        set_bounds(teca_arakawa_c_grid self, double const * vals)

        Parameters
        ----------
        vals: double const *

        set_bounds(teca_arakawa_c_grid self, double const & val_1, double const & val_2, double const & val_3, double const & val_4, double const & val_5, double const & val_6)

        Parameters
        ----------
        val_1: double const &
        val_2: double const &
        val_3: double const &
        val_4: double const &
        val_5: double const &
        val_6: double const &

        """
        return _teca_py.teca_arakawa_c_grid_set_bounds(self, *args)

    def get_number_of_points(self):
        r"""get_number_of_points(teca_arakawa_c_grid self) -> unsigned long"""
        return _teca_py.teca_arakawa_c_grid_get_number_of_points(self)

    def get_number_of_cells(self):
        r"""get_number_of_cells(teca_arakawa_c_grid self) -> unsigned long"""
        return _teca_py.teca_arakawa_c_grid_get_number_of_cells(self)

    def get_m_x_coordinates(self, *args):
        r"""
        get_m_x_coordinates(teca_arakawa_c_grid self) -> p_teca_variant_array
        get_m_x_coordinates(teca_arakawa_c_grid self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_arakawa_c_grid_get_m_x_coordinates(self, *args)

    def get_m_y_coordinates(self, *args):
        r"""
        get_m_y_coordinates(teca_arakawa_c_grid self) -> p_teca_variant_array
        get_m_y_coordinates(teca_arakawa_c_grid self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_arakawa_c_grid_get_m_y_coordinates(self, *args)

    def get_u_x_coordinates(self, *args):
        r"""
        get_u_x_coordinates(teca_arakawa_c_grid self) -> p_teca_variant_array
        get_u_x_coordinates(teca_arakawa_c_grid self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_arakawa_c_grid_get_u_x_coordinates(self, *args)

    def get_u_y_coordinates(self, *args):
        r"""
        get_u_y_coordinates(teca_arakawa_c_grid self) -> p_teca_variant_array
        get_u_y_coordinates(teca_arakawa_c_grid self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_arakawa_c_grid_get_u_y_coordinates(self, *args)

    def get_v_x_coordinates(self, *args):
        r"""
        get_v_x_coordinates(teca_arakawa_c_grid self) -> p_teca_variant_array
        get_v_x_coordinates(teca_arakawa_c_grid self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_arakawa_c_grid_get_v_x_coordinates(self, *args)

    def get_v_y_coordinates(self, *args):
        r"""
        get_v_y_coordinates(teca_arakawa_c_grid self) -> p_teca_variant_array
        get_v_y_coordinates(teca_arakawa_c_grid self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_arakawa_c_grid_get_v_y_coordinates(self, *args)

    def get_m_z_coordinates(self, *args):
        r"""
        get_m_z_coordinates(teca_arakawa_c_grid self) -> p_teca_variant_array
        get_m_z_coordinates(teca_arakawa_c_grid self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_arakawa_c_grid_get_m_z_coordinates(self, *args)

    def get_w_z_coordinates(self, *args):
        r"""
        get_w_z_coordinates(teca_arakawa_c_grid self) -> p_teca_variant_array
        get_w_z_coordinates(teca_arakawa_c_grid self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_arakawa_c_grid_get_w_z_coordinates(self, *args)

    def get_t_coordinates(self, *args):
        r"""
        get_t_coordinates(teca_arakawa_c_grid self) -> p_teca_variant_array
        get_t_coordinates(teca_arakawa_c_grid self) -> const_p_teca_variant_array
        """
        return _teca_py.teca_arakawa_c_grid_get_t_coordinates(self, *args)

    def set_m_x_coordinates(self, name, a):
        r"""
        set_m_x_coordinates(teca_arakawa_c_grid self, std::string const & name, p_teca_variant_array const & a)

        Parameters
        ----------
        name: std::string const &
        a: p_teca_variant_array const &

        """
        return _teca_py.teca_arakawa_c_grid_set_m_x_coordinates(self, name, a)

    def set_m_y_coordinates(self, name, a):
        r"""
        set_m_y_coordinates(teca_arakawa_c_grid self, std::string const & name, p_teca_variant_array const & a)

        Parameters
        ----------
        name: std::string const &
        a: p_teca_variant_array const &

        """
        return _teca_py.teca_arakawa_c_grid_set_m_y_coordinates(self, name, a)

    def set_u_x_coordinates(self, name, a):
        r"""
        set_u_x_coordinates(teca_arakawa_c_grid self, std::string const & name, p_teca_variant_array const & a)

        Parameters
        ----------
        name: std::string const &
        a: p_teca_variant_array const &

        """
        return _teca_py.teca_arakawa_c_grid_set_u_x_coordinates(self, name, a)

    def set_u_y_coordinates(self, name, a):
        r"""
        set_u_y_coordinates(teca_arakawa_c_grid self, std::string const & name, p_teca_variant_array const & a)

        Parameters
        ----------
        name: std::string const &
        a: p_teca_variant_array const &

        """
        return _teca_py.teca_arakawa_c_grid_set_u_y_coordinates(self, name, a)

    def set_v_x_coordinates(self, name, a):
        r"""
        set_v_x_coordinates(teca_arakawa_c_grid self, std::string const & name, p_teca_variant_array const & a)

        Parameters
        ----------
        name: std::string const &
        a: p_teca_variant_array const &

        """
        return _teca_py.teca_arakawa_c_grid_set_v_x_coordinates(self, name, a)

    def set_v_y_coordinates(self, name, a):
        r"""
        set_v_y_coordinates(teca_arakawa_c_grid self, std::string const & name, p_teca_variant_array const & a)

        Parameters
        ----------
        name: std::string const &
        a: p_teca_variant_array const &

        """
        return _teca_py.teca_arakawa_c_grid_set_v_y_coordinates(self, name, a)

    def set_m_z_coordinates(self, name, a):
        r"""
        set_m_z_coordinates(teca_arakawa_c_grid self, std::string const & name, p_teca_variant_array const & a)

        Parameters
        ----------
        name: std::string const &
        a: p_teca_variant_array const &

        """
        return _teca_py.teca_arakawa_c_grid_set_m_z_coordinates(self, name, a)

    def set_w_z_coordinates(self, name, a):
        r"""
        set_w_z_coordinates(teca_arakawa_c_grid self, std::string const & name, p_teca_variant_array const & a)

        Parameters
        ----------
        name: std::string const &
        a: p_teca_variant_array const &

        """
        return _teca_py.teca_arakawa_c_grid_set_w_z_coordinates(self, name, a)

    def set_t_coordinates(self, name, a):
        r"""
        set_t_coordinates(teca_arakawa_c_grid self, std::string const & name, p_teca_variant_array const & a)

        Parameters
        ----------
        name: std::string const &
        a: p_teca_variant_array const &

        """
        return _teca_py.teca_arakawa_c_grid_set_t_coordinates(self, name, a)

    def get_class_name(self):
        r"""get_class_name(teca_arakawa_c_grid self) -> std::string"""
        return _teca_py.teca_arakawa_c_grid_get_class_name(self)

    def get_type_code(self):
        r"""get_type_code(teca_arakawa_c_grid self) -> int"""
        return _teca_py.teca_arakawa_c_grid_get_type_code(self)

    def copy(self, *args):
        r"""
        copy(teca_arakawa_c_grid self, const_p_teca_dataset const & other, teca_dataset::allocator alloc=allocator::malloc)

        Parameters
        ----------
        other: const_p_teca_dataset const &
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_arakawa_c_grid_copy(self, *args)

    def shallow_copy(self, other):
        r"""
        shallow_copy(teca_arakawa_c_grid self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_arakawa_c_grid_shallow_copy(self, other)

    def copy_metadata(self, other):
        r"""
        copy_metadata(teca_arakawa_c_grid self, const_p_teca_dataset const & other)

        Parameters
        ----------
        other: const_p_teca_dataset const &

        """
        return _teca_py.teca_arakawa_c_grid_copy_metadata(self, other)

    def swap(self, arg2):
        r"""
        swap(teca_arakawa_c_grid self, p_teca_dataset const & arg2)

        Parameters
        ----------
        arg2: p_teca_dataset const &

        """
        return _teca_py.teca_arakawa_c_grid_swap(self, arg2)

    def empty(self):
        r"""empty(teca_arakawa_c_grid self) -> bool"""
        return _teca_py.teca_arakawa_c_grid_empty(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_arakawa_c_grid self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        to_stream(teca_arakawa_c_grid self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_arakawa_c_grid_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_arakawa_c_grid self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        from_stream(teca_arakawa_c_grid self, istream arg2) -> int

        Parameters
        ----------
        arg2: std::istream &

        """
        return _teca_py.teca_arakawa_c_grid_from_stream(self, *args)

    def __str__(self):
        r"""__str__(teca_arakawa_c_grid self) -> PyObject *"""
        return _teca_py.teca_arakawa_c_grid___str__(self)

    def get_extent(self, *args):
        r"""
        get_extent(teca_arakawa_c_grid self, std_vector_ulong vals) -> int

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > &

        get_extent(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_extent(teca_arakawa_c_grid self, unsigned long * vals) -> int

        Parameters
        ----------
        vals: unsigned long *

        get_extent(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_extent(self, *args)

    def set_extent(self, *args):
        r"""
        set_extent(teca_arakawa_c_grid self, std_vector_ulong vals)

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_extent(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_extent(teca_arakawa_c_grid self, std::initializer_list< unsigned long > const & l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &

        set_extent(teca_arakawa_c_grid self, unsigned long const * vals)

        Parameters
        ----------
        vals: unsigned long const *

        set_extent(teca_arakawa_c_grid self, unsigned long const & val_1, unsigned long const & val_2, unsigned long const & val_3, unsigned long const & val_4, unsigned long const & val_5, unsigned long const & val_6)

        Parameters
        ----------
        val_1: unsigned long const &
        val_2: unsigned long const &
        val_3: unsigned long const &
        val_4: unsigned long const &
        val_5: unsigned long const &
        val_6: unsigned long const &

        set_extent(teca_arakawa_c_grid self, PyObject * array) -> PyObject *

        Parameters
        ----------
        array: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_extent(self, *args)

    def get_whole_extent(self, *args):
        r"""
        get_whole_extent(teca_arakawa_c_grid self, std_vector_ulong vals) -> int

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > &

        get_whole_extent(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_whole_extent(teca_arakawa_c_grid self, unsigned long * vals) -> int

        Parameters
        ----------
        vals: unsigned long *

        get_whole_extent(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_whole_extent(self, *args)

    def set_whole_extent(self, *args):
        r"""
        set_whole_extent(teca_arakawa_c_grid self, std_vector_ulong vals)

        Parameters
        ----------
        vals: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_whole_extent(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_whole_extent(teca_arakawa_c_grid self, std::initializer_list< unsigned long > const & l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &

        set_whole_extent(teca_arakawa_c_grid self, unsigned long const * vals)

        Parameters
        ----------
        vals: unsigned long const *

        set_whole_extent(teca_arakawa_c_grid self, unsigned long const & val_1, unsigned long const & val_2, unsigned long const & val_3, unsigned long const & val_4, unsigned long const & val_5, unsigned long const & val_6)

        Parameters
        ----------
        val_1: unsigned long const &
        val_2: unsigned long const &
        val_3: unsigned long const &
        val_4: unsigned long const &
        val_5: unsigned long const &
        val_6: unsigned long const &

        set_whole_extent(teca_arakawa_c_grid self, PyObject * array) -> PyObject *

        Parameters
        ----------
        array: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_whole_extent(self, *args)

    def set_periodic_in_x(self, *args):
        r"""
        set_periodic_in_x(teca_arakawa_c_grid self, std_vector_int vals)

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > const &

        set_periodic_in_x(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_periodic_in_x(teca_arakawa_c_grid self, std::initializer_list< int > const & l)

        Parameters
        ----------
        l: std::initializer_list< int > const &

        set_periodic_in_x(teca_arakawa_c_grid self, int const * vals)

        Parameters
        ----------
        vals: int const *

        set_periodic_in_x(teca_arakawa_c_grid self, int const & val_1)

        Parameters
        ----------
        val_1: int const &

        set_periodic_in_x(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_periodic_in_x(self, *args)

    def get_periodic_in_x(self, *args):
        r"""
        get_periodic_in_x(teca_arakawa_c_grid self, std_vector_int vals) -> int

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > &

        get_periodic_in_x(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_periodic_in_x(teca_arakawa_c_grid self, int & val_1) -> int

        Parameters
        ----------
        val_1: int &

        get_periodic_in_x(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_periodic_in_x(self, *args)

    def set_periodic_in_y(self, *args):
        r"""
        set_periodic_in_y(teca_arakawa_c_grid self, std_vector_int vals)

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > const &

        set_periodic_in_y(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_periodic_in_y(teca_arakawa_c_grid self, std::initializer_list< int > const & l)

        Parameters
        ----------
        l: std::initializer_list< int > const &

        set_periodic_in_y(teca_arakawa_c_grid self, int const * vals)

        Parameters
        ----------
        vals: int const *

        set_periodic_in_y(teca_arakawa_c_grid self, int const & val_1)

        Parameters
        ----------
        val_1: int const &

        set_periodic_in_y(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_periodic_in_y(self, *args)

    def get_periodic_in_y(self, *args):
        r"""
        get_periodic_in_y(teca_arakawa_c_grid self, std_vector_int vals) -> int

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > &

        get_periodic_in_y(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_periodic_in_y(teca_arakawa_c_grid self, int & val_1) -> int

        Parameters
        ----------
        val_1: int &

        get_periodic_in_y(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_periodic_in_y(self, *args)

    def set_periodic_in_z(self, *args):
        r"""
        set_periodic_in_z(teca_arakawa_c_grid self, std_vector_int vals)

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > const &

        set_periodic_in_z(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_periodic_in_z(teca_arakawa_c_grid self, std::initializer_list< int > const & l)

        Parameters
        ----------
        l: std::initializer_list< int > const &

        set_periodic_in_z(teca_arakawa_c_grid self, int const * vals)

        Parameters
        ----------
        vals: int const *

        set_periodic_in_z(teca_arakawa_c_grid self, int const & val_1)

        Parameters
        ----------
        val_1: int const &

        set_periodic_in_z(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_periodic_in_z(self, *args)

    def get_periodic_in_z(self, *args):
        r"""
        get_periodic_in_z(teca_arakawa_c_grid self, std_vector_int vals) -> int

        Parameters
        ----------
        vals: std::vector< int,std::allocator< int > > &

        get_periodic_in_z(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_periodic_in_z(teca_arakawa_c_grid self, int & val_1) -> int

        Parameters
        ----------
        val_1: int &

        get_periodic_in_z(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_periodic_in_z(self, *args)

    def set_m_x_coordinate_variable(self, *args):
        r"""
        set_m_x_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_m_x_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_m_x_coordinate_variable(teca_arakawa_c_grid self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_m_x_coordinate_variable(teca_arakawa_c_grid self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_m_x_coordinate_variable(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_m_x_coordinate_variable(self, *args)

    def get_m_x_coordinate_variable(self, *args):
        r"""
        get_m_x_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_m_x_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_m_x_coordinate_variable(teca_arakawa_c_grid self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_m_x_coordinate_variable(teca_arakawa_c_grid self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_m_x_coordinate_variable(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_m_x_coordinate_variable(self, *args)

    def set_m_y_coordinate_variable(self, *args):
        r"""
        set_m_y_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_m_y_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_m_y_coordinate_variable(teca_arakawa_c_grid self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_m_y_coordinate_variable(teca_arakawa_c_grid self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_m_y_coordinate_variable(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_m_y_coordinate_variable(self, *args)

    def get_m_y_coordinate_variable(self, *args):
        r"""
        get_m_y_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_m_y_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_m_y_coordinate_variable(teca_arakawa_c_grid self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_m_y_coordinate_variable(teca_arakawa_c_grid self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_m_y_coordinate_variable(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_m_y_coordinate_variable(self, *args)

    def set_u_x_coordinate_variable(self, *args):
        r"""
        set_u_x_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_u_x_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_u_x_coordinate_variable(teca_arakawa_c_grid self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_u_x_coordinate_variable(teca_arakawa_c_grid self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_u_x_coordinate_variable(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_u_x_coordinate_variable(self, *args)

    def get_u_x_coordinate_variable(self, *args):
        r"""
        get_u_x_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_u_x_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_u_x_coordinate_variable(teca_arakawa_c_grid self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_u_x_coordinate_variable(teca_arakawa_c_grid self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_u_x_coordinate_variable(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_u_x_coordinate_variable(self, *args)

    def set_u_y_coordinate_variable(self, *args):
        r"""
        set_u_y_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_u_y_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_u_y_coordinate_variable(teca_arakawa_c_grid self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_u_y_coordinate_variable(teca_arakawa_c_grid self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_u_y_coordinate_variable(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_u_y_coordinate_variable(self, *args)

    def get_u_y_coordinate_variable(self, *args):
        r"""
        get_u_y_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_u_y_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_u_y_coordinate_variable(teca_arakawa_c_grid self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_u_y_coordinate_variable(teca_arakawa_c_grid self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_u_y_coordinate_variable(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_u_y_coordinate_variable(self, *args)

    def set_v_x_coordinate_variable(self, *args):
        r"""
        set_v_x_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_v_x_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_v_x_coordinate_variable(teca_arakawa_c_grid self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_v_x_coordinate_variable(teca_arakawa_c_grid self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_v_x_coordinate_variable(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_v_x_coordinate_variable(self, *args)

    def get_v_x_coordinate_variable(self, *args):
        r"""
        get_v_x_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_v_x_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_v_x_coordinate_variable(teca_arakawa_c_grid self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_v_x_coordinate_variable(teca_arakawa_c_grid self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_v_x_coordinate_variable(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_v_x_coordinate_variable(self, *args)

    def set_v_y_coordinate_variable(self, *args):
        r"""
        set_v_y_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_v_y_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_v_y_coordinate_variable(teca_arakawa_c_grid self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_v_y_coordinate_variable(teca_arakawa_c_grid self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_v_y_coordinate_variable(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_v_y_coordinate_variable(self, *args)

    def get_v_y_coordinate_variable(self, *args):
        r"""
        get_v_y_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_v_y_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_v_y_coordinate_variable(teca_arakawa_c_grid self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_v_y_coordinate_variable(teca_arakawa_c_grid self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_v_y_coordinate_variable(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_v_y_coordinate_variable(self, *args)

    def set_m_z_coordinate_variable(self, *args):
        r"""
        set_m_z_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_m_z_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_m_z_coordinate_variable(teca_arakawa_c_grid self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_m_z_coordinate_variable(teca_arakawa_c_grid self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_m_z_coordinate_variable(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_m_z_coordinate_variable(self, *args)

    def get_m_z_coordinate_variable(self, *args):
        r"""
        get_m_z_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_m_z_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_m_z_coordinate_variable(teca_arakawa_c_grid self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_m_z_coordinate_variable(teca_arakawa_c_grid self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_m_z_coordinate_variable(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_m_z_coordinate_variable(self, *args)

    def set_w_z_coordinate_variable(self, *args):
        r"""
        set_w_z_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_w_z_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_w_z_coordinate_variable(teca_arakawa_c_grid self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_w_z_coordinate_variable(teca_arakawa_c_grid self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_w_z_coordinate_variable(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_w_z_coordinate_variable(self, *args)

    def get_w_z_coordinate_variable(self, *args):
        r"""
        get_w_z_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_w_z_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_w_z_coordinate_variable(teca_arakawa_c_grid self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_w_z_coordinate_variable(teca_arakawa_c_grid self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_w_z_coordinate_variable(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_w_z_coordinate_variable(self, *args)

    def set_t_coordinate_variable(self, *args):
        r"""
        set_t_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_t_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_t_coordinate_variable(teca_arakawa_c_grid self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_t_coordinate_variable(teca_arakawa_c_grid self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_t_coordinate_variable(teca_arakawa_c_grid self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_arakawa_c_grid_set_t_coordinate_variable(self, *args)

    def get_t_coordinate_variable(self, *args):
        r"""
        get_t_coordinate_variable(teca_arakawa_c_grid self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_t_coordinate_variable(teca_arakawa_c_grid self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_t_coordinate_variable(teca_arakawa_c_grid self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_t_coordinate_variable(teca_arakawa_c_grid self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_t_coordinate_variable(teca_arakawa_c_grid self) -> PyObject *
        """
        return _teca_py.teca_arakawa_c_grid_get_t_coordinate_variable(self, *args)

# Register teca_arakawa_c_grid in _teca_py:
_teca_py.teca_arakawa_c_grid_swigregister(teca_arakawa_c_grid)

def teca_arakawa_c_grid_New():
    r"""teca_arakawa_c_grid_New() -> p_teca_arakawa_c_grid"""
    return _teca_py.teca_arakawa_c_grid_New()


def as_teca_arakawa_c_grid(in_inst):
    r"""
    as_teca_arakawa_c_grid(p_teca_dataset in_inst) -> p_teca_arakawa_c_grid

    Parameters
    ----------
    in_inst: p_teca_dataset

    """
    return _teca_py.as_teca_arakawa_c_grid(in_inst)

def as_const_teca_arakawa_c_grid(inst):
    r"""
    as_const_teca_arakawa_c_grid(const_p_teca_dataset inst) -> const_p_teca_arakawa_c_grid

    Parameters
    ----------
    inst: const_p_teca_dataset

    """
    return _teca_py.as_const_teca_arakawa_c_grid(inst)

def as_non_const_teca_arakawa_c_grid(in_inst):
    r"""
    as_non_const_teca_arakawa_c_grid(const_p_teca_arakawa_c_grid in_inst) -> p_teca_arakawa_c_grid

    Parameters
    ----------
    in_inst: const_p_teca_arakawa_c_grid

    """
    return _teca_py.as_non_const_teca_arakawa_c_grid(in_inst)
class teca_table(teca_dataset):
    r"""Proxy of C++ teca_table class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table"""
        return _teca_py.teca_table_New()

    def new_instance(self):
        r"""new_instance(teca_table self) -> p_teca_dataset"""
        return _teca_py.teca_table_new_instance(self)

    def new_copy(self, *args):
        r"""
        new_copy(teca_table self, teca_dataset::allocator alloc=allocator::malloc) -> p_teca_dataset

        Parameters
        ----------
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_table_new_copy(self, *args)

    def new_shallow_copy(self):
        r"""new_shallow_copy(teca_table self) -> p_teca_dataset"""
        return _teca_py.teca_table_new_shallow_copy(self)
    __swig_destroy__ = _teca_py.delete_teca_table

    def clear(self):
        r"""clear(teca_table self)"""
        return _teca_py.teca_table_clear(self)

    def set_default_allocator(self, alloc):
        r"""
        set_default_allocator(teca_table self, teca_dataset::allocator alloc)

        Parameters
        ----------
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_table_set_default_allocator(self, alloc)

    def get_number_of_columns(self):
        r"""get_number_of_columns(teca_table self) -> unsigned int"""
        return _teca_py.teca_table_get_number_of_columns(self)

    def get_number_of_rows(self):
        r"""get_number_of_rows(teca_table self) -> unsigned long"""
        return _teca_py.teca_table_get_number_of_rows(self)

    def get_column(self, *args):
        r"""
        get_column(teca_table self, unsigned int i) -> p_teca_variant_array

        Parameters
        ----------
        i: unsigned int

        get_column(teca_table self, std::string const & col_name) -> p_teca_variant_array

        Parameters
        ----------
        col_name: std::string const &

        get_column(teca_table self, unsigned int i) -> const_p_teca_variant_array

        Parameters
        ----------
        i: unsigned int

        get_column(teca_table self, std::string const & col_name) -> const_p_teca_variant_array

        Parameters
        ----------
        col_name: std::string const &

        """
        return _teca_py.teca_table_get_column(self, *args)

    def has_column(self, col_name):
        r"""
        has_column(teca_table self, std::string const & col_name) -> bool

        Parameters
        ----------
        col_name: std::string const &

        """
        return _teca_py.teca_table_has_column(self, col_name)

    def get_column_name(self, i):
        r"""
        get_column_name(teca_table self, unsigned int i) -> std::string

        Parameters
        ----------
        i: unsigned int

        """
        return _teca_py.teca_table_get_column_name(self, i)

    def append_column(self, *args):
        r"""
        append_column(teca_table self, p_teca_variant_array array) -> int

        Parameters
        ----------
        array: p_teca_variant_array

        append_column(teca_table self, std::string const & name, p_teca_variant_array array) -> int

        Parameters
        ----------
        name: std::string const &
        array: p_teca_variant_array

        """
        return _teca_py.teca_table_append_column(self, *args)

    def remove_column(self, *args):
        r"""
        remove_column(teca_table self, unsigned int i) -> int

        Parameters
        ----------
        i: unsigned int

        remove_column(teca_table self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_table_remove_column(self, *args)

    def get_columns(self, *args):
        r"""
        get_columns(teca_table self) -> p_teca_array_collection
        get_columns(teca_table self) -> const_p_teca_array_collection
        """
        return _teca_py.teca_table_get_columns(self, *args)

    def resize(self, n):
        r"""
        resize(teca_table self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_table_resize(self, n)

    def reserve(self, n):
        r"""
        reserve(teca_table self, unsigned long n)

        Parameters
        ----------
        n: unsigned long

        """
        return _teca_py.teca_table_reserve(self, n)

    def get_class_name(self):
        r"""get_class_name(teca_table self) -> std::string"""
        return _teca_py.teca_table_get_class_name(self)

    def get_type_code(self):
        r"""get_type_code(teca_table self) -> int"""
        return _teca_py.teca_table_get_type_code(self)

    def __nonzero__(self):
        return _teca_py.teca_table___nonzero__(self)
    __bool__ = __nonzero__



    def empty(self):
        r"""empty(teca_table self) -> bool"""
        return _teca_py.teca_table_empty(self)

    def to_stream(self, *args):
        r"""
        to_stream(teca_table self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        to_stream(teca_table self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_table_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_table self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        from_stream(teca_table self, istream arg2) -> int

        Parameters
        ----------
        arg2: std::istream &

        """
        return _teca_py.teca_table_from_stream(self, *args)

    def copy(self, *args):
        r"""
        copy(teca_table self, const_p_teca_dataset const & other, teca_dataset::allocator alloc=allocator::malloc)

        Parameters
        ----------
        other: const_p_teca_dataset const &
        alloc: enum teca_dataset::allocator

        copy(teca_table self, const_p_teca_table const & other, unsigned long first_row, unsigned long last_row, teca_dataset::allocator alloc=allocator::malloc)

        Parameters
        ----------
        other: const_p_teca_table const &
        first_row: unsigned long
        last_row: unsigned long
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_table_copy(self, *args)

    def shallow_copy(self, other):
        r"""
        shallow_copy(teca_table self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_table_shallow_copy(self, other)

    def copy_structure(self, other):
        r"""
        copy_structure(teca_table self, const_p_teca_table const & other)

        Parameters
        ----------
        other: const_p_teca_table const &

        """
        return _teca_py.teca_table_copy_structure(self, other)

    def swap(self, other):
        r"""
        swap(teca_table self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_table_swap(self, other)

    def concatenate_rows(self, other):
        r"""
        concatenate_rows(teca_table self, const_p_teca_table const & other)

        Parameters
        ----------
        other: const_p_teca_table const &

        """
        return _teca_py.teca_table_concatenate_rows(self, other)

    def concatenate_cols(self, other, deep=False):
        r"""
        concatenate_cols(teca_table self, const_p_teca_table const & other, bool deep=False)

        Parameters
        ----------
        other: const_p_teca_table const &
        deep: bool

        """
        return _teca_py.teca_table_concatenate_cols(self, other, deep)

    def __str__(self):
        r"""__str__(teca_table self) -> PyObject *"""
        return _teca_py.teca_table___str__(self)

    def set_calendar(self, *args):
        r"""
        set_calendar(teca_table self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_calendar(teca_table self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_calendar(teca_table self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_calendar(teca_table self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_calendar(teca_table self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_table_set_calendar(self, *args)

    def get_calendar(self, *args):
        r"""
        get_calendar(teca_table self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_calendar(teca_table self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_calendar(teca_table self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_calendar(teca_table self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_calendar(teca_table self) -> PyObject *
        """
        return _teca_py.teca_table_get_calendar(self, *args)

    def set_time_units(self, *args):
        r"""
        set_time_units(teca_table self, std_vector_string vals)

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > const &

        set_time_units(teca_table self, p_teca_variant_array const & vals)

        Parameters
        ----------
        vals: p_teca_variant_array const &

        set_time_units(teca_table self, std::initializer_list< std::string > const & l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &

        set_time_units(teca_table self, std::string const & val_1)

        Parameters
        ----------
        val_1: std::string const &

        set_time_units(teca_table self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_table_set_time_units(self, *args)

    def get_time_units(self, *args):
        r"""
        get_time_units(teca_table self, std_vector_string vals) -> int

        Parameters
        ----------
        vals: std::vector< std::string,std::allocator< std::string > > &

        get_time_units(teca_table self, p_teca_variant_array vals) -> int

        Parameters
        ----------
        vals: p_teca_variant_array

        get_time_units(teca_table self, std::string * vals) -> int

        Parameters
        ----------
        vals: std::string *

        get_time_units(teca_table self, std::string & val_1) -> int

        Parameters
        ----------
        val_1: std::string &

        get_time_units(teca_table self) -> PyObject *
        """
        return _teca_py.teca_table_get_time_units(self, *args)

    def __setitem__(self, idx, obj):
        r"""
        __setitem__(teca_table self, PyObject * idx, PyObject * obj) -> PyObject *

        Parameters
        ----------
        idx: PyObject *
        obj: PyObject *

        """
        return _teca_py.teca_table___setitem__(self, idx, obj)

    def __getitem__(self, idx):
        r"""
        __getitem__(teca_table self, PyObject * idx) -> PyObject *

        Parameters
        ----------
        idx: PyObject *

        """
        return _teca_py.teca_table___getitem__(self, idx)

    def set_column(self, id, array):
        r"""
        set_column(teca_table self, PyObject * id, PyObject * array) -> PyObject *

        Parameters
        ----------
        id: PyObject *
        array: PyObject *

        """
        return _teca_py.teca_table_set_column(self, id, array)

    def declare_column(self, name, type):
        r"""
        declare_column(teca_table self, char const * name, char const * type) -> PyObject *

        Parameters
        ----------
        name: char const *
        type: char const *

        """
        return _teca_py.teca_table_declare_column(self, name, type)

    def declare_columns(self, names, types):
        r"""
        declare_columns(teca_table self, PyObject * names, PyObject * types) -> PyObject *

        Parameters
        ----------
        names: PyObject *
        types: PyObject *

        """
        return _teca_py.teca_table_declare_columns(self, names, types)

    def append(self, obj):
        r"""
        append(teca_table self, PyObject * obj) -> PyObject *

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_table_append(self, obj)

    def __lshift__(self, obj):
        r"""
        __lshift__(teca_table self, PyObject * obj) -> p_teca_table

        Parameters
        ----------
        obj: PyObject *

        """
        return _teca_py.teca_table___lshift__(self, obj)

# Register teca_table in _teca_py:
_teca_py.teca_table_swigregister(teca_table)

def teca_table_New():
    r"""teca_table_New() -> p_teca_table"""
    return _teca_py.teca_table_New()


def as_teca_table(in_inst):
    r"""
    as_teca_table(p_teca_dataset in_inst) -> p_teca_table

    Parameters
    ----------
    in_inst: p_teca_dataset

    """
    return _teca_py.as_teca_table(in_inst)

def as_const_teca_table(inst):
    r"""
    as_const_teca_table(const_p_teca_dataset inst) -> const_p_teca_table

    Parameters
    ----------
    inst: const_p_teca_dataset

    """
    return _teca_py.as_const_teca_table(inst)

def as_non_const_teca_table(in_inst):
    r"""
    as_non_const_teca_table(const_p_teca_table in_inst) -> p_teca_table

    Parameters
    ----------
    in_inst: const_p_teca_table

    """
    return _teca_py.as_non_const_teca_table(in_inst)
class teca_table_collection(object):
    r"""Proxy of C++ teca_table_collection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table_collection"""
        return _teca_py.teca_table_collection_New()

    def clear(self):
        r"""clear(teca_table_collection self)"""
        return _teca_py.teca_table_collection_clear(self)

    def append(self, *args):
        r"""
        append(teca_table_collection self, p_teca_table array) -> int

        Parameters
        ----------
        array: p_teca_table

        append(teca_table_collection self, std::string const & name, p_teca_table array) -> int

        Parameters
        ----------
        name: std::string const &
        array: p_teca_table

        """
        return _teca_py.teca_table_collection_append(self, *args)

    def set(self, *args):
        r"""
        set(teca_table_collection self, unsigned int i, p_teca_table array) -> int

        Parameters
        ----------
        i: unsigned int
        array: p_teca_table

        set(teca_table_collection self, std::string const & name, p_teca_table array) -> int

        Parameters
        ----------
        name: std::string const &
        array: p_teca_table

        """
        return _teca_py.teca_table_collection_set(self, *args)

    def remove(self, *args):
        r"""
        remove(teca_table_collection self, unsigned int i) -> int

        Parameters
        ----------
        i: unsigned int

        remove(teca_table_collection self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_table_collection_remove(self, *args)

    def size(self):
        r"""size(teca_table_collection self) -> unsigned int"""
        return _teca_py.teca_table_collection_size(self)

    def has(self, name):
        r"""
        has(teca_table_collection self, std::string const & name) -> bool

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_table_collection_has(self, name)

    def get(self, *args):
        r"""
        get(teca_table_collection self, unsigned int i) -> p_teca_table

        Parameters
        ----------
        i: unsigned int

        get(teca_table_collection self, unsigned int i) -> const_p_teca_table

        Parameters
        ----------
        i: unsigned int

        get(teca_table_collection self, std::string const & name) -> p_teca_table

        Parameters
        ----------
        name: std::string const &

        get(teca_table_collection self, std::string const & name) -> const_p_teca_table

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_table_collection_get(self, *args)

    def get_name(self, *args):
        r"""
        get_name(teca_table_collection self, unsigned int i) -> std::string

        Parameters
        ----------
        i: unsigned int

        get_name(teca_table_collection self, unsigned int i) -> std::string const &

        Parameters
        ----------
        i: unsigned int

        """
        return _teca_py.teca_table_collection_get_name(self, *args)

    def get_class_name(self):
        r"""get_class_name(teca_table_collection self) -> std::string"""
        return _teca_py.teca_table_collection_get_class_name(self)

    def get_type_code(self):
        r"""get_type_code(teca_table_collection self) -> int"""
        return _teca_py.teca_table_collection_get_type_code(self)

    def copy(self, *args):
        r"""
        copy(teca_table_collection self, const_p_teca_table_collection const & other, teca_table_collection::allocator alloc=malloc)

        Parameters
        ----------
        other: const_p_teca_table_collection const &
        alloc: enum teca_table_collection::allocator

        """
        return _teca_py.teca_table_collection_copy(self, *args)

    def shallow_copy(self, other):
        r"""
        shallow_copy(teca_table_collection self, p_teca_table_collection const & other)

        Parameters
        ----------
        other: p_teca_table_collection const &

        """
        return _teca_py.teca_table_collection_shallow_copy(self, other)

    def swap(self, other):
        r"""
        swap(teca_table_collection self, p_teca_table_collection & other)

        Parameters
        ----------
        other: p_teca_table_collection &

        """
        return _teca_py.teca_table_collection_swap(self, other)

    def to_stream(self, *args):
        r"""
        to_stream(teca_table_collection self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        to_stream(teca_table_collection self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_table_collection_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_table_collection self, teca_binary_stream s) -> int

        Parameters
        ----------
        s: teca_binary_stream &

        from_stream(teca_table_collection self, istream arg2) -> int

        Parameters
        ----------
        arg2: std::istream &

        """
        return _teca_py.teca_table_collection_from_stream(self, *args)

    def __str__(self):
        r"""__str__(teca_table_collection self) -> PyObject *"""
        return _teca_py.teca_table_collection___str__(self)

    def __setitem__(self, name, table):
        r"""
        __setitem__(teca_table_collection self, std::string const & name, p_teca_table table)

        Parameters
        ----------
        name: std::string const &
        table: p_teca_table

        """
        return _teca_py.teca_table_collection___setitem__(self, name, table)

    def __getitem__(self, name):
        r"""
        __getitem__(teca_table_collection self, std::string const & name) -> p_teca_table

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_table_collection___getitem__(self, name)
    __swig_destroy__ = _teca_py.delete_teca_table_collection

# Register teca_table_collection in _teca_py:
_teca_py.teca_table_collection_swigregister(teca_table_collection)

def teca_table_collection_New():
    r"""teca_table_collection_New() -> p_teca_table_collection"""
    return _teca_py.teca_table_collection_New()

class teca_database(teca_dataset):
    r"""Proxy of C++ teca_database class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_database"""
        return _teca_py.teca_database_New()

    def new_instance(self):
        r"""new_instance(teca_database self) -> p_teca_dataset"""
        return _teca_py.teca_database_new_instance(self)

    def new_copy(self, *args):
        r"""
        new_copy(teca_database self, teca_dataset::allocator alloc=allocator::malloc) -> p_teca_dataset

        Parameters
        ----------
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_database_new_copy(self, *args)

    def new_shallow_copy(self):
        r"""new_shallow_copy(teca_database self) -> p_teca_dataset"""
        return _teca_py.teca_database_new_shallow_copy(self)
    __swig_destroy__ = _teca_py.delete_teca_database

    def append_table(self, *args):
        r"""
        append_table(teca_database self, p_teca_table table) -> int

        Parameters
        ----------
        table: p_teca_table

        append_table(teca_database self, std::string const & name, p_teca_table table) -> int

        Parameters
        ----------
        name: std::string const &
        table: p_teca_table

        """
        return _teca_py.teca_database_append_table(self, *args)

    def declare_table(self, name):
        r"""
        declare_table(teca_database self, std::string const & name)

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_database_declare_table(self, name)

    def declare_tables(self, n):
        r"""
        declare_tables(teca_database self, unsigned int n)

        Parameters
        ----------
        n: unsigned int

        """
        return _teca_py.teca_database_declare_tables(self, n)

    def get_number_of_tables(self):
        r"""get_number_of_tables(teca_database self) -> unsigned int"""
        return _teca_py.teca_database_get_number_of_tables(self)

    def get_table(self, *args):
        r"""
        get_table(teca_database self, unsigned int i) -> p_teca_table

        Parameters
        ----------
        i: unsigned int

        get_table(teca_database self, unsigned int i) -> const_p_teca_table

        Parameters
        ----------
        i: unsigned int

        get_table(teca_database self, std::string const & name) -> p_teca_table

        Parameters
        ----------
        name: std::string const &

        get_table(teca_database self, std::string const & name) -> const_p_teca_table

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_database_get_table(self, *args)

    def get_table_name(self, i):
        r"""
        get_table_name(teca_database self, unsigned int i) -> std::string const &

        Parameters
        ----------
        i: unsigned int

        """
        return _teca_py.teca_database_get_table_name(self, i)

    def set_table(self, *args):
        r"""
        set_table(teca_database self, std::string const & name, p_teca_table table) -> int

        Parameters
        ----------
        name: std::string const &
        table: p_teca_table

        set_table(teca_database self, unsigned int i, p_teca_table table) -> int

        Parameters
        ----------
        i: unsigned int
        table: p_teca_table

        """
        return _teca_py.teca_database_set_table(self, *args)

    def remove_table(self, *args):
        r"""
        remove_table(teca_database self, unsigned int i) -> int

        Parameters
        ----------
        i: unsigned int

        remove_table(teca_database self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_database_remove_table(self, *args)

    def get_class_name(self):
        r"""get_class_name(teca_database self) -> std::string"""
        return _teca_py.teca_database_get_class_name(self)

    def get_type_code(self):
        r"""get_type_code(teca_database self) -> int"""
        return _teca_py.teca_database_get_type_code(self)

    def empty(self):
        r"""empty(teca_database self) -> bool"""
        return _teca_py.teca_database_empty(self)

    def copy(self, other, alloc):
        r"""
        copy(teca_database self, const_p_teca_dataset const & other, teca_dataset::allocator alloc)

        Parameters
        ----------
        other: const_p_teca_dataset const &
        alloc: enum teca_dataset::allocator

        """
        return _teca_py.teca_database_copy(self, other, alloc)

    def shallow_copy(self, other):
        r"""
        shallow_copy(teca_database self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_database_shallow_copy(self, other)

    def copy_metadata(self, other):
        r"""
        copy_metadata(teca_database self, const_p_teca_dataset const & other)

        Parameters
        ----------
        other: const_p_teca_dataset const &

        """
        return _teca_py.teca_database_copy_metadata(self, other)

    def swap(self, other):
        r"""
        swap(teca_database self, p_teca_dataset const & other)

        Parameters
        ----------
        other: p_teca_dataset const &

        """
        return _teca_py.teca_database_swap(self, other)

    def to_stream(self, *args):
        r"""
        to_stream(teca_database self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        to_stream(teca_database self, ostream arg2) -> int

        Parameters
        ----------
        arg2: std::ostream &

        """
        return _teca_py.teca_database_to_stream(self, *args)

    def from_stream(self, *args):
        r"""
        from_stream(teca_database self, teca_binary_stream arg2) -> int

        Parameters
        ----------
        arg2: teca_binary_stream &

        from_stream(teca_database self, istream arg2) -> int

        Parameters
        ----------
        arg2: std::istream &

        """
        return _teca_py.teca_database_from_stream(self, *args)

    def __str__(self):
        r"""__str__(teca_database self) -> PyObject *"""
        return _teca_py.teca_database___str__(self)

# Register teca_database in _teca_py:
_teca_py.teca_database_swigregister(teca_database)

def teca_database_New():
    r"""teca_database_New() -> p_teca_database"""
    return _teca_py.teca_database_New()


def as_teca_database(in_inst):
    r"""
    as_teca_database(p_teca_dataset in_inst) -> p_teca_database

    Parameters
    ----------
    in_inst: p_teca_dataset

    """
    return _teca_py.as_teca_database(in_inst)

def as_const_teca_database(inst):
    r"""
    as_const_teca_database(const_p_teca_dataset inst) -> const_p_teca_database

    Parameters
    ----------
    inst: const_p_teca_dataset

    """
    return _teca_py.as_const_teca_database(inst)

def as_non_const_teca_database(in_inst):
    r"""
    as_non_const_teca_database(const_p_teca_database in_inst) -> p_teca_database

    Parameters
    ----------
    in_inst: const_p_teca_database

    """
    return _teca_py.as_non_const_teca_database(in_inst)
class coordinate_util(object):
    r"""Proxy of C++ coordinate_util class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def time_step_of(time, lower, clamp, calendar, units, date):
        r"""
        time_step_of(PyObject * time, bool lower, bool clamp, std::string const & calendar, std::string const & units, std::string const & date) -> unsigned long

        Parameters
        ----------
        time: PyObject *
        lower: bool
        clamp: bool
        calendar: std::string const &
        units: std::string const &
        date: std::string const &

        """
        return _teca_py.coordinate_util_time_step_of(time, lower, clamp, calendar, units, date)

    @staticmethod
    def time_to_string(val, calendar, units, format):
        r"""
        time_to_string(double val, std::string const & calendar, std::string const & units, std::string const & format) -> std::string

        Parameters
        ----------
        val: double
        calendar: std::string const &
        units: std::string const &
        format: std::string const &

        """
        return _teca_py.coordinate_util_time_to_string(val, calendar, units, format)

    def __init__(self):
        r"""__init__(coordinate_util self) -> coordinate_util"""
        _teca_py.coordinate_util_swiginit(self, _teca_py.new_coordinate_util())
    __swig_destroy__ = _teca_py.delete_coordinate_util

# Register coordinate_util in _teca_py:
_teca_py.coordinate_util_swigregister(coordinate_util)

def coordinate_util_time_step_of(time, lower, clamp, calendar, units, date):
    r"""
    coordinate_util_time_step_of(PyObject * time, bool lower, bool clamp, std::string const & calendar, std::string const & units, std::string const & date) -> unsigned long

    Parameters
    ----------
    time: PyObject *
    lower: bool
    clamp: bool
    calendar: std::string const &
    units: std::string const &
    date: std::string const &

    """
    return _teca_py.coordinate_util_time_step_of(time, lower, clamp, calendar, units, date)

def coordinate_util_time_to_string(val, calendar, units, format):
    r"""
    coordinate_util_time_to_string(double val, std::string const & calendar, std::string const & units, std::string const & format) -> std::string

    Parameters
    ----------
    val: double
    calendar: std::string const &
    units: std::string const &
    format: std::string const &

    """
    return _teca_py.coordinate_util_time_to_string(val, calendar, units, format)

class teca_cartesian_mesh_subset(teca_algorithm):
    r"""Proxy of C++ teca_cartesian_mesh_subset class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_cartesian_mesh_subset"""
        return _teca_py.teca_cartesian_mesh_subset_New()

    def get_class_name(self):
        r"""get_class_name(teca_cartesian_mesh_subset self) -> char const *"""
        return _teca_py.teca_cartesian_mesh_subset_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_cartesian_mesh_subset

    def get_bounds(self):
        r"""get_bounds(teca_cartesian_mesh_subset self) -> std_vector_double"""
        return _teca_py.teca_cartesian_mesh_subset_get_bounds(self)

    def set_bounds(self, *args):
        r"""
        set_bounds(teca_cartesian_mesh_subset self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_bounds(teca_cartesian_mesh_subset self, double low_x, double high_x, double low_y, double high_y, double low_z, double high_z)

        Parameters
        ----------
        low_x: double
        high_x: double
        low_y: double
        high_y: double
        low_z: double
        high_z: double

        """
        return _teca_py.teca_cartesian_mesh_subset_set_bounds(self, *args)

    def set_cover_bounds(self, v):
        r"""
        set_cover_bounds(teca_cartesian_mesh_subset self, bool const & v)

        Parameters
        ----------
        v: bool const &

        """
        return _teca_py.teca_cartesian_mesh_subset_set_cover_bounds(self, v)

    def get_cover_bounds(self):
        r"""get_cover_bounds(teca_cartesian_mesh_subset self) -> bool const &"""
        return _teca_py.teca_cartesian_mesh_subset_get_cover_bounds(self)

# Register teca_cartesian_mesh_subset in _teca_py:
_teca_py.teca_cartesian_mesh_subset_swigregister(teca_cartesian_mesh_subset)

def teca_cartesian_mesh_subset_New():
    r"""teca_cartesian_mesh_subset_New() -> p_teca_cartesian_mesh_subset"""
    return _teca_py.teca_cartesian_mesh_subset_New()

class teca_cartesian_mesh_regrid(teca_algorithm):
    r"""Proxy of C++ teca_cartesian_mesh_regrid class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_cartesian_mesh_regrid"""
        return _teca_py.teca_cartesian_mesh_regrid_New()

    def get_class_name(self):
        r"""get_class_name(teca_cartesian_mesh_regrid self) -> char const *"""
        return _teca_py.teca_cartesian_mesh_regrid_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_cartesian_mesh_regrid

    def get_number_of_arrays(self):
        r"""get_number_of_arrays(teca_cartesian_mesh_regrid self) -> size_t"""
        return _teca_py.teca_cartesian_mesh_regrid_get_number_of_arrays(self)

    def append_array(self, v):
        r"""
        append_array(teca_cartesian_mesh_regrid self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_regrid_append_array(self, v)

    def set_array(self, i, v):
        r"""
        set_array(teca_cartesian_mesh_regrid self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_regrid_set_array(self, i, v)

    def set_arrays(self, *args):
        r"""
        set_arrays(teca_cartesian_mesh_regrid self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_arrays(teca_cartesian_mesh_regrid self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_cartesian_mesh_regrid_set_arrays(self, *args)

    def get_array(self, i):
        r"""
        get_array(teca_cartesian_mesh_regrid self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cartesian_mesh_regrid_get_array(self, i)

    def get_arrays(self):
        r"""get_arrays(teca_cartesian_mesh_regrid self) -> std_vector_string"""
        return _teca_py.teca_cartesian_mesh_regrid_get_arrays(self)

    def clear_arrays(self):
        r"""clear_arrays(teca_cartesian_mesh_regrid self)"""
        return _teca_py.teca_cartesian_mesh_regrid_clear_arrays(self)

    def set_target_input(self, v):
        r"""
        set_target_input(teca_cartesian_mesh_regrid self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cartesian_mesh_regrid_set_target_input(self, v)

    def get_target_input(self):
        r"""get_target_input(teca_cartesian_mesh_regrid self) -> int const &"""
        return _teca_py.teca_cartesian_mesh_regrid_get_target_input(self)
    nearest = _teca_py.teca_cartesian_mesh_regrid_nearest
    
    linear = _teca_py.teca_cartesian_mesh_regrid_linear
    

    def set_interpolation_mode(self, v):
        r"""
        set_interpolation_mode(teca_cartesian_mesh_regrid self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cartesian_mesh_regrid_set_interpolation_mode(self, v)

    def get_interpolation_mode(self):
        r"""get_interpolation_mode(teca_cartesian_mesh_regrid self) -> int const &"""
        return _teca_py.teca_cartesian_mesh_regrid_get_interpolation_mode(self)

    def set_interpolation_mode_nearest(self):
        r"""set_interpolation_mode_nearest(teca_cartesian_mesh_regrid self)"""
        return _teca_py.teca_cartesian_mesh_regrid_set_interpolation_mode_nearest(self)

    def set_interpolation_mode_linear(self):
        r"""set_interpolation_mode_linear(teca_cartesian_mesh_regrid self)"""
        return _teca_py.teca_cartesian_mesh_regrid_set_interpolation_mode_linear(self)

# Register teca_cartesian_mesh_regrid in _teca_py:
_teca_py.teca_cartesian_mesh_regrid_swigregister(teca_cartesian_mesh_regrid)

def teca_cartesian_mesh_regrid_New():
    r"""teca_cartesian_mesh_regrid_New() -> p_teca_cartesian_mesh_regrid"""
    return _teca_py.teca_cartesian_mesh_regrid_New()

class teca_connected_components(teca_algorithm):
    r"""Proxy of C++ teca_connected_components class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_connected_components"""
        return _teca_py.teca_connected_components_New()

    def get_class_name(self):
        r"""get_class_name(teca_connected_components self) -> char const *"""
        return _teca_py.teca_connected_components_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_connected_components

    def set_segmentation_variable(self, v):
        r"""
        set_segmentation_variable(teca_connected_components self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_connected_components_set_segmentation_variable(self, v)

    def get_segmentation_variable(self):
        r"""get_segmentation_variable(teca_connected_components self) -> std::string const &"""
        return _teca_py.teca_connected_components_get_segmentation_variable(self)

    def set_component_variable(self, v):
        r"""
        set_component_variable(teca_connected_components self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_connected_components_set_component_variable(self, v)

    def get_component_variable(self):
        r"""get_component_variable(teca_connected_components self) -> std::string const &"""
        return _teca_py.teca_connected_components_get_component_variable(self)

# Register teca_connected_components in _teca_py:
_teca_py.teca_connected_components_swigregister(teca_connected_components)

def teca_connected_components_New():
    r"""teca_connected_components_New() -> p_teca_connected_components"""
    return _teca_py.teca_connected_components_New()

class teca_l2_norm(teca_algorithm):
    r"""Proxy of C++ teca_l2_norm class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_l2_norm"""
        return _teca_py.teca_l2_norm_New()

    def get_class_name(self):
        r"""get_class_name(teca_l2_norm self) -> char const *"""
        return _teca_py.teca_l2_norm_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_l2_norm

    def set_component_0_variable(self, v):
        r"""
        set_component_0_variable(teca_l2_norm self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_l2_norm_set_component_0_variable(self, v)

    def get_component_0_variable(self):
        r"""get_component_0_variable(teca_l2_norm self) -> std::string const &"""
        return _teca_py.teca_l2_norm_get_component_0_variable(self)

    def set_component_1_variable(self, v):
        r"""
        set_component_1_variable(teca_l2_norm self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_l2_norm_set_component_1_variable(self, v)

    def get_component_1_variable(self):
        r"""get_component_1_variable(teca_l2_norm self) -> std::string const &"""
        return _teca_py.teca_l2_norm_get_component_1_variable(self)

    def set_component_2_variable(self, v):
        r"""
        set_component_2_variable(teca_l2_norm self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_l2_norm_set_component_2_variable(self, v)

    def get_component_2_variable(self):
        r"""get_component_2_variable(teca_l2_norm self) -> std::string const &"""
        return _teca_py.teca_l2_norm_get_component_2_variable(self)

    def set_l2_norm_variable(self, v):
        r"""
        set_l2_norm_variable(teca_l2_norm self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_l2_norm_set_l2_norm_variable(self, v)

    def get_l2_norm_variable(self):
        r"""get_l2_norm_variable(teca_l2_norm self) -> std::string const &"""
        return _teca_py.teca_l2_norm_get_l2_norm_variable(self)

# Register teca_l2_norm in _teca_py:
_teca_py.teca_l2_norm_swigregister(teca_l2_norm)

def teca_l2_norm_New():
    r"""teca_l2_norm_New() -> p_teca_l2_norm"""
    return _teca_py.teca_l2_norm_New()

class teca_laplacian(teca_algorithm):
    r"""Proxy of C++ teca_laplacian class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_laplacian"""
        return _teca_py.teca_laplacian_New()

    def get_class_name(self):
        r"""get_class_name(teca_laplacian self) -> char const *"""
        return _teca_py.teca_laplacian_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_laplacian

    def set_component_0_variable(self, v):
        r"""
        set_component_0_variable(teca_laplacian self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_laplacian_set_component_0_variable(self, v)

    def get_component_0_variable(self):
        r"""get_component_0_variable(teca_laplacian self) -> std::string const &"""
        return _teca_py.teca_laplacian_get_component_0_variable(self)

    def set_component_1_variable(self, v):
        r"""
        set_component_1_variable(teca_laplacian self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_laplacian_set_component_1_variable(self, v)

    def get_component_1_variable(self):
        r"""get_component_1_variable(teca_laplacian self) -> std::string const &"""
        return _teca_py.teca_laplacian_get_component_1_variable(self)

    def set_laplacian_variable(self, v):
        r"""
        set_laplacian_variable(teca_laplacian self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_laplacian_set_laplacian_variable(self, v)

    def get_laplacian_variable(self):
        r"""get_laplacian_variable(teca_laplacian self) -> std::string const &"""
        return _teca_py.teca_laplacian_get_laplacian_variable(self)

# Register teca_laplacian in _teca_py:
_teca_py.teca_laplacian_swigregister(teca_laplacian)

def teca_laplacian_New():
    r"""teca_laplacian_New() -> p_teca_laplacian"""
    return _teca_py.teca_laplacian_New()

class teca_mask(teca_algorithm):
    r"""Proxy of C++ teca_mask class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_mask"""
        return _teca_py.teca_mask_New()

    def get_class_name(self):
        r"""get_class_name(teca_mask self) -> char const *"""
        return _teca_py.teca_mask_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_mask

    def get_number_of_mask_variables(self):
        r"""get_number_of_mask_variables(teca_mask self) -> size_t"""
        return _teca_py.teca_mask_get_number_of_mask_variables(self)

    def append_mask_variable(self, v):
        r"""
        append_mask_variable(teca_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_mask_append_mask_variable(self, v)

    def set_mask_variable(self, i, v):
        r"""
        set_mask_variable(teca_mask self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_mask_set_mask_variable(self, i, v)

    def set_mask_variables(self, *args):
        r"""
        set_mask_variables(teca_mask self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_mask_variables(teca_mask self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_mask_set_mask_variables(self, *args)

    def get_mask_variable(self, i):
        r"""
        get_mask_variable(teca_mask self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_mask_get_mask_variable(self, i)

    def get_mask_variables(self):
        r"""get_mask_variables(teca_mask self) -> std_vector_string"""
        return _teca_py.teca_mask_get_mask_variables(self)

    def clear_mask_variables(self):
        r"""clear_mask_variables(teca_mask self)"""
        return _teca_py.teca_mask_clear_mask_variables(self)

    def set_low_threshold_value(self, v):
        r"""
        set_low_threshold_value(teca_mask self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_mask_set_low_threshold_value(self, v)

    def get_low_threshold_value(self):
        r"""get_low_threshold_value(teca_mask self) -> double const &"""
        return _teca_py.teca_mask_get_low_threshold_value(self)

    def set_high_threshold_value(self, v):
        r"""
        set_high_threshold_value(teca_mask self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_mask_set_high_threshold_value(self, v)

    def get_high_threshold_value(self):
        r"""get_high_threshold_value(teca_mask self) -> double const &"""
        return _teca_py.teca_mask_get_high_threshold_value(self)

    def set_mask_value(self, v):
        r"""
        set_mask_value(teca_mask self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_mask_set_mask_value(self, v)

    def get_mask_value(self):
        r"""get_mask_value(teca_mask self) -> double const &"""
        return _teca_py.teca_mask_get_mask_value(self)

# Register teca_mask in _teca_py:
_teca_py.teca_mask_swigregister(teca_mask)

def teca_mask_New():
    r"""teca_mask_New() -> p_teca_mask"""
    return _teca_py.teca_mask_New()

class teca_table_reduce(teca_index_reduce):
    r"""Proxy of C++ teca_table_reduce class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table_reduce"""
        return _teca_py.teca_table_reduce_New()

    def get_class_name(self):
        r"""get_class_name(teca_table_reduce self) -> char const *"""
        return _teca_py.teca_table_reduce_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_table_reduce

# Register teca_table_reduce in _teca_py:
_teca_py.teca_table_reduce_swigregister(teca_table_reduce)

def teca_table_reduce_New():
    r"""teca_table_reduce_New() -> p_teca_table_reduce"""
    return _teca_py.teca_table_reduce_New()

class teca_table_to_stream(teca_algorithm):
    r"""Proxy of C++ teca_table_to_stream class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table_to_stream"""
        return _teca_py.teca_table_to_stream_New()

    def get_class_name(self):
        r"""get_class_name(teca_table_to_stream self) -> char const *"""
        return _teca_py.teca_table_to_stream_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_table_to_stream

    def set_header(self, v):
        r"""
        set_header(teca_table_to_stream self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_to_stream_set_header(self, v)

    def get_header(self):
        r"""get_header(teca_table_to_stream self) -> std::string const &"""
        return _teca_py.teca_table_to_stream_get_header(self)

    def set_footer(self, v):
        r"""
        set_footer(teca_table_to_stream self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_to_stream_set_footer(self, v)

    def get_footer(self):
        r"""get_footer(teca_table_to_stream self) -> std::string const &"""
        return _teca_py.teca_table_to_stream_get_footer(self)

    def set_stream(self, *args):
        r"""
        set_stream(teca_table_to_stream self, ostream s)

        Parameters
        ----------
        s: std::ostream &

        set_stream(teca_table_to_stream self, std::string const & s)

        Parameters
        ----------
        s: std::string const &

        """
        return _teca_py.teca_table_to_stream_set_stream(self, *args)

    def set_stream_to_stderr(self):
        r"""set_stream_to_stderr(teca_table_to_stream self)"""
        return _teca_py.teca_table_to_stream_set_stream_to_stderr(self)

    def set_stream_to_stdout(self):
        r"""set_stream_to_stdout(teca_table_to_stream self)"""
        return _teca_py.teca_table_to_stream_set_stream_to_stdout(self)

    def get_stream(self):
        r"""get_stream(teca_table_to_stream self) -> std::string"""
        return _teca_py.teca_table_to_stream_get_stream(self)

# Register teca_table_to_stream in _teca_py:
_teca_py.teca_table_to_stream_swigregister(teca_table_to_stream)

def teca_table_to_stream_New():
    r"""teca_table_to_stream_New() -> p_teca_table_to_stream"""
    return _teca_py.teca_table_to_stream_New()

class teca_simple_moving_average(teca_algorithm):
    r"""Proxy of C++ teca_simple_moving_average class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_simple_moving_average"""
        return _teca_py.teca_simple_moving_average_New()

    def get_class_name(self):
        r"""get_class_name(teca_simple_moving_average self) -> char const *"""
        return _teca_py.teca_simple_moving_average_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_simple_moving_average

    def set_filter_width(self, v):
        r"""
        set_filter_width(teca_simple_moving_average self, unsigned int const & v)

        Parameters
        ----------
        v: unsigned int const &

        """
        return _teca_py.teca_simple_moving_average_set_filter_width(self, v)

    def get_filter_width(self):
        r"""get_filter_width(teca_simple_moving_average self) -> unsigned int const &"""
        return _teca_py.teca_simple_moving_average_get_filter_width(self)
    backward = _teca_py.teca_simple_moving_average_backward
    
    centered = _teca_py.teca_simple_moving_average_centered
    
    forward = _teca_py.teca_simple_moving_average_forward
    

    def set_filter_type(self, v):
        r"""
        set_filter_type(teca_simple_moving_average self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_simple_moving_average_set_filter_type(self, v)

    def get_filter_type(self):
        r"""get_filter_type(teca_simple_moving_average self) -> int const &"""
        return _teca_py.teca_simple_moving_average_get_filter_type(self)

# Register teca_simple_moving_average in _teca_py:
_teca_py.teca_simple_moving_average_swigregister(teca_simple_moving_average)

def teca_simple_moving_average_New():
    r"""teca_simple_moving_average_New() -> p_teca_simple_moving_average"""
    return _teca_py.teca_simple_moving_average_New()

class teca_vorticity(teca_algorithm):
    r"""Proxy of C++ teca_vorticity class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_vorticity"""
        return _teca_py.teca_vorticity_New()

    def get_class_name(self):
        r"""get_class_name(teca_vorticity self) -> char const *"""
        return _teca_py.teca_vorticity_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_vorticity

    def set_component_0_variable(self, v):
        r"""
        set_component_0_variable(teca_vorticity self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_vorticity_set_component_0_variable(self, v)

    def get_component_0_variable(self):
        r"""get_component_0_variable(teca_vorticity self) -> std::string const &"""
        return _teca_py.teca_vorticity_get_component_0_variable(self)

    def set_component_1_variable(self, v):
        r"""
        set_component_1_variable(teca_vorticity self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_vorticity_set_component_1_variable(self, v)

    def get_component_1_variable(self):
        r"""get_component_1_variable(teca_vorticity self) -> std::string const &"""
        return _teca_py.teca_vorticity_get_component_1_variable(self)

    def set_vorticity_variable(self, v):
        r"""
        set_vorticity_variable(teca_vorticity self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_vorticity_set_vorticity_variable(self, v)

    def get_vorticity_variable(self):
        r"""get_vorticity_variable(teca_vorticity self) -> std::string const &"""
        return _teca_py.teca_vorticity_get_vorticity_variable(self)

# Register teca_vorticity in _teca_py:
_teca_py.teca_vorticity_swigregister(teca_vorticity)

def teca_vorticity_New():
    r"""teca_vorticity_New() -> p_teca_vorticity"""
    return _teca_py.teca_vorticity_New()

class teca_derived_quantity(teca_programmable_algorithm):
    r"""Proxy of C++ teca_derived_quantity class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_derived_quantity"""
        return _teca_py.teca_derived_quantity_New()
    __swig_destroy__ = _teca_py.delete_teca_derived_quantity

    def get_number_of_dependent_variables(self):
        r"""get_number_of_dependent_variables(teca_derived_quantity self) -> size_t"""
        return _teca_py.teca_derived_quantity_get_number_of_dependent_variables(self)

    def append_dependent_variable(self, v):
        r"""
        append_dependent_variable(teca_derived_quantity self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_derived_quantity_append_dependent_variable(self, v)

    def set_dependent_variable(self, i, v):
        r"""
        set_dependent_variable(teca_derived_quantity self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_derived_quantity_set_dependent_variable(self, i, v)

    def set_dependent_variables(self, *args):
        r"""
        set_dependent_variables(teca_derived_quantity self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_dependent_variables(teca_derived_quantity self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_derived_quantity_set_dependent_variables(self, *args)

    def get_dependent_variable(self, i):
        r"""
        get_dependent_variable(teca_derived_quantity self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_derived_quantity_get_dependent_variable(self, i)

    def get_dependent_variables(self):
        r"""get_dependent_variables(teca_derived_quantity self) -> std_vector_string"""
        return _teca_py.teca_derived_quantity_get_dependent_variables(self)

    def clear_dependent_variables(self):
        r"""clear_dependent_variables(teca_derived_quantity self)"""
        return _teca_py.teca_derived_quantity_clear_dependent_variables(self)

    def set_derived_variable(self, v):
        r"""
        set_derived_variable(teca_derived_quantity self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_derived_quantity_set_derived_variable(self, v)

    def get_derived_variable(self):
        r"""get_derived_variable(teca_derived_quantity self) -> std::string const &"""
        return _teca_py.teca_derived_quantity_get_derived_variable(self)

    def set_operation_name(self, v):
        r"""
        set_operation_name(teca_derived_quantity self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_derived_quantity_set_operation_name(self, v)

    def get_operation_name(self, *args):
        r"""
        get_operation_name(teca_derived_quantity self) -> std::string const
        get_operation_name(teca_derived_quantity self) -> std::string &
        """
        return _teca_py.teca_derived_quantity_get_operation_name(self, *args)

    def set_execute_callback(self, f):
        r"""
        set_execute_callback(teca_derived_quantity self, PyObject * f)

        Parameters
        ----------
        f: PyObject *

        """
        return _teca_py.teca_derived_quantity_set_execute_callback(self, f)

# Register teca_derived_quantity in _teca_py:
_teca_py.teca_derived_quantity_swigregister(teca_derived_quantity)

def teca_derived_quantity_New():
    r"""teca_derived_quantity_New() -> p_teca_derived_quantity"""
    return _teca_py.teca_derived_quantity_New()

class point_wise_average(object):
    r"""Proxy of C++ teca_derived_quantity_numerics::point_wise_average class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, v0, v1, avg):
        r"""
        __init__(point_wise_average self, std::string const & v0, std::string const & v1, std::string const & avg) -> point_wise_average

        Parameters
        ----------
        v0: std::string const &
        v1: std::string const &
        avg: std::string const &

        """
        _teca_py.point_wise_average_swiginit(self, _teca_py.new_point_wise_average(v0, v1, avg))
    __swig_destroy__ = _teca_py.delete_point_wise_average

    def __call__(self, arg2, in_data, arg4):
        r"""
        __call__(point_wise_average self, unsigned int arg2, std::vector< const_p_teca_dataset,std::allocator< const_p_teca_dataset > > const & in_data, teca_metadata arg4) -> const_p_teca_dataset

        Parameters
        ----------
        arg2: unsigned int
        in_data: std::vector< const_p_teca_dataset,std::allocator< const_p_teca_dataset > > const &
        arg4: teca_metadata const &

        """
        return _teca_py.point_wise_average___call__(self, arg2, in_data, arg4)
    m_v0 = property(_teca_py.point_wise_average_m_v0_get, _teca_py.point_wise_average_m_v0_set, doc=r"""m_v0 : std::string""")
    m_v1 = property(_teca_py.point_wise_average_m_v1_get, _teca_py.point_wise_average_m_v1_set, doc=r"""m_v1 : std::string""")
    m_avg = property(_teca_py.point_wise_average_m_avg_get, _teca_py.point_wise_average_m_avg_set, doc=r"""m_avg : std::string""")

# Register point_wise_average in _teca_py:
_teca_py.point_wise_average_swigregister(point_wise_average)

class point_wise_difference(object):
    r"""Proxy of C++ teca_derived_quantity_numerics::point_wise_difference class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, v0, v1, diff):
        r"""
        __init__(point_wise_difference self, std::string const & v0, std::string const & v1, std::string const & diff) -> point_wise_difference

        Parameters
        ----------
        v0: std::string const &
        v1: std::string const &
        diff: std::string const &

        """
        _teca_py.point_wise_difference_swiginit(self, _teca_py.new_point_wise_difference(v0, v1, diff))
    __swig_destroy__ = _teca_py.delete_point_wise_difference

    def __call__(self, arg2, in_data, arg4):
        r"""
        __call__(point_wise_difference self, unsigned int arg2, std::vector< const_p_teca_dataset,std::allocator< const_p_teca_dataset > > const & in_data, teca_metadata arg4) -> const_p_teca_dataset

        Parameters
        ----------
        arg2: unsigned int
        in_data: std::vector< const_p_teca_dataset,std::allocator< const_p_teca_dataset > > const &
        arg4: teca_metadata const &

        """
        return _teca_py.point_wise_difference___call__(self, arg2, in_data, arg4)
    m_v0 = property(_teca_py.point_wise_difference_m_v0_get, _teca_py.point_wise_difference_m_v0_set, doc=r"""m_v0 : std::string""")
    m_v1 = property(_teca_py.point_wise_difference_m_v1_get, _teca_py.point_wise_difference_m_v1_set, doc=r"""m_v1 : std::string""")
    m_diff = property(_teca_py.point_wise_difference_m_diff_get, _teca_py.point_wise_difference_m_diff_set, doc=r"""m_diff : std::string""")

# Register point_wise_difference in _teca_py:
_teca_py.point_wise_difference_swigregister(point_wise_difference)

class teca_descriptive_statistics(teca_algorithm):
    r"""Proxy of C++ teca_descriptive_statistics class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_descriptive_statistics"""
        return _teca_py.teca_descriptive_statistics_New()

    def get_class_name(self):
        r"""get_class_name(teca_descriptive_statistics self) -> char const *"""
        return _teca_py.teca_descriptive_statistics_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_descriptive_statistics

    def get_number_of_dependent_variables(self):
        r"""get_number_of_dependent_variables(teca_descriptive_statistics self) -> size_t"""
        return _teca_py.teca_descriptive_statistics_get_number_of_dependent_variables(self)

    def append_dependent_variable(self, v):
        r"""
        append_dependent_variable(teca_descriptive_statistics self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_descriptive_statistics_append_dependent_variable(self, v)

    def set_dependent_variable(self, i, v):
        r"""
        set_dependent_variable(teca_descriptive_statistics self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_descriptive_statistics_set_dependent_variable(self, i, v)

    def set_dependent_variables(self, *args):
        r"""
        set_dependent_variables(teca_descriptive_statistics self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_dependent_variables(teca_descriptive_statistics self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_descriptive_statistics_set_dependent_variables(self, *args)

    def get_dependent_variable(self, i):
        r"""
        get_dependent_variable(teca_descriptive_statistics self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_descriptive_statistics_get_dependent_variable(self, i)

    def get_dependent_variables(self):
        r"""get_dependent_variables(teca_descriptive_statistics self) -> std_vector_string"""
        return _teca_py.teca_descriptive_statistics_get_dependent_variables(self)

    def clear_dependent_variables(self):
        r"""clear_dependent_variables(teca_descriptive_statistics self)"""
        return _teca_py.teca_descriptive_statistics_clear_dependent_variables(self)

# Register teca_descriptive_statistics in _teca_py:
_teca_py.teca_descriptive_statistics_swigregister(teca_descriptive_statistics)

def teca_descriptive_statistics_New():
    r"""teca_descriptive_statistics_New() -> p_teca_descriptive_statistics"""
    return _teca_py.teca_descriptive_statistics_New()

class teca_table_sort(teca_algorithm):
    r"""Proxy of C++ teca_table_sort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table_sort"""
        return _teca_py.teca_table_sort_New()

    def get_class_name(self):
        r"""get_class_name(teca_table_sort self) -> char const *"""
        return _teca_py.teca_table_sort_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_table_sort

    def set_index_column(self, v):
        r"""
        set_index_column(teca_table_sort self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_sort_set_index_column(self, v)

    def get_index_column(self):
        r"""get_index_column(teca_table_sort self) -> std::string const &"""
        return _teca_py.teca_table_sort_get_index_column(self)

    def set_index_column_id(self, v):
        r"""
        set_index_column_id(teca_table_sort self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_table_sort_set_index_column_id(self, v)

    def get_index_column_id(self):
        r"""get_index_column_id(teca_table_sort self) -> int const &"""
        return _teca_py.teca_table_sort_get_index_column_id(self)

    def set_stable_sort(self, v):
        r"""
        set_stable_sort(teca_table_sort self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_table_sort_set_stable_sort(self, v)

    def get_stable_sort(self):
        r"""get_stable_sort(teca_table_sort self) -> int const &"""
        return _teca_py.teca_table_sort_get_stable_sort(self)

    def enable_stable_sort(self):
        r"""enable_stable_sort(teca_table_sort self)"""
        return _teca_py.teca_table_sort_enable_stable_sort(self)

    def disable_stable_sort(self):
        r"""disable_stable_sort(teca_table_sort self)"""
        return _teca_py.teca_table_sort_disable_stable_sort(self)

# Register teca_table_sort in _teca_py:
_teca_py.teca_table_sort_swigregister(teca_table_sort)

def teca_table_sort_New():
    r"""teca_table_sort_New() -> p_teca_table_sort"""
    return _teca_py.teca_table_sort_New()

class teca_table_calendar(teca_algorithm):
    r"""Proxy of C++ teca_table_calendar class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table_calendar"""
        return _teca_py.teca_table_calendar_New()

    def get_class_name(self):
        r"""get_class_name(teca_table_calendar self) -> char const *"""
        return _teca_py.teca_table_calendar_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_table_calendar

    def set_time_column(self, v):
        r"""
        set_time_column(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_time_column(self, v)

    def get_time_column(self):
        r"""get_time_column(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_time_column(self)

    def set_units(self, v):
        r"""
        set_units(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_units(self, v)

    def get_units(self):
        r"""get_units(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_units(self)

    def set_calendar(self, v):
        r"""
        set_calendar(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_calendar(self, v)

    def get_calendar(self):
        r"""get_calendar(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_calendar(self)

    def set_year_column(self, v):
        r"""
        set_year_column(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_year_column(self, v)

    def get_year_column(self):
        r"""get_year_column(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_year_column(self)

    def set_month_column(self, v):
        r"""
        set_month_column(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_month_column(self, v)

    def get_month_column(self):
        r"""get_month_column(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_month_column(self)

    def set_day_column(self, v):
        r"""
        set_day_column(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_day_column(self, v)

    def get_day_column(self):
        r"""get_day_column(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_day_column(self)

    def set_hour_column(self, v):
        r"""
        set_hour_column(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_hour_column(self, v)

    def get_hour_column(self):
        r"""get_hour_column(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_hour_column(self)

    def set_minute_column(self, v):
        r"""
        set_minute_column(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_minute_column(self, v)

    def get_minute_column(self):
        r"""get_minute_column(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_minute_column(self)

    def set_second_column(self, v):
        r"""
        set_second_column(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_second_column(self, v)

    def get_second_column(self):
        r"""get_second_column(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_second_column(self)

    def set_output_column_prefix(self, v):
        r"""
        set_output_column_prefix(teca_table_calendar self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_calendar_set_output_column_prefix(self, v)

    def get_output_column_prefix(self):
        r"""get_output_column_prefix(teca_table_calendar self) -> std::string const &"""
        return _teca_py.teca_table_calendar_get_output_column_prefix(self)

# Register teca_table_calendar in _teca_py:
_teca_py.teca_table_calendar_swigregister(teca_table_calendar)

def teca_table_calendar_New():
    r"""teca_table_calendar_New() -> p_teca_table_calendar"""
    return _teca_py.teca_table_calendar_New()

class teca_tc_candidates(teca_algorithm):
    r"""Proxy of C++ teca_tc_candidates class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_tc_candidates"""
        return _teca_py.teca_tc_candidates_New()

    def get_class_name(self):
        r"""get_class_name(teca_tc_candidates self) -> char const *"""
        return _teca_py.teca_tc_candidates_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_tc_candidates

    def set_surface_wind_speed_variable(self, v):
        r"""
        set_surface_wind_speed_variable(teca_tc_candidates self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_candidates_set_surface_wind_speed_variable(self, v)

    def get_surface_wind_speed_variable(self):
        r"""get_surface_wind_speed_variable(teca_tc_candidates self) -> std::string const &"""
        return _teca_py.teca_tc_candidates_get_surface_wind_speed_variable(self)

    def set_vorticity_850mb_variable(self, v):
        r"""
        set_vorticity_850mb_variable(teca_tc_candidates self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_candidates_set_vorticity_850mb_variable(self, v)

    def get_vorticity_850mb_variable(self):
        r"""get_vorticity_850mb_variable(teca_tc_candidates self) -> std::string const &"""
        return _teca_py.teca_tc_candidates_get_vorticity_850mb_variable(self)

    def set_sea_level_pressure_variable(self, v):
        r"""
        set_sea_level_pressure_variable(teca_tc_candidates self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_candidates_set_sea_level_pressure_variable(self, v)

    def get_sea_level_pressure_variable(self):
        r"""get_sea_level_pressure_variable(teca_tc_candidates self) -> std::string const &"""
        return _teca_py.teca_tc_candidates_get_sea_level_pressure_variable(self)

    def set_core_temperature_variable(self, v):
        r"""
        set_core_temperature_variable(teca_tc_candidates self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_candidates_set_core_temperature_variable(self, v)

    def get_core_temperature_variable(self):
        r"""get_core_temperature_variable(teca_tc_candidates self) -> std::string const &"""
        return _teca_py.teca_tc_candidates_get_core_temperature_variable(self)

    def set_thickness_variable(self, v):
        r"""
        set_thickness_variable(teca_tc_candidates self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_candidates_set_thickness_variable(self, v)

    def get_thickness_variable(self):
        r"""get_thickness_variable(teca_tc_candidates self) -> std::string const &"""
        return _teca_py.teca_tc_candidates_get_thickness_variable(self)

    def set_max_core_radius(self, v):
        r"""
        set_max_core_radius(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_max_core_radius(self, v)

    def get_max_core_radius(self):
        r"""get_max_core_radius(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_max_core_radius(self)

    def set_min_vorticity_850mb(self, v):
        r"""
        set_min_vorticity_850mb(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_min_vorticity_850mb(self, v)

    def get_min_vorticity_850mb(self):
        r"""get_min_vorticity_850mb(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_min_vorticity_850mb(self)

    def set_vorticity_850mb_window(self, v):
        r"""
        set_vorticity_850mb_window(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_vorticity_850mb_window(self, v)

    def get_vorticity_850mb_window(self):
        r"""get_vorticity_850mb_window(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_vorticity_850mb_window(self)

    def set_max_pressure_delta(self, v):
        r"""
        set_max_pressure_delta(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_max_pressure_delta(self, v)

    def get_max_pressure_delta(self):
        r"""get_max_pressure_delta(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_max_pressure_delta(self)

    def set_max_pressure_radius(self, v):
        r"""
        set_max_pressure_radius(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_max_pressure_radius(self, v)

    def get_max_pressure_radius(self):
        r"""get_max_pressure_radius(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_max_pressure_radius(self)

    def set_max_core_temperature_delta(self, v):
        r"""
        set_max_core_temperature_delta(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_max_core_temperature_delta(self, v)

    def get_max_core_temperature_delta(self):
        r"""get_max_core_temperature_delta(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_max_core_temperature_delta(self)

    def set_max_core_temperature_radius(self, v):
        r"""
        set_max_core_temperature_radius(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_max_core_temperature_radius(self, v)

    def get_max_core_temperature_radius(self):
        r"""get_max_core_temperature_radius(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_max_core_temperature_radius(self)

    def set_max_thickness_delta(self, v):
        r"""
        set_max_thickness_delta(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_max_thickness_delta(self, v)

    def get_max_thickness_delta(self):
        r"""get_max_thickness_delta(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_max_thickness_delta(self)

    def set_max_thickness_radius(self, v):
        r"""
        set_max_thickness_radius(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_max_thickness_radius(self, v)

    def get_max_thickness_radius(self):
        r"""get_max_thickness_radius(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_max_thickness_radius(self)

    def set_search_lat_low(self, v):
        r"""
        set_search_lat_low(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_search_lat_low(self, v)

    def get_search_lat_low(self):
        r"""get_search_lat_low(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_search_lat_low(self)

    def set_search_lat_high(self, v):
        r"""
        set_search_lat_high(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_search_lat_high(self, v)

    def get_search_lat_high(self):
        r"""get_search_lat_high(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_search_lat_high(self)

    def set_search_lon_low(self, v):
        r"""
        set_search_lon_low(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_search_lon_low(self, v)

    def get_search_lon_low(self):
        r"""get_search_lon_low(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_search_lon_low(self)

    def set_search_lon_high(self, v):
        r"""
        set_search_lon_high(teca_tc_candidates self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_candidates_set_search_lon_high(self, v)

    def get_search_lon_high(self):
        r"""get_search_lon_high(teca_tc_candidates self) -> double const &"""
        return _teca_py.teca_tc_candidates_get_search_lon_high(self)

    def set_minimizer_iterations(self, v):
        r"""
        set_minimizer_iterations(teca_tc_candidates self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_tc_candidates_set_minimizer_iterations(self, v)

    def get_minimizer_iterations(self):
        r"""get_minimizer_iterations(teca_tc_candidates self) -> int const &"""
        return _teca_py.teca_tc_candidates_get_minimizer_iterations(self)

    def to_stream(self, os):
        r"""
        to_stream(teca_tc_candidates self, ostream os)

        Parameters
        ----------
        os: std::ostream &

        """
        return _teca_py.teca_tc_candidates_to_stream(self, os)

# Register teca_tc_candidates in _teca_py:
_teca_py.teca_tc_candidates_swigregister(teca_tc_candidates)

def teca_tc_candidates_New():
    r"""teca_tc_candidates_New() -> p_teca_tc_candidates"""
    return _teca_py.teca_tc_candidates_New()

class teca_tc_trajectory(teca_algorithm):
    r"""Proxy of C++ teca_tc_trajectory class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_tc_trajectory"""
        return _teca_py.teca_tc_trajectory_New()

    def get_class_name(self):
        r"""get_class_name(teca_tc_trajectory self) -> char const *"""
        return _teca_py.teca_tc_trajectory_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_tc_trajectory

    def set_max_daily_distance(self, v):
        r"""
        set_max_daily_distance(teca_tc_trajectory self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_trajectory_set_max_daily_distance(self, v)

    def get_max_daily_distance(self):
        r"""get_max_daily_distance(teca_tc_trajectory self) -> double const &"""
        return _teca_py.teca_tc_trajectory_get_max_daily_distance(self)

    def set_min_wind_speed(self, v):
        r"""
        set_min_wind_speed(teca_tc_trajectory self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_trajectory_set_min_wind_speed(self, v)

    def get_min_wind_speed(self):
        r"""get_min_wind_speed(teca_tc_trajectory self) -> double const &"""
        return _teca_py.teca_tc_trajectory_get_min_wind_speed(self)

    def set_min_wind_duration(self, v):
        r"""
        set_min_wind_duration(teca_tc_trajectory self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_trajectory_set_min_wind_duration(self, v)

    def get_min_wind_duration(self):
        r"""get_min_wind_duration(teca_tc_trajectory self) -> double const &"""
        return _teca_py.teca_tc_trajectory_get_min_wind_duration(self)

    def set_step_interval(self, v):
        r"""
        set_step_interval(teca_tc_trajectory self, unsigned long const & v)

        Parameters
        ----------
        v: unsigned long const &

        """
        return _teca_py.teca_tc_trajectory_set_step_interval(self, v)

    def get_step_interval(self):
        r"""get_step_interval(teca_tc_trajectory self) -> unsigned long const &"""
        return _teca_py.teca_tc_trajectory_get_step_interval(self)

# Register teca_tc_trajectory in _teca_py:
_teca_py.teca_tc_trajectory_swigregister(teca_tc_trajectory)

def teca_tc_trajectory_New():
    r"""teca_tc_trajectory_New() -> p_teca_tc_trajectory"""
    return _teca_py.teca_tc_trajectory_New()

class teca_tc_classify(teca_algorithm):
    r"""Proxy of C++ teca_tc_classify class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_tc_classify"""
        return _teca_py.teca_tc_classify_New()

    def get_class_name(self):
        r"""get_class_name(teca_tc_classify self) -> char const *"""
        return _teca_py.teca_tc_classify_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_tc_classify

    def set_track_id_column(self, v):
        r"""
        set_track_id_column(teca_tc_classify self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_set_track_id_column(self, v)

    def get_track_id_column(self):
        r"""get_track_id_column(teca_tc_classify self) -> std::string const &"""
        return _teca_py.teca_tc_classify_get_track_id_column(self)

    def set_time_column(self, v):
        r"""
        set_time_column(teca_tc_classify self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_set_time_column(self, v)

    def get_time_column(self):
        r"""get_time_column(teca_tc_classify self) -> std::string const &"""
        return _teca_py.teca_tc_classify_get_time_column(self)

    def set_surface_wind_column(self, v):
        r"""
        set_surface_wind_column(teca_tc_classify self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_set_surface_wind_column(self, v)

    def get_surface_wind_column(self):
        r"""get_surface_wind_column(teca_tc_classify self) -> std::string const &"""
        return _teca_py.teca_tc_classify_get_surface_wind_column(self)

    def set_sea_level_pressure_column(self, v):
        r"""
        set_sea_level_pressure_column(teca_tc_classify self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_set_sea_level_pressure_column(self, v)

    def get_sea_level_pressure_column(self):
        r"""get_sea_level_pressure_column(teca_tc_classify self) -> std::string const &"""
        return _teca_py.teca_tc_classify_get_sea_level_pressure_column(self)

    def set_x_coordinate_column(self, v):
        r"""
        set_x_coordinate_column(teca_tc_classify self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_set_x_coordinate_column(self, v)

    def get_x_coordinate_column(self):
        r"""get_x_coordinate_column(teca_tc_classify self) -> std::string const &"""
        return _teca_py.teca_tc_classify_get_x_coordinate_column(self)

    def set_y_coordinate_column(self, v):
        r"""
        set_y_coordinate_column(teca_tc_classify self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_set_y_coordinate_column(self, v)

    def get_y_coordinate_column(self):
        r"""get_y_coordinate_column(teca_tc_classify self) -> std::string const &"""
        return _teca_py.teca_tc_classify_get_y_coordinate_column(self)

    def get_number_of_region_sizes(self):
        r"""get_number_of_region_sizes(teca_tc_classify self) -> size_t"""
        return _teca_py.teca_tc_classify_get_number_of_region_sizes(self)

    def append_region_size(self, v):
        r"""
        append_region_size(teca_tc_classify self, unsigned long const & v)

        Parameters
        ----------
        v: unsigned long const &

        """
        return _teca_py.teca_tc_classify_append_region_size(self, v)

    def set_region_size(self, i, v):
        r"""
        set_region_size(teca_tc_classify self, size_t i, unsigned long const & v)

        Parameters
        ----------
        i: size_t
        v: unsigned long const &

        """
        return _teca_py.teca_tc_classify_set_region_size(self, i, v)

    def set_region_sizes(self, *args):
        r"""
        set_region_sizes(teca_tc_classify self, std_vector_ulong v)

        Parameters
        ----------
        v: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_region_sizes(teca_tc_classify self, std::initializer_list< unsigned long > const && l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &&

        """
        return _teca_py.teca_tc_classify_set_region_sizes(self, *args)

    def get_region_size(self, i):
        r"""
        get_region_size(teca_tc_classify self, size_t i) -> unsigned long const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_tc_classify_get_region_size(self, i)

    def get_region_sizes(self):
        r"""get_region_sizes(teca_tc_classify self) -> std_vector_ulong"""
        return _teca_py.teca_tc_classify_get_region_sizes(self)

    def clear_region_sizes(self):
        r"""clear_region_sizes(teca_tc_classify self)"""
        return _teca_py.teca_tc_classify_clear_region_sizes(self)

    def get_number_of_region_starts(self):
        r"""get_number_of_region_starts(teca_tc_classify self) -> size_t"""
        return _teca_py.teca_tc_classify_get_number_of_region_starts(self)

    def append_region_start(self, v):
        r"""
        append_region_start(teca_tc_classify self, unsigned long const & v)

        Parameters
        ----------
        v: unsigned long const &

        """
        return _teca_py.teca_tc_classify_append_region_start(self, v)

    def set_region_start(self, i, v):
        r"""
        set_region_start(teca_tc_classify self, size_t i, unsigned long const & v)

        Parameters
        ----------
        i: size_t
        v: unsigned long const &

        """
        return _teca_py.teca_tc_classify_set_region_start(self, i, v)

    def set_region_starts(self, *args):
        r"""
        set_region_starts(teca_tc_classify self, std_vector_ulong v)

        Parameters
        ----------
        v: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_region_starts(teca_tc_classify self, std::initializer_list< unsigned long > const && l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &&

        """
        return _teca_py.teca_tc_classify_set_region_starts(self, *args)

    def get_region_start(self, i):
        r"""
        get_region_start(teca_tc_classify self, size_t i) -> unsigned long const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_tc_classify_get_region_start(self, i)

    def get_region_starts(self):
        r"""get_region_starts(teca_tc_classify self) -> std_vector_ulong"""
        return _teca_py.teca_tc_classify_get_region_starts(self)

    def clear_region_starts(self):
        r"""clear_region_starts(teca_tc_classify self)"""
        return _teca_py.teca_tc_classify_clear_region_starts(self)

    def get_number_of_region_x_coordinates(self):
        r"""get_number_of_region_x_coordinates(teca_tc_classify self) -> size_t"""
        return _teca_py.teca_tc_classify_get_number_of_region_x_coordinates(self)

    def append_region_x_coordinate(self, v):
        r"""
        append_region_x_coordinate(teca_tc_classify self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_classify_append_region_x_coordinate(self, v)

    def set_region_x_coordinate(self, i, v):
        r"""
        set_region_x_coordinate(teca_tc_classify self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_tc_classify_set_region_x_coordinate(self, i, v)

    def set_region_x_coordinates(self, *args):
        r"""
        set_region_x_coordinates(teca_tc_classify self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_region_x_coordinates(teca_tc_classify self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_tc_classify_set_region_x_coordinates(self, *args)

    def get_region_x_coordinate(self, i):
        r"""
        get_region_x_coordinate(teca_tc_classify self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_tc_classify_get_region_x_coordinate(self, i)

    def get_region_x_coordinates(self):
        r"""get_region_x_coordinates(teca_tc_classify self) -> std_vector_double"""
        return _teca_py.teca_tc_classify_get_region_x_coordinates(self)

    def clear_region_x_coordinates(self):
        r"""clear_region_x_coordinates(teca_tc_classify self)"""
        return _teca_py.teca_tc_classify_clear_region_x_coordinates(self)

    def get_number_of_region_y_coordinates(self):
        r"""get_number_of_region_y_coordinates(teca_tc_classify self) -> size_t"""
        return _teca_py.teca_tc_classify_get_number_of_region_y_coordinates(self)

    def append_region_y_coordinate(self, v):
        r"""
        append_region_y_coordinate(teca_tc_classify self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_classify_append_region_y_coordinate(self, v)

    def set_region_y_coordinate(self, i, v):
        r"""
        set_region_y_coordinate(teca_tc_classify self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_tc_classify_set_region_y_coordinate(self, i, v)

    def set_region_y_coordinates(self, *args):
        r"""
        set_region_y_coordinates(teca_tc_classify self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_region_y_coordinates(teca_tc_classify self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_tc_classify_set_region_y_coordinates(self, *args)

    def get_region_y_coordinate(self, i):
        r"""
        get_region_y_coordinate(teca_tc_classify self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_tc_classify_get_region_y_coordinate(self, i)

    def get_region_y_coordinates(self):
        r"""get_region_y_coordinates(teca_tc_classify self) -> std_vector_double"""
        return _teca_py.teca_tc_classify_get_region_y_coordinates(self)

    def clear_region_y_coordinates(self):
        r"""clear_region_y_coordinates(teca_tc_classify self)"""
        return _teca_py.teca_tc_classify_clear_region_y_coordinates(self)

    def get_number_of_region_ids(self):
        r"""get_number_of_region_ids(teca_tc_classify self) -> size_t"""
        return _teca_py.teca_tc_classify_get_number_of_region_ids(self)

    def append_region_id(self, v):
        r"""
        append_region_id(teca_tc_classify self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_tc_classify_append_region_id(self, v)

    def set_region_id(self, i, v):
        r"""
        set_region_id(teca_tc_classify self, size_t i, int const & v)

        Parameters
        ----------
        i: size_t
        v: int const &

        """
        return _teca_py.teca_tc_classify_set_region_id(self, i, v)

    def set_region_ids(self, *args):
        r"""
        set_region_ids(teca_tc_classify self, std_vector_int v)

        Parameters
        ----------
        v: std::vector< int,std::allocator< int > > const &

        set_region_ids(teca_tc_classify self, std::initializer_list< int > const && l)

        Parameters
        ----------
        l: std::initializer_list< int > const &&

        """
        return _teca_py.teca_tc_classify_set_region_ids(self, *args)

    def get_region_id(self, i):
        r"""
        get_region_id(teca_tc_classify self, size_t i) -> int const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_tc_classify_get_region_id(self, i)

    def get_region_ids(self):
        r"""get_region_ids(teca_tc_classify self) -> std_vector_int"""
        return _teca_py.teca_tc_classify_get_region_ids(self)

    def clear_region_ids(self):
        r"""clear_region_ids(teca_tc_classify self)"""
        return _teca_py.teca_tc_classify_clear_region_ids(self)

    def get_number_of_region_names(self):
        r"""get_number_of_region_names(teca_tc_classify self) -> size_t"""
        return _teca_py.teca_tc_classify_get_number_of_region_names(self)

    def append_region_name(self, v):
        r"""
        append_region_name(teca_tc_classify self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_append_region_name(self, v)

    def set_region_name(self, i, v):
        r"""
        set_region_name(teca_tc_classify self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_set_region_name(self, i, v)

    def set_region_names(self, *args):
        r"""
        set_region_names(teca_tc_classify self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_region_names(teca_tc_classify self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_tc_classify_set_region_names(self, *args)

    def get_region_name(self, i):
        r"""
        get_region_name(teca_tc_classify self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_tc_classify_get_region_name(self, i)

    def get_region_names(self):
        r"""get_region_names(teca_tc_classify self) -> std_vector_string"""
        return _teca_py.teca_tc_classify_get_region_names(self)

    def clear_region_names(self):
        r"""clear_region_names(teca_tc_classify self)"""
        return _teca_py.teca_tc_classify_clear_region_names(self)

    def get_number_of_region_long_names(self):
        r"""get_number_of_region_long_names(teca_tc_classify self) -> size_t"""
        return _teca_py.teca_tc_classify_get_number_of_region_long_names(self)

    def append_region_long_name(self, v):
        r"""
        append_region_long_name(teca_tc_classify self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_append_region_long_name(self, v)

    def set_region_long_name(self, i, v):
        r"""
        set_region_long_name(teca_tc_classify self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_tc_classify_set_region_long_name(self, i, v)

    def set_region_long_names(self, *args):
        r"""
        set_region_long_names(teca_tc_classify self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_region_long_names(teca_tc_classify self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_tc_classify_set_region_long_names(self, *args)

    def get_region_long_name(self, i):
        r"""
        get_region_long_name(teca_tc_classify self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_tc_classify_get_region_long_name(self, i)

    def get_region_long_names(self):
        r"""get_region_long_names(teca_tc_classify self) -> std_vector_string"""
        return _teca_py.teca_tc_classify_get_region_long_names(self)

    def clear_region_long_names(self):
        r"""clear_region_long_names(teca_tc_classify self)"""
        return _teca_py.teca_tc_classify_clear_region_long_names(self)

# Register teca_tc_classify in _teca_py:
_teca_py.teca_tc_classify_swigregister(teca_tc_classify)

def teca_tc_classify_New():
    r"""teca_tc_classify_New() -> p_teca_tc_classify"""
    return _teca_py.teca_tc_classify_New()

class teca_dataset_diff(teca_algorithm):
    r"""Proxy of C++ teca_dataset_diff class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_dataset_diff"""
        return _teca_py.teca_dataset_diff_New()

    def get_class_name(self):
        r"""get_class_name(teca_dataset_diff self) -> char const *"""
        return _teca_py.teca_dataset_diff_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_dataset_diff

    def set_relative_tolerance(self, v):
        r"""
        set_relative_tolerance(teca_dataset_diff self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_dataset_diff_set_relative_tolerance(self, v)

    def get_relative_tolerance(self):
        r"""get_relative_tolerance(teca_dataset_diff self) -> double const &"""
        return _teca_py.teca_dataset_diff_get_relative_tolerance(self)

    def set_absolute_tolerance(self, v):
        r"""
        set_absolute_tolerance(teca_dataset_diff self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_dataset_diff_set_absolute_tolerance(self, v)

    def get_absolute_tolerance(self):
        r"""get_absolute_tolerance(teca_dataset_diff self) -> double const &"""
        return _teca_py.teca_dataset_diff_get_absolute_tolerance(self)

# Register teca_dataset_diff in _teca_py:
_teca_py.teca_dataset_diff_swigregister(teca_dataset_diff)

def teca_dataset_diff_New():
    r"""teca_dataset_diff_New() -> p_teca_dataset_diff"""
    return _teca_py.teca_dataset_diff_New()

class teca_table_region_mask(teca_algorithm):
    r"""Proxy of C++ teca_table_region_mask class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table_region_mask"""
        return _teca_py.teca_table_region_mask_New()

    def get_class_name(self):
        r"""get_class_name(teca_table_region_mask self) -> char const *"""
        return _teca_py.teca_table_region_mask_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_table_region_mask

    def set_x_coordinate_column(self, v):
        r"""
        set_x_coordinate_column(teca_table_region_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_region_mask_set_x_coordinate_column(self, v)

    def get_x_coordinate_column(self):
        r"""get_x_coordinate_column(teca_table_region_mask self) -> std::string const &"""
        return _teca_py.teca_table_region_mask_get_x_coordinate_column(self)

    def set_y_coordinate_column(self, v):
        r"""
        set_y_coordinate_column(teca_table_region_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_region_mask_set_y_coordinate_column(self, v)

    def get_y_coordinate_column(self):
        r"""get_y_coordinate_column(teca_table_region_mask self) -> std::string const &"""
        return _teca_py.teca_table_region_mask_get_y_coordinate_column(self)

    def set_result_column(self, v):
        r"""
        set_result_column(teca_table_region_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_region_mask_set_result_column(self, v)

    def get_result_column(self):
        r"""get_result_column(teca_table_region_mask self) -> std::string const &"""
        return _teca_py.teca_table_region_mask_get_result_column(self)

    def get_number_of_region_sizes(self):
        r"""get_number_of_region_sizes(teca_table_region_mask self) -> size_t"""
        return _teca_py.teca_table_region_mask_get_number_of_region_sizes(self)

    def append_region_size(self, v):
        r"""
        append_region_size(teca_table_region_mask self, unsigned long const & v)

        Parameters
        ----------
        v: unsigned long const &

        """
        return _teca_py.teca_table_region_mask_append_region_size(self, v)

    def set_region_size(self, i, v):
        r"""
        set_region_size(teca_table_region_mask self, size_t i, unsigned long const & v)

        Parameters
        ----------
        i: size_t
        v: unsigned long const &

        """
        return _teca_py.teca_table_region_mask_set_region_size(self, i, v)

    def set_region_sizes(self, *args):
        r"""
        set_region_sizes(teca_table_region_mask self, std_vector_ulong v)

        Parameters
        ----------
        v: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_region_sizes(teca_table_region_mask self, std::initializer_list< unsigned long > const && l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &&

        """
        return _teca_py.teca_table_region_mask_set_region_sizes(self, *args)

    def get_region_size(self, i):
        r"""
        get_region_size(teca_table_region_mask self, size_t i) -> unsigned long const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_table_region_mask_get_region_size(self, i)

    def get_region_sizes(self):
        r"""get_region_sizes(teca_table_region_mask self) -> std_vector_ulong"""
        return _teca_py.teca_table_region_mask_get_region_sizes(self)

    def clear_region_sizes(self):
        r"""clear_region_sizes(teca_table_region_mask self)"""
        return _teca_py.teca_table_region_mask_clear_region_sizes(self)

    def get_number_of_region_starts(self):
        r"""get_number_of_region_starts(teca_table_region_mask self) -> size_t"""
        return _teca_py.teca_table_region_mask_get_number_of_region_starts(self)

    def append_region_start(self, v):
        r"""
        append_region_start(teca_table_region_mask self, unsigned long const & v)

        Parameters
        ----------
        v: unsigned long const &

        """
        return _teca_py.teca_table_region_mask_append_region_start(self, v)

    def set_region_start(self, i, v):
        r"""
        set_region_start(teca_table_region_mask self, size_t i, unsigned long const & v)

        Parameters
        ----------
        i: size_t
        v: unsigned long const &

        """
        return _teca_py.teca_table_region_mask_set_region_start(self, i, v)

    def set_region_starts(self, *args):
        r"""
        set_region_starts(teca_table_region_mask self, std_vector_ulong v)

        Parameters
        ----------
        v: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_region_starts(teca_table_region_mask self, std::initializer_list< unsigned long > const && l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &&

        """
        return _teca_py.teca_table_region_mask_set_region_starts(self, *args)

    def get_region_start(self, i):
        r"""
        get_region_start(teca_table_region_mask self, size_t i) -> unsigned long const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_table_region_mask_get_region_start(self, i)

    def get_region_starts(self):
        r"""get_region_starts(teca_table_region_mask self) -> std_vector_ulong"""
        return _teca_py.teca_table_region_mask_get_region_starts(self)

    def clear_region_starts(self):
        r"""clear_region_starts(teca_table_region_mask self)"""
        return _teca_py.teca_table_region_mask_clear_region_starts(self)

    def get_number_of_region_x_coordinates(self):
        r"""get_number_of_region_x_coordinates(teca_table_region_mask self) -> size_t"""
        return _teca_py.teca_table_region_mask_get_number_of_region_x_coordinates(self)

    def append_region_x_coordinate(self, v):
        r"""
        append_region_x_coordinate(teca_table_region_mask self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_table_region_mask_append_region_x_coordinate(self, v)

    def set_region_x_coordinate(self, i, v):
        r"""
        set_region_x_coordinate(teca_table_region_mask self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_table_region_mask_set_region_x_coordinate(self, i, v)

    def set_region_x_coordinates(self, *args):
        r"""
        set_region_x_coordinates(teca_table_region_mask self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_region_x_coordinates(teca_table_region_mask self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_table_region_mask_set_region_x_coordinates(self, *args)

    def get_region_x_coordinate(self, i):
        r"""
        get_region_x_coordinate(teca_table_region_mask self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_table_region_mask_get_region_x_coordinate(self, i)

    def get_region_x_coordinates(self):
        r"""get_region_x_coordinates(teca_table_region_mask self) -> std_vector_double"""
        return _teca_py.teca_table_region_mask_get_region_x_coordinates(self)

    def clear_region_x_coordinates(self):
        r"""clear_region_x_coordinates(teca_table_region_mask self)"""
        return _teca_py.teca_table_region_mask_clear_region_x_coordinates(self)

    def get_number_of_region_y_coordinates(self):
        r"""get_number_of_region_y_coordinates(teca_table_region_mask self) -> size_t"""
        return _teca_py.teca_table_region_mask_get_number_of_region_y_coordinates(self)

    def append_region_y_coordinate(self, v):
        r"""
        append_region_y_coordinate(teca_table_region_mask self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_table_region_mask_append_region_y_coordinate(self, v)

    def set_region_y_coordinate(self, i, v):
        r"""
        set_region_y_coordinate(teca_table_region_mask self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_table_region_mask_set_region_y_coordinate(self, i, v)

    def set_region_y_coordinates(self, *args):
        r"""
        set_region_y_coordinates(teca_table_region_mask self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_region_y_coordinates(teca_table_region_mask self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_table_region_mask_set_region_y_coordinates(self, *args)

    def get_region_y_coordinate(self, i):
        r"""
        get_region_y_coordinate(teca_table_region_mask self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_table_region_mask_get_region_y_coordinate(self, i)

    def get_region_y_coordinates(self):
        r"""get_region_y_coordinates(teca_table_region_mask self) -> std_vector_double"""
        return _teca_py.teca_table_region_mask_get_region_y_coordinates(self)

    def clear_region_y_coordinates(self):
        r"""clear_region_y_coordinates(teca_table_region_mask self)"""
        return _teca_py.teca_table_region_mask_clear_region_y_coordinates(self)

    def clear_regions(self):
        r"""clear_regions(teca_table_region_mask self)"""
        return _teca_py.teca_table_region_mask_clear_regions(self)

    def load_cyclone_basin(self, name):
        r"""
        load_cyclone_basin(teca_table_region_mask self, std::string const & name) -> int

        Parameters
        ----------
        name: std::string const &

        """
        return _teca_py.teca_table_region_mask_load_cyclone_basin(self, name)

    def set_invert(self, v):
        r"""
        set_invert(teca_table_region_mask self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_table_region_mask_set_invert(self, v)

    def get_invert(self):
        r"""get_invert(teca_table_region_mask self) -> int const &"""
        return _teca_py.teca_table_region_mask_get_invert(self)

# Register teca_table_region_mask in _teca_py:
_teca_py.teca_table_region_mask_swigregister(teca_table_region_mask)

def teca_table_region_mask_New():
    r"""teca_table_region_mask_New() -> p_teca_table_region_mask"""
    return _teca_py.teca_table_region_mask_New()

import os
import sys
from socket import gethostname
import numpy as np

class teca_pytorch_algorithm(teca_python_algorithm):
    """
    A TECA algorithm that provides access to torch. To use this class, derive
    a new class from it and from your class:

    1. call set input_/output_variable. this tells the pytorch_algorithm
       which array to process and how to name the result.

    2. call set_model. this installs your torch model. Use load_state_dict
       to load state dict from the file system in parallel.

    3. override preprocess. The input numpy array is passed in.  return the
       array to send to torch after applying any preprocessing or transforms.

    4. override postprocess. the tensor returned from torch is passed. return a
       numpy array with the correct mesh dimensions

    5. Optionally override the usual teca_python_algorithm methods as needed.

    """
    def __init__(self):

        self.input_variable = None
        self.output_variable = None
        self.output_variable_atts = None

        self.model = None
        self.model_path = None
        self.device = 'cpu'
        self.n_threads = -1
        self.n_threads_max = 4
        self.verbose = 0
        self.initialized = False

    def set_verbose(self, val):
        """
        Set the verbosity of the run, higher values will result in more
        terminal output
        """
        self.verbose = val

    def set_input_variable(self, name):
        """
        set the name of the variable to be processed
        """
        self.input_variable = name

    def set_output_variable(self, name, atts):
        """
        set the variable name to store the results under and
        its attributes. Attributes are optional and may be None
        but are required for the CF writer to write the result
        to disk.
        """
        self.output_variable = name
        self.output_variable_atts = atts

    def set_thread_pool_size(self, val):
        """
        Set the number of threads in each rank's thread pool. Setting
        to a value of -1 will result in the thread pool being sized
        such that each thread is uniquely and exclusively bound to a
        specific core accounting for thread pools in other ranks
        running on the same node
        """
        self.n_threads = val

    def set_max_thread_pool_size(self, val):
        """
        Set aniupper bound on the thread pool size. This is applied
        during automatic thread pool sizing.
        """
        self.n_threads_max = val

    def set_target_device(self, val):
        """
        Set the target device. May be one of 'cpu' or 'cuda'.
        """
        if val == 'cpu' or val == 'cuda':
            self.device = val
        else:
            raise RuntimeError('Invalid target device %s' % (val))

    def set_model(self, model):
        """
        set PyTorch model
        """
        self.model = model

    def initialize(self):
        """
        determine the mapping to hardware for the current MPI layout.
        if device is cpu then this configures OpenMP such that its
        thread pools have 1 thread per physical core.
        this also imports torch. this must be called prior to using any
        torch api's etc.
        """
        event = teca_time_py_event('teca_pytorch_algorithm::initialize')

        if self.initialized:
            return

        rank = 0
        n_ranks = 1
        comm = self.get_communicator()
        if get_teca_has_mpi():
            rank = comm.Get_rank()
            n_ranks = comm.Get_size()

# tell OpenMP to report on what it does
        if self.verbose > 2:
            os.putenv('OMP_DISPLAY_ENV', 'true')

# check for user specified OpenMP environment configuration
        omp_num_threads = os.getenv('OMP_NUM_THREADS')
        omp_places = os.getenv('OMP_PLACES')
        omp_proc_bind = os.getenv('OMP_PROC_BIND')
        if omp_num_threads is not None or omp_places is not None \
            or omp_proc_bind is not None:

# at least one of the OpenMP environment control variables
# was set. we will now bail out and use those settings
            if rank == 0:
                sys.stderr.write('[0] STATUS: OpenMP environment override '
                                 'detected. OMP_NUM_THREADS=%s '
                                 'OMP_PROC_BIND=%s OMP_PLACES=%s\n' % (
                                 str(omp_num_threads), str(omp_proc_bind),
                                 str(omp_places)))
                sys.stderr.flush()

            n_threads = 0

        else:
# we will set the OpenMP control envirnment variables
# detemrmine the number of physical cores are available
# on this node, accounting for all MPI ranks scheduled to
# run here.
            try:
# let the user request a specific number of threads
                n_threads = self.n_threads

                n_threads, affinity, device_ids = \
                    thread_util.thread_parameters(comm, n_threads, 1, -1,
                                                  0 if self.verbose < 2 else 1)

# let the user request a bound on the number of threads
                if self.n_threads_max > 0:
                    n_threads = min(n_threads, self.n_threads_max)

# construct the places list explicitly
                places = '{%d}'%(affinity[0])
                i = 1
                while i < n_threads:
                    places += ',{%d}'%(affinity[i])
                    i += 1

                os.putenv('OMP_NUM_THREADS', '%d'%(n_threads))
                os.putenv('OMP_PROC_BIND', 'true')
                os.putenv('OMP_PLACES', places)

                if self.verbose:
                    sys.stderr.write('[%d] STATUS: %s : %d : OMP_NUM_THREADS=%d'
                                     ' OMP_PROC_BIND=true OMP_PLACES=%s\n' % (
                                     rank, gethostname(), rank, n_threads,
                                     places))
                    sys.stderr.flush()

            except(RuntimeError):
# we failed to detect the number of physical cores per MPI rank
                os.putenv('OMP_NUM_THREADS', '1')
                n_threads = 1

                sys.stderr.write('[0] STATUS: Failed to determine the '
                                 'number of physical cores available per '
                                 'MPI rank. OMP_NUM_THREADS=1\n')
                sys.stderr.flush()

        global torch
        import torch

        if n_threads:
# also tell torch explicitly
            torch.set_num_threads(n_threads)
            torch.set_num_interop_threads(n_threads)

        if 'cuda' in self.device:
# check that CUDA is present
            if torch.cuda.is_available():
# get the number of devices and assign them to ranks round
# robin
                n_dev = torch.cuda.device_count()
                dev_id = rank % n_dev

                if self.device == 'cuda':
# select the GPU that this rank will use.
                    self.device = 'cuda:%d' % (dev_id)

                if self.verbose:
                    dev_name = torch.cuda.get_device_name(self.device)

                    sys.stderr.write('[%d] STATUS: %s : %d : %d/%d : %s\n' % (
                                     rank, gethostname(), rank, dev_id, n_dev,
                                     dev_name))
                    sys.stderr.flush()
            else:
# fall back to OpenMP
                if rank == 0:
                   sys.stderr.write('[%d] WARNING: CUDA was requested but is not'
                                    ' available. OpenMP will be used.\n')
                   sys.stderr.flush()

                self.device = 'cpu'

        self.initialized = True

    def check_initialized(self):
        """
        verify that the user called initialize
        """
        if not self.initialized:
            raise RuntimeError('Not initialized! call '
                               'teca_pytroch_algorithm::initialize before '
                               'use to configure OpenMP and import torch')

    def load_state_dict(self, filename):
        """
        Load only the pytorch state_dict parameters file.
        """
        event = teca_time_py_event('teca_pytorch_algorithm::load_state_dict')

        self.check_initialized()

        comm = self.get_communicator()
        rank = comm.Get_rank()

        sd = None
        if rank == 0:
            sd = torch.load(filename, map_location='cpu')

        sd = comm.bcast(sd, root=0)

        return sd

    def load_model(self, filename, model):
        """
        Load the state dict named by 'filename' and install them into the
        passed model instance 'model'. This also moves the model on the current
        target device, and puts the model into inference mode.
        """
        event = teca_time_py_event('teca_pytorch_algorithm::load_model')

        self.check_initialized()

# load the model weights from disk
        model_state = self.load_state_dict(filename)

# install weights, send to target device, run in inference mode
        model.load_state_dict(model_state)
        model.to(self.device)
        model.eval()

        self.model = model

    def preprocess(self, in_array):
        """
        Override this to preprocess the passed in array before it is passed to
        torch. The passed array has the shape of the input/output mesh. the
        default implementation does nothing.
        """
        return in_array

    def postprocess(self, out_tensor):
        """
        Override this to postprocess the tensor data returned from torch.
        return the result as a numpy array. the return should be sized
        compatibly with the output mesh. The default implementation converts
        the tensor to a ndarray.
        """
        return out_tensor.numpy()

    def report(self, port, rep_in):
        """ TECA report override """
        event = teca_time_py_event('teca_pytorch_algorithm::report')

        self.check_initialized()

# check for required parameters.
        if self.model is None:
            raise RuntimeError('A torch model has not been specified')

        if self.input_variable is None:
            raise RuntimeError('input_variable has not been specified')

        if self.output_variable is None:
            raise RuntimeError('output_variable has not been specified')

# add the variable we proeduce to the report
        rep = teca_metadata(rep_in[0])

        if rep.has('variables'):
            rep.append('variables', self.output_variable)
        else:
            rep.set('variables', self.output_variable)

        attributes = rep["attributes"]
        attributes[self.output_variable] = self.output_variable_atts.to_metadata()
        rep["attributes"] = attributes

        return rep

    def request(self, port, md_in, req_in):
        """ TECA request override """
        event = teca_time_py_event('teca_pytorch_algorithm::request')

        self.check_initialized()

        req = teca_metadata(req_in)

        arrays = []
        if req.has('arrays'):
            arrays = req['arrays']
            if type(arrays) != list:
                arrays = [arrays]

# remove the arrays we produce
        try:
            arrays.remove(self.output_variable)
        except(Exception):
            pass

# add the arrays we need
        arrays.append(self.input_variable)

        req['arrays'] = arrays

        return [req]

    def execute(self, port, data_in, req):
        """ TECA execute override """
        event = teca_time_py_event('teca_pytorch_algorithm::execute')

        self.check_initialized()

# get the input array and reshape it to a 2D layout that's compatible
# with numpy and torch
        in_mesh = as_teca_cartesian_mesh(data_in[0])

        if in_mesh is None:
            raise RuntimeError('empty input, or not a mesh')

        arrays = in_mesh.get_point_arrays()
        in_va = arrays[self.input_variable].get_cpu_accessible()

        ext = in_mesh.get_extent()
        in_va.shape = (ext[3] - ext[2] + 1,
                       ext[1] - ext[0] + 1)

# let the derived class do model specific preprocessing
        in_array = self.preprocess(in_va)

# send to torch for processing
        in_tensor = torch.from_numpy(in_array).to(self.device)

        with torch.no_grad():
            out_tensor = self.model(in_tensor)

        if out_tensor is None:
            raise RuntimeError("Model failed to get predictions")

# let the derived class do model specific posprocessing
        out_array = self.postprocess(out_tensor)

# build the output
        out_mesh = teca_cartesian_mesh.New()
        out_mesh.shallow_copy(in_mesh)

        out_va = teca_variant_array.New(out_array)
        out_mesh.get_point_arrays().set(self.output_variable, out_va)

        return out_mesh

import numpy as np

class teca_deeplab_ar_detect(teca_pytorch_algorithm):
    """
    This algorithm detects Atmospheric Rivers using deep learning techniques
    derived from the DeepLabv3+ architecture. Given an input field of
    integrated vapor transport (IVT) magnitude, it calculates the probability
    of an AR event and stores it in a new scalar field named 'ar_probability'.
    """
    def __init__(self):
        super().__init__()

        self.set_input_variable("IVT")

        arp_atts = teca_array_attributes(
            teca_float_array_code.get(),
            teca_array_attributes.point_centering,
            0, 'unitless', 'posterior AR flag',
            'the posterior probability of the presence '
            'of an atmospheric river',
            None)

        self.set_output_variable("ar_probability", arp_atts)

    def set_ivt_variable(self, var):
        """
        set the name of the variable containing the integrated vapor
        transport(IVT) magnitude field.
        """
        self.set_input_variable(var)

    def load_model(self, filename):
        """
        Load model from file system. In MPI parallel runs rank 0
        loads the model file and broadcasts it to the other ranks.
        """
        event = teca_time_py_event('teca_deeplab_ar_detect::load_model')

# this creates OpenMP thread pools and imports torch
# it must be called *before* we import torch
        self.initialize()

# import our torch codes only now that torch has been initialized
        global teca_deeplab_ar_detect_internals
        from teca_deeplab_ar_detect_internals \
            import teca_deeplab_ar_detect_internals

# create an instance of the model
        model = teca_deeplab_ar_detect_internals.DeepLabv3_plus(
            n_classes=1, _print=False)

# load model weights from state on disk
        super().load_model(filename, model)

    def get_padding_sizes(self, div, dim):
        """
        given a divisor(div) and an input mesh dimension(dim)
        returns a tuple of values holding the number of values to
        add onto the low and high sides of the mesh to make the mesh
        dimension evely divisible by the divisor
        """
# ghost cells in the y direction
        target_shape = div * np.ceil(dim / div)
        target_shape_diff = target_shape - dim

        pad_low = int(np.ceil(target_shape_diff / 2.0))
        pad_high = int(np.floor(target_shape_diff / 2.0))

        return pad_low, pad_high

    def preprocess(self, in_array):
        """
        resize the array to be a multiple of 64 in the y direction and 128 in
        the x direction amd convert to 3 channel (i.e. RGB image like)
        """
        event = teca_time_py_event('teca_deeplab_ar_detect::preprocess')

        nx_in = in_array.shape[1]
        ny_in = in_array.shape[0]

# get the padding sizes to make the mesh evenly divisible by 64 in the
# x direction and 128 in the y direction
        ng_x0, ng_x1 = self.get_padding_sizes(64.0, nx_in)
        ng_y0, ng_y1 = self.get_padding_sizes(128.0, ny_in)

        nx_out = ng_x0 + ng_x1 + nx_in
        ny_out = ng_y0 + ng_y1 + ny_in

# allocate a new larger array
        out_array = np.zeros((1, 3, ny_out, nx_out), dtype=np.float32)

# copy the input array into the center
        out_array[:, :, ng_y0 : ng_y0 + ny_in,
                  ng_x0 : ng_x0 + nx_in] = in_array

# cache the padding info in order to extract the result
        self.ng_x0 = ng_x0
        self.ng_y0 = ng_y0
        self.nx_in = nx_in
        self.ny_in = ny_in

        return out_array

    def postprocess(self, out_tensor):
        """
        convert the tensor to a numpy array and extract the output data from
        the padded tensor. padding was added during preprocess.
        """
        event = teca_time_py_event('teca_deeplab_ar_detect::postprocess')

# normalize the output
        tmp = torch.sigmoid(out_tensor)

# move to the CPU if running on a GPU
        if self.device != 'cpu':
            tmp = tmp.to('cpu')

# convert from torch tensor to numpy ndarray
        out_array = tmp.numpy()

# extract the valid portion of the result
        out_array = out_array[:, :, self.ng_y0 : self.ng_y0 + self.ny_in,
                              self.ng_x0 : self.ng_x0 + self.nx_in]

        return out_array

import sys
import numpy as np

class teca_tc_activity(teca_python_algorithm):
    """
    Computes summary statistics, histograms on sorted, classified,
    TC trajectory output.
    """
    def __init__(self):
        self.basename = 'activity'
        self.dpi = 100
        self.interactive = False
        self.rel_axes = True
        self.color_map = None

    def __str__(self):
        return 'basename=%s, dpi=%d, interactive=%s, rel_axes=%s'%( \
            self.basename, self.dpi, str(self.interactive), str(self.rel_axes))

    def set_basename(self, basename):
        """
        All output files are prefixed by the basename. default 'stats'
        """
        self.basename = basename

    def set_dpi(self, dpi):
        """
        set the DPI resolution for image output. default 100
        """
        self.dpi = dpi

    def set_interactive(self, interactive):
        """
        plots are rendered to a an on screen window when enabled.
        when disabled plots are written directly to disk. default False
        """
        self.interactive = interactive

    def set_rel_axes(self, rel_axes):
        """
        When enabled y-axes in subplots are scaled to reflect the max
        value across all the plots making it easy to compare between plots.
        when disabled matplotlib's default scaling is used. default True
        """
        self.rel_axes = rel_axes

    def set_color_map(self, color_map):
        """
        set colormap to color plots by
        """
        self.color_map = color_map

    def execute(self, port, data_in, req):
        """
        expects the output of the teca_tc_classify algorithm
        generates a handful of histograms, summary statistics,
        and plots. returns summary table with counts of annual
        storms and their categories.
        """
        global plt
        global plt_mp
        global plt_tick

        import matplotlib.pyplot as plt
        import matplotlib.patches as plt_mp
        import matplotlib.ticker as plt_tick

# store matplotlib state we modify
        legend_frame_on_orig = plt.rcParams['legend.frameon']

# tweak matplotlib slightly
        plt.rcParams['figure.max_open_warning'] = 0
        plt.rcParams['legend.frameon'] = 1

# get the input table
        in_table = as_teca_table(data_in[0])
        if in_table is None:
# TODO if this is part of a parallel pipeline then
# only rank 0 should report an error.
            sys.stderr.write('ERROR: empty input, or not a table\n')
            return teca_table.New()

        time_units = in_table.get_time_units()

# get the columns of raw data
        year = in_table.get_column('year').as_array()
        region_id = in_table.get_column('region_id').as_array()
        region_name = in_table.get_column('region_name')
        region_long_name = in_table.get_column('region_long_name')
        start_y = in_table.get_column('start_y').as_array()

        ACE = in_table.get_column('ACE').as_array()
        PDI = in_table.get_column('PDI').as_array()

# organize the data by year month etc...
        regional_ACE = []
        regional_PDI = []

# get unique for use as indices etc
        uyear = sorted(set(year))
        n_year = len(uyear)
        ureg = sorted(set(zip(region_id, region_name, region_long_name)))

        self.accum_by_year_and_region(uyear, \
            ureg, year, region_id, start_y, ACE, regional_ACE)

        self.accum_by_year_and_region(uyear, \
            ureg, year, region_id, start_y, PDI, regional_PDI)

# now plot the organized data in various ways
        if self.color_map is None:
            self.color_map = plt.cm.jet

        self.plot_individual(uyear, \
             ureg, regional_ACE,'ACE', '$10^4 kn^2$')

        self.plot_individual(uyear, \
            ureg, regional_PDI, 'PDI', '$m^3 s^{-2}$')

        self.plot_cumulative(uyear, \
            ureg, regional_ACE, 'ACE', '$10^4 kn^2$')

        self.plot_cumulative(uyear, \
            ureg, regional_PDI, 'PDI', '$m^3 s^{-2}$')

        if (self.interactive):
            plt.show()

# restore matplot lib global state
        plt.rcParams['legend.frameon'] = legend_frame_on_orig

# send data downstream
        return in_table

    @staticmethod
    def two_digit_year_fmt(x, pos):
        q = int(x)
        q = q - q // 100 * 100
        return '%02d'%q

    @staticmethod
    def accum_by_year_and_region(uyear,ureg,year,region_id,start_y,var,var_out):
        for yy in uyear:
            yids = np.where(year==yy)
# break these down by year
            yvar = var[yids]
# break down by year and region
            rr = region_id[yids]
            max_reg = np.max(rr)
            tot = 0
            for r,n,l in ureg:
                rids = np.where(rr==r)
                rvar = yvar[rids]
                var_out.append(np.sum(rvar))
# south
            shids = np.where(start_y[yids] < 0.0)
            rvar = yvar[shids]
            var_out.append(np.sum(rvar))
# add northern, southern hemisphere and global regions
# north
            nhids = np.where(start_y[yids] >= 0.0)
            rvar = yvar[nhids]
            var_out.append(np.sum(rvar))
# global
            var_out.append(np.sum(yvar))

    def plot_individual(self, uyear, ureg, var, var_name, units):
        n_reg = len(ureg) + 3 # add 2 for n & s hemi, 1 for global
        n_year = len(uyear)

# now plot the organized data in various ways
        n_cols = 3
        wid = 2.5*n_cols

# plot regions over time
        reg_t_fig = plt.figure()

        rnms = list(zip(*ureg))[2]
        rnms += ('Southern','Northern','Global')

        n_plots = n_reg + 1
        n_left = n_plots % n_cols
        n_rows = n_plots // n_cols + (1 if n_left else 0)
        wid = 2.5*n_cols
        ht = 2.0*n_rows
        reg_t_fig.set_size_inches(wid, ht)

        max_y_reg = -1
        max_y_hem = -1
        q = 0
        while q < n_reg:
            if q < n_reg-3:
                max_y_reg = max(max_y_reg, np.max(var[q::n_reg]))
            elif q < n_reg-1:
                max_y_hem = max(max_y_hem, np.max(var[q::n_reg]))
            q += 1

        fill_col = [self.color_map(i) for i in np.linspace(0, 1, n_reg)]

        q = 0
        while q < n_reg:
            plt.subplot(n_rows, n_cols, q+1)
            ax = plt.gca()
            ax.grid(zorder=0)
            ax.xaxis.set_major_formatter(plt_tick.FuncFormatter( \
                teca_tc_activity.two_digit_year_fmt))

            plt.plot(uyear, var[q::n_reg],'-',color=fill_col[q],linewidth=2)
            ax.set_xticks(uyear[:] if n_year < 10 else uyear[::2])
            if len(uyear) > 1:
                ax.set_xlim([uyear[0], uyear[-1]])

            if self.rel_axes and q < n_reg - 1:
                ax.set_ylim([0, 1.05*(max_y_reg if q < n_reg - 3 else max_y_hem)])
            if (q%n_cols == 0):
                plt.ylabel(units, fontweight='normal', fontsize=10)
            if (q >= (n_reg - n_cols)):
                plt.xlabel('Year', fontweight='normal', fontsize=10)
            plt.title('%s'%(rnms[q]), fontweight='bold', fontsize=11)
            plt.grid(True)

            q += 1

        plt.suptitle('%s Individual Region'%(var_name), fontweight='bold')
        plt.subplots_adjust(wspace=0.35, hspace=0.6, top=0.92)

        plt.savefig('%s_%s_individual_%d.png'%( \
            self.basename, var_name, self.dpi), dpi=self.dpi)

        return

    def plot_cumulative(self, uyear, ureg, var, var_name, units):

        n_reg = len(ureg) + 3 # add 2 for n & s hemi, 1 for global
        n_year = len(uyear)

        rnms = list(zip(*ureg))[2]
        rnms += ('Southern','Northern','Global')

        fill_col = [self.color_map(i) for i in np.linspace(0, 1, n_reg)]

# stacked plot by region
        nhsh_stack_fig = plt.figure()
        ax = plt.gca()
        ax.xaxis.set_major_formatter(plt_tick.FuncFormatter( \
            teca_tc_activity.two_digit_year_fmt))

        base = np.zeros(n_year)
        q = 0
        while q < n_reg-3:
            vals = var[q::n_reg]
            bot = base
            top = bot + vals
            ax.fill_between(uyear, bot, top, facecolor=fill_col[q], alpha=0.75, zorder=3)
            ax.plot(uyear, top, color=fill_col[q], linewidth=2, label=rnms[q], zorder=3)
            base = top
            q += 1

        ax.set_xticks(uyear[:] if n_year < 15 else uyear[::2])
        if len(uyear) > 1:
            ax.set_xlim([uyear[0], uyear[-1]])
        plt.grid(True, zorder=0)

        ylim = ax.get_ylim()
        ax.set_ylim([0, ylim[1]])

        leg=plt.legend(loc=2, bbox_to_anchor=(1.0, 1.01))
        plt.subplots_adjust(right=0.78)

        plt.ylabel(units)
        plt.xlabel('Year')
        plt.title('%s by Region'%(var_name), fontweight='bold')

        plt.savefig('%s_%s_regions_%d.png'%( \
            self.basename, var_name, self.dpi), dpi=self.dpi)

# stacked plot of northern, southern hemispheres
        nhsh_stack_fig = plt.figure()
        ax = plt.gca()
        ax.xaxis.set_major_formatter(plt_tick.FuncFormatter( \
            teca_tc_activity.two_digit_year_fmt))

        base = np.zeros(n_year)
        q = n_reg-3
        while q < n_reg-1:
            vals = var[q::n_reg]
            bot = base
            top = bot + vals
            ax.fill_between(uyear, bot, top, facecolor=fill_col[q], alpha=0.75, zorder=3)
            ax.plot(uyear, top, color=fill_col[q], linewidth=2, label=rnms[q], zorder=3)
            base = top
            q += 1

        ax.set_xticks(uyear[:] if n_year < 15 else uyear[::2])
        if len(uyear) > 1:
            ax.set_xlim([uyear[0], uyear[-1]])
        plt.grid(True, zorder=0)

        ylim = ax.get_ylim()
        ax.set_ylim([0, ylim[1]])

        leg=plt.legend(loc=2, bbox_to_anchor=(1.0, 1.01))
        plt.subplots_adjust(right=0.78)

        plt.xlabel('Year')
        plt.ylabel(units)
        plt.title('%s by Hemisphere'%(var_name), fontweight='bold')

        plt.savefig('%s_%s_hemispheres_%d.png'%( \
            self.basename, var_name, self.dpi), dpi=self.dpi)

        return


import sys
import numpy as np

class teca_tc_stats(teca_python_algorithm):
    """
    Computes summary statistics, histograms on sorted, classified,
    TC trajectory output.
    """
    def __init__(self):
        self.basename = 'stats'
        self.dpi = 100
        self.interactive = False
        self.rel_axes = True

    def __str__(self):
        return 'basename=%s, dpi=%d, interactive=%s, rel_axes=%s'%( \
            self.basename, self.dpi, str(self.interactive), str(self.rel_axes))

    def set_basename(self, basename):
        """
        All output files are prefixed by the basename. default 'stats'
        """
        self.basename = basename

    def set_dpi(self, dpi):
        """
        set the DPI resolution for image output. default 100
        """
        self.dpi = dpi

    def set_interactive(self, interactive):
        """
        plots are rendered to a an on screen window when enabled.
        when disabled plots are written directly to disk. default False
        """
        self.interactive = interactive

    def set_rel_axes(self, rel_axes):
        """
        When enabled y-axes in subplots are scaled to reflect the max
        value across all the plots making it easy to compare between plots.
        when disabled matplotlib's default scaling is used. default True
        """
        self.rel_axes = rel_axes

    def execute(self, port, data_in, req):
        """
        expects the output of the teca_tc_classify algorithm
        generates a handful of histograms, summary statistics,
        and plots. returns summary table with counts of annual
        storms and their categories.
        """
        import matplotlib.pyplot as plt
        import matplotlib.patches as plt_mp

# store matplotlib state we modify
        legend_frame_on_orig = plt.rcParams['legend.frameon']

# tweak matplotlib slightly
        plt.rcParams['figure.max_open_warning'] = 0
        plt.rcParams['legend.frameon'] = 1

# get the input table
        in_table = as_teca_table(data_in[0])
        if in_table is None:
# TODO if this is part of a parallel pipeline then
# only rank 0 should report an error.
            sys.stderr.write('ERROR: empty input, or not a table\n')
            return teca_table.New()

        time_units = in_table.get_time_units()

# get the columns of raw data
        year = in_table.get_column('year').as_array()
        month = in_table.get_column('month').as_array()
        duration = in_table.get_column('duration').as_array()
        length = in_table.get_column('length').as_array()/1000.0
        category = in_table.get_column('category').as_array()
        region_id = in_table.get_column('region_id').as_array()
        region_name = in_table.get_column('region_name')
        region_long_name = in_table.get_column('region_long_name')
        wind = in_table.get_column('max_surface_wind').as_array()
        press = in_table.get_column('min_sea_level_pressure').as_array()
        start_y = in_table.get_column('start_y').as_array()
        ACE = in_table.get_column('ACE').as_array()

# organize the data by year month etc...
        annual_cat = []
        annual_count = []
        annual_wind = []
        annual_press = []
        annual_dur = []
        annual_len = []
        annual_ACE = []
        by_month = []
        by_region = []
        totals = []

# get unique for use as indices etc
        uyear = sorted(set(year))
        n_year = len(uyear)

        ureg = sorted(set(zip(region_id, region_name, region_long_name)))
        n_reg = len(ureg) + 3 # add 2 for n & s hemi, 1 for global

        for yy in uyear:
            yids = np.where(year==yy)
# break these down by year
            annual_count.append(len(yids[0]))
            annual_cat.append(category[yids])
            annual_wind.append(wind[yids])
            annual_press.append(press[yids])
            annual_dur.append(duration[yids])
            annual_len.append(length[yids])
            annual_ACE.append(ACE[yids])

# global totals
            tmp = [annual_count[-1]]
            for c in np.arange(0,6,1):
                cids = np.where(category[yids]==c)
                tmp.append(len(cids[0]))
            totals.append(tmp)

# break down by year, month, and category
            mm = month[yids]
            mnum = np.arange(1,13,1)
            monthly = []
            for m in mnum:
                mids = np.where(mm==m)
                mcats = category[yids][mids]
                cats = []
                for c in np.arange(0,6,1):
                    cids = np.where(mcats==c)
                    cats.append(len(cids[0]))
                monthly.append(cats)
            by_month.append(monthly)
# break down by year and region
            rr = region_id[yids]
            max_reg = np.max(rr)
            regional = []
            for r,n,l in ureg:
                rids = np.where(rr==r)
                rcats = category[yids][rids]
                cats = []
                for c in np.arange(0,6,1):
                    cids = np.where(rcats==c)
                    cats.append(len(cids[0]))
                regional.append(cats)
            by_region.append(regional)
# add north and south hemisphere regions
            hemi = []
            nhids = np.where(start_y[yids] >= 0.0)
            cats = category[yids][nhids]
            nhcats = []
            for c in np.arange(0,6,1):
                cids = np.where(cats==c)
                nhcats.append(len(cids[0]))
            by_region[-1].append(nhcats)
            shids = np.where(start_y[yids] < 0.0)
            cats = category[yids][shids]
            shcats = []
            for c in np.arange(0,6,1):
                cids = np.where(cats==c)
                shcats.append(len(cids[0]))
            by_region[-1].append(shcats)
# global break down
            gcats = []
            cats = category[yids]
            for c in np.arange(0,6,1):
                cids = np.where(cats==c)
                gcats.append(len(cids[0]))
            by_region[-1].append(gcats)

# dump annual totals
        summary = teca_table.New()
        summary.set_request_index('table_id', 0)
        summary.declare_columns(['year', 'total', 'cat 0', \
             'cat 1', 'cat 2', 'cat 3', 'cat 4', 'cat 5'], \
             ['i', 'ul', 'i', 'i', 'i', 'i', 'i', 'i'])
        q = 0
        while q < n_year:
            summary << int(uyear[q]) << int(totals[q][0]) \
                << int(totals[q][1]) << int(totals[q][2]) \
                << int(totals[q][3]) << int(totals[q][4]) \
                << int(totals[q][5]) << int(totals[q][6])
            q += 1
        f = open('%s_summary.csv'%(self.basename),'w')
        f.write(str(summary))
        f.close()

# now plot the organized data in various ways
        n_cols = 3
        n_plots = n_year + 1
        n_left = n_plots % n_cols
        n_rows = n_plots // n_cols + (1 if n_left else 0)
        wid = 2.5*n_cols
        ht = 2.0*n_rows

# use this color map for Saphir-Simpson scale
        red_cmap = ['#ffd2a3','#ffa749','#ff7c04', \
            '#ea4f00','#c92500','#a80300']

        red_cmap_pats = []
        q = 0
        while q < 6:
            red_cmap_pats.append( \
                plt_mp.Patch(color=red_cmap[q], label='cat %d'%(q)))
            q += 1

# plot annual saphir-simpson distribution
        page_no = 1
        cat_fig = plt.figure()
        cat_fig.set_size_inches(wid, ht)

        max_y = 0
        q = 0
        while q < n_year:
            max_y = max(max_y, len(np.where(annual_cat[q]==0)[0]))
            q += 1

        q = 0
        for yy in uyear:
            plt.subplot(n_rows, n_cols, q+1)
            ax = plt.gca()
            ax.grid(zorder=0)
            n,bins,pats = plt.hist(annual_cat[q], bins=np.arange(-0.5, 6.0, 1.0), \
                facecolor='steelblue', alpha=0.95, edgecolor='black', \
                linewidth=2, zorder=3)
            j = 0
            while j < 6:
                pats[j].set_facecolor(red_cmap[j])
                j += 1
            plt.xticks(np.arange(0,6,1))
            if self.rel_axes:
                ax.set_ylim([0, max_y*1.05])
            if (q%n_cols == 0):
                plt.ylabel('Count', fontweight='normal', fontsize=10)
            if (q >= (n_year - n_cols)):
                plt.xlabel('Category', fontweight='normal', fontsize=10)
            plt.title('%d'%(yy), fontweight='bold', fontsize=11)
            plt.grid(True)

            q += 1

        plt.subplot(n_rows, n_cols, q+1)
        ax = plt.gca()
        ax.grid(zorder=0)
        l = plt.legend(handles=red_cmap_pats, loc=2, bbox_to_anchor=(0.0, 1.0))
        plt.axis('off')

        plt.suptitle('Annual Saphir-Simpson Distribution', fontweight='bold')
        plt.subplots_adjust(hspace=0.4, top=0.92)

        plt.savefig('%s_annual_saphire_simpson_distribution_%d.png'%( \
            self.basename, page_no), dpi=self.dpi)

# break annual distributions down by month
        mos_fig = plt.figure()
        mos_fig.set_size_inches(wid, ht)

        max_y = 0
        q = 0
        while q < n_year:
            p = 0
            while p < 12:
                max_y = max(max_y, sum(by_month[q][p]))
                p += 1
            q += 1

        q = 0
        for yy in uyear:
            plt.subplot(n_rows, n_cols, q+1)
            ax = plt.gca()
            ax.grid(zorder=0)
# build up a stacked bar chart, each category is a layer
# copy that cat for all months into a temp array then add
# it to the plot at the right hight and color.
            mcts = by_month[q]
            bot = np.zeros((12))
            c = 0
            while c < 6:
                tmp = []
                p = 0
                while p < 12:
                    tmp.append(mcts[p][c])
                    p += 1
                plt.bar(np.arange(1,13,1)-0.375, tmp, width=0.75, bottom=bot, \
                    facecolor=red_cmap[c], edgecolor='k', linewidth=1, \
                    tick_label=['J','F','M','A','M','J','J','A','S','O','N','D'], \
                    zorder=3)
                bot += tmp
                c += 1

            plt.xticks(np.arange(1,13,1))
            if self.rel_axes:
                ax.set_ylim([0, 1.05*max_y])
            if (q%n_cols == 0):
                plt.ylabel('Count', fontweight='normal', fontsize=10)
            if (q >= (n_year - n_cols)):
                plt.xlabel('Month', fontweight='normal', fontsize=10)
            plt.title('%d'%(yy), fontweight='bold', fontsize=11)
            plt.grid(True)

            q += 1

        plt.subplot(n_rows, n_cols, q+1)
        ax = plt.gca()
        ax.grid(zorder=0)
        l = plt.legend(handles=red_cmap_pats, loc=2, bbox_to_anchor=(0.0, 1.0))
        plt.axis('off')

        plt.suptitle('Monthly Breakdown', fontweight='bold')
        plt.subplots_adjust(hspace=0.4, top=0.92)

        plt.savefig('%s_monthly_breakdown_%d.png'%( \
            self.basename, page_no), dpi=self.dpi)

# plot annual counts by region
        reg_fig = plt.figure()
        reg_fig.set_size_inches(wid, ht)

        rcds = list(zip(*ureg))[1]
        rcds += ('NH', 'SH', 'G')

        max_y = 0
        q = 0
        while q < n_year:
            j = 0
            while j < n_reg:
                max_y = max(max_y, sum(by_region[q][j]))
                j += 1
            q += 1

        q = 0
        for yy in uyear:
            plt.subplot(n_rows, n_cols, q+1)
            ax = plt.gca()
            ax.grid(zorder=0)
# build up a stacked bar chart, each category is a layer
# copy that cat for all months into a temp array then add
# it to the plot at the right height and color.
            rcnts = by_region[q]
            bot = np.zeros((n_reg))
            c = 0
            while c < 6:
                tmp = []
                p = 0
                while p < n_reg:
                    tmp.append(rcnts[p][c])
                    p += 1

                plt.bar(np.arange(0,n_reg,1)-0.375, tmp, width=0.75, bottom=bot, \
                    facecolor=red_cmap[c], edgecolor='k', linewidth=1, \
                    tick_label=rcds, \
                    zorder=3)

                bot += tmp
                c += 1

            plt.xticks(np.arange(0,n_reg,1), rotation='vertical')
            if self.rel_axes:
                ax.set_ylim([0, 1.05*max_y])
            if (q%n_cols == 0):
                plt.ylabel('Count', fontweight='normal', fontsize=10)
            if (q >= (n_year - n_cols)):
                plt.xlabel('Region', fontweight='normal', fontsize=10)
            plt.title('%d'%(yy), fontweight='bold', fontsize=11)
            plt.grid(True)

            q += 1

# add the color map legend
        plt.subplot(n_rows, n_cols, q+1)
        ax = plt.gca()
        ax.grid(zorder=0)
        l = plt.legend(handles=red_cmap_pats, loc=2, bbox_to_anchor=(0.0, 1.0))
        plt.axis('off')

        plt.suptitle('Regional Breakdown', fontweight='bold')
        plt.subplots_adjust(wspace=0.3, hspace=0.6, top=0.92)

        plt.savefig('%s_regional_break_down_%d.png'%( \
            self.basename, page_no), dpi=self.dpi)

# plot annual distributions
        dist_fig = plt.figure()

        wid = n_year*0.65
        dist_fig.set_size_inches(wid, 9.0)

        ax = plt.subplot(5,1,1)
        plt.boxplot(annual_wind, labels=uyear)
        plt.xlabel('Year')
        plt.ylabel('ms^-1')
        plt.title('Peak Instantaneous Wind', fontweight='bold')
        ax.get_yaxis().set_label_coords(-0.1,0.5)

        ax = plt.subplot(5,1,2)
        plt.boxplot(annual_press, labels=uyear)
        plt.xlabel('Year')
        plt.ylabel('Pa')
        plt.title('Min Instantaneous Pressure', fontweight='bold')
        ax.get_yaxis().set_label_coords(-0.1,0.5)

        ax = plt.subplot(5,1,3)
        plt.boxplot(annual_dur, labels=uyear)
        plt.xlabel('Year')
        plt.ylabel('%s'%(time_units.split()[0]))
        plt.title('Track Duration', fontweight='bold')
        ax.get_yaxis().set_label_coords(-0.1,0.5)

        ax = plt.subplot(5,1,4)
        plt.boxplot(annual_len, labels=uyear)
        plt.xlabel('Year')
        plt.ylabel('km')
        plt.title('Track Length', fontweight='bold')
        ax.get_yaxis().set_label_coords(-0.1,0.5)

        ax = plt.subplot(5,1,5)
#plt.axhline(82,color='k',linestyle='--',alpha=0.25)
        plt.boxplot(annual_ACE, labels=uyear)
        plt.xlabel('Year')
        plt.ylabel('10^4 kn^2')
        plt.title('ACE', fontweight='bold')
        ax.get_yaxis().set_label_coords(-0.1,0.5)

        plt.suptitle('Distributions', fontweight='bold')
        plt.subplots_adjust(hspace=0.72, top=0.93)

        plt.savefig('%s_distribution_%d.png'%( \
            self.basename, page_no), dpi=self.dpi)

# plot region over time
        reg_t_fig = plt.figure()

        rnms = list(zip(*ureg))[2]
        rnms += ('Northern', 'Southern', 'Global')

        tmp = np.array(uyear)
        tmp = tmp - tmp/100*100
        ynms = []
        for t in tmp:
            ynms.append('%02d'%t)

        n_plots = n_reg + 1
        n_left = n_plots % n_cols
        n_rows = n_plots // n_cols + (1 if n_left else 0)
        wid = 2.5*n_cols
        ht = 2.0*n_rows
        reg_t_fig.set_size_inches(wid, ht)

        reg_by_t = []
        p = 0
        while p < n_reg:
            reg = []
            q = 0
            while q < n_year:
                reg.append(by_region[q][p])
                q += 1
            reg_by_t.append(reg)
            p += 1

        max_y_reg = -1
        max_y_hem = -1
        q = 0
        while q < n_reg:
            dat = reg_by_t[q]
            p = 0
            while p < n_year:
                if q < n_reg-3:
                    max_y_reg = max(max_y_reg, sum(dat[p]))
                elif q < n_reg-1:
                    max_y_hem = max(max_y_hem, sum(dat[p]))
                p += 1
            q += 1

        q = 0
        while q < n_reg:
            dat = reg_by_t[q]

            plt.subplot(n_rows, n_cols, q+1)
            ax = plt.gca()
            ax.grid(zorder=0)

# build up a stacked bar chart, each category is a layer
# copy that cat for all months into a temp array then add
# it to the plot at the right height and color.
            bot = np.zeros((n_year))
            c = 0
            while c < 6:
                tmp = []
                p = 0
                while p < n_year:
                    tmp.append(dat[p][c])
                    p += 1

                plt.bar(np.arange(0,n_year,1)-0.375, tmp, width=0.75, bottom=bot, \
                    facecolor=red_cmap[c], edgecolor='k', linewidth=1, \
                    tick_label=ynms, \
                    zorder=3)

                bot += tmp
                c += 1

            plt.xticks(np.arange(0,n_year,1), rotation='vertical')
            if self.rel_axes and q < n_reg - 1:
                ax.set_ylim([0, 1.05*(max_y_reg if q < n_reg - 3 else max_y_hem)])
            if (q%n_cols == 0):
                plt.ylabel('Count', fontweight='normal', fontsize=10)
            if (q >= (n_reg - n_cols)):
                plt.xlabel('Year', fontweight='normal', fontsize=10)
            plt.title('%s'%(rnms[q]), fontweight='bold', fontsize=11)
            plt.grid(True)

            q += 1

        plt.suptitle('Regional Trend', fontweight='bold')
        plt.subplots_adjust(wspace=0.3, hspace=0.6, top=0.92)

# add the color map legend
        plt.subplot(n_rows, n_cols, q+1)
        ax = plt.gca()
        ax.grid(zorder=0)
        l = plt.legend(handles=red_cmap_pats, loc=2, bbox_to_anchor=(0.0, 1.0))
        plt.axis('off')

        plt.savefig('%s_regional_trend_%d.png'%( \
            self.basename, page_no), dpi=self.dpi)

        if (self.interactive):
            plt.show()

# restore matplotlib global state
        plt.rcParams['legend.frameon'] = legend_frame_on_orig

# send data downstream
        return summary


import sys
import numpy as np

class teca_tc_trajectory_scalars(teca_python_algorithm):
    """
    Computes summary statistics, histograms on sorted, classified,
    TC trajectory output.
    """
    def __init__(self):
        self.basename = 'tc_track'
        self.tex_file = ''
        self.tex = None
        self.dpi = 100
        self.interactive = False
        self.axes_equal = True
        self.plot_peak_radius = False

    def __str__(self):
        return 'basename=%s, dpi=%d, interactive=%s, rel_axes=%s'%( \
            self.basename, self.dpi, str(self.interactive), str(self.rel_axes))

    def set_basename(self, basename):
        """
        All output files are prefixed by the basename. default 'tc_track'
        """
        self.basename = basename

    def set_texture(self, file_name):
        """
        All output files are prefixed by the textrure. default 'tc_track'
        """
        self.tex_file = file_name

    def set_dpi(self, dpi):
        """
        set the DPI resolution for image output. default 100
        """
        self.dpi = dpi

    def set_interactive(self, interactive):
        """
        plots are rendered to an on screen window when enabled.
        when disabled plots are written directly to disk. default False
        """
        self.interactive = interactive

    def set_axes_equal(self, axes_equal):
        """
        controls the scaling of track plots. when off the aspect ratio
        is modified to best suit the window size. default True.
        """
        self.axes_equal = axes_equal

    def set_plot_peak_radius(self, plot_peak_radius):
        """
        when set peak wind radius is included in the plots. default False
        """
        self.plot_peak_radius = plot_peak_radius

    def execute(self, port, data_in, req):
        """
        expects the output of the teca_tc_classify algorithm
        generates a handful of histograms, summary statistics,
        and plots. returns summary table with counts of annual
        storms and their categories.
        """
#sys.stderr.write('teca_tc_trajectory_scalars::execute\n')

        import matplotlib.pyplot as plt
        import matplotlib.patches as plt_mp
        import matplotlib.image as plt_img
        import matplotlib.gridspec as plt_gridspec

# store matplotlib state we modify
        legend_frame_on_orig = plt.rcParams['legend.frameon']

# tweak matplotlib slightly
        plt.rcParams['figure.max_open_warning'] = 0
        plt.rcParams['legend.frameon'] = 1

# get the input table
        in_table = as_teca_table(data_in[0])
        if in_table is None:
# TODO if this is part of a parallel pipeline then
# only rank 0 should report an error.
            sys.stderr.write('ERROR: empty input, or not a table\n')
            return teca_table.New()

# use this color map for Saphir-Simpson scale
        red_cmap = ['#ffd2a3','#ffa749','#ff7c04', \
            '#ea4f00','#c92500','#a80300']

        km_per_deg_lat = 111

        time_units = in_table.get_time_units()

        time = in_table.get_column('time').as_array()
        step = in_table.get_column('step').as_array()
        track = in_table.get_column('track_id').as_array()

        lon = in_table.get_column('lon').as_array()
        lat = in_table.get_column('lat').as_array()

        year = in_table.get_column('year').as_array()
        month = in_table.get_column('month').as_array()
        day = in_table.get_column('day').as_array()
        hour = in_table.get_column('hour').as_array()
        minute = in_table.get_column('minute').as_array()

        wind = in_table.get_column('surface_wind').as_array()
        vort = in_table.get_column('850mb_vorticity').as_array()
        psl = in_table.get_column('sea_level_pressure').as_array()
        temp = in_table.get_column('core_temp').as_array()
        have_temp = in_table.get_column('have_core_temp').as_array()
        thick = in_table.get_column('thickness').as_array()
        have_thick = in_table.get_column('have_thickness').as_array()
        speed = in_table.get_column('storm_speed').as_array()

        wind_rad = []
        i = 0
        while i < 5:
            col_name = 'wind_radius_%d'%(i)
            if in_table.has_column(col_name):
                wind_rad.append(in_table.get_column(col_name).as_array())
            i += 1
        peak_rad = in_table.get_column('peak_radius').as_array() \
            if in_table.has_column('peak_radius') else None

# get the list of unique track ids, this is our loop index
        utrack = sorted(set(track))
        nutracks = len(utrack)

# load background image
        if (self.tex is None) and self.tex_file:
            self.tex = plt_img.imread(self.tex_file)

        for i in utrack:
#sys.stderr.write('processing track %d\n'%(i))
            sys.stderr.write('.')

            fig = plt.figure()
            fig.set_size_inches(10,9.75)

            ii = np.where(track == i)[0]

# get the scalar values for this storm
            lon_i = lon[ii]
            lat_i = lat[ii]
            wind_i = wind[ii]
            psl_i = psl[ii]
            vort_i = vort[ii]
            thick_i = thick[ii]
            temp_i = temp[ii]
            speed_i = speed[ii]/24.0

            wind_rad_i = []
            for col in wind_rad:
                wind_rad_i.append(col[ii])
            peak_rad_i = peak_rad[ii] if peak_rad is not None else None

# construct the title
            q = ii[0]
            r = ii[-1]

            t0 = time[q]
            t1 = time[r]

            s0 = step[q]
            s1 = step[r]

            Y0 = year[q]
            Y1 = year[r]

            M0 = month[q]
            M1 = month[r]

            D0 = day[q]
            D1 = day[r]

            h0 = hour[q]
            h1 = hour[r]

            m0 = minute[q]
            m1 = minute[r]

            tt = time[ii] - t0

            cat = teca_tc_saffir_simpson.classify_mps(float(np.max(wind_i)))

            plt.suptitle( \
                'Track %d, cat %d, steps %d - %d\n%d/%d/%d %d:%d:00 - %d/%d/%d %d:%d:00'%(\
                i, cat, s0, s1, Y0, M0, D0, h0, m0, Y1, M1, D1, h1, m1), \
                fontweight='bold')

# plot the scalars
            gs = plt_gridspec.GridSpec(5, 4)

            plt.subplot2grid((5,4),(0,0),colspan=2,rowspan=2)
# prepare the texture
            if self.tex is not None:
                ext = [np.min(lon_i), np.max(lon_i), np.min(lat_i), np.max(lat_i)]
                if self.axes_equal:
                    w = ext[1]-ext[0]
                    h = ext[3]-ext[2]
                    if w > h:
                        c = (ext[2] + ext[3])/2.0
                        w2 = w/2.0
                        ext[2] = c - w2
                        ext[3] = c + w2
                    else:
                        c = (ext[0] + ext[1])/2.0
                        h2 = h/2.0
                        ext[0] = c - h2
                        ext[1] = c + h2
                border_size = 0.15
                wrimax = 0 if peak_rad_i is None else \
                    max(0 if not self.plot_peak_radius else \
                        np.max(peak_rad_i), np.max(wind_rad_i[0]))
                dlon = max(wrimax, (ext[1] - ext[0])*border_size)
                dlat = max(wrimax, (ext[3] - ext[2])*border_size)
                ext[0] = max(ext[0] - dlon, 0.0)
                ext[1] = min(ext[1] + dlon, 360.0)
                ext[2] = max(ext[2] - dlat, -90.0)
                ext[3] = min(ext[3] + dlat, 90.0)
                i0 = int(self.tex.shape[1]/360.0*ext[0])
                i1 = int(self.tex.shape[1]/360.0*ext[1])
                j0 = int(-((ext[3] + 90.0)/180.0 - 1.0)*self.tex.shape[0])
                j1 = int(-((ext[2] + 90.0)/180.0 - 1.0)*self.tex.shape[0])
                plt.imshow(self.tex[j0:j1, i0:i1], extent=ext, aspect='auto')

            edge_color = '#ffff00' if self.tex is not None else 'b'

# plot the storm size
            if peak_rad_i is None:
                plt.plot(lon_i, lat_i, '.', linewidth=2, color=edge_color)
            else:
# compute track unit normals
                npts = len(ii)
                norm_x = np.zeros(npts)
                norm_y = np.zeros(npts)
                npts -= 1
                q = 1
                while q < npts:
                    norm_x[q] = lat_i[q+1] - lat_i[q-1]
                    norm_y[q] = -(lon_i[q+1] - lon_i[q-1])
                    nmag = np.sqrt(norm_x[q]**2 + norm_y[q]**2)
                    norm_x[q] = norm_x[q]/nmag
                    norm_y[q] = norm_y[q]/nmag
                    q += 1
# normal at first and last point on the track
                norm_x[0] = lat_i[1] - lat_i[0]
                norm_y[0] = -(lon_i[1] - lon_i[0])
                norm_x[0] = norm_x[0]/nmag
                norm_y[0] = norm_y[0]/nmag
                norm_x[npts] = lat_i[npts] - lat_i[npts-1]
                norm_y[npts] = -(lon_i[npts] - lon_i[npts-1])
                norm_x[npts] = norm_x[npts]/nmag
                norm_y[npts] = norm_y[npts]/nmag
# for each wind radius, render a polygon of width 2*wind
# centered on the track. have to break it into continuous
# segments
                nwri = len(wind_rad_i)
                q = nwri - 1
                while q >= 0:
                    self.plot_wind_rad(lon_i, lat_i, norm_x, norm_y, \
                        wind_rad_i[q], '-', edge_color if q==0 else red_cmap[q], \
                        2 if q==0 else 1, red_cmap[q], 0.98, q+4)
                    q -= 1
# plot the peak radius
                if (self.plot_peak_radius):
# peak radius is only valid if one of the other wind radii
# exist, zero out other values
                    kk = wind_rad_i[0] > 1.0e-6
                    q = 1
                    while q < nwri:
                        kk = np.logical_or(kk, wind_rad_i[q] > 1.0e-6)
                        q += 1
                    peak_rad_i[np.logical_not(kk)] = 0.0
                    self.plot_wind_rad(lon_i, lat_i, norm_x, norm_y, \
                        peak_rad_i, '--', (0,0,0,0.25), 1, 'none', 1.00, nwri+4)
# mark track
                marks = wind_rad_i[0] <= 1.0e-6
                q = 1
                while q < nwri:
                    marks = np.logical_and(marks, np.logical_not(wind_rad_i[q] > 1.0e-6))
                    q += 1
                kk = np.where(marks)[0]

                plt.plot(lon_i[kk], lat_i[kk], '.', linewidth=2, \
                    color=edge_color,zorder=10)

                plt.plot(lon_i[kk], lat_i[kk], '.', linewidth=1, \
                    color='k', zorder=10, markersize=1)

                marks = wind_rad_i[0] > 1.0e-6
                q = 1
                while q < nwri:
                    marks = np.logical_or(marks, wind_rad_i[q] > 1.0e-6)
                    q += 1
                kk = np.where(marks)[0]

                plt.plot(lon_i[kk], lat_i[kk], '.', linewidth=1, \
                    color='k', zorder=10, markersize=2, alpha=0.1)

# mark track start and end
            plt.plot(lon_i[0], lat_i[0], 'o', markersize=6, markeredgewidth=2, \
                color=edge_color, markerfacecolor='g',zorder=10)

            plt.plot(lon_i[-1], lat_i[-1], '^', markersize=6, markeredgewidth=2, \
                color=edge_color, markerfacecolor='r',zorder=10)

            plt.grid(True)
            plt.xlabel('deg lon')
            plt.ylabel('deg lat')
            plt.title('Track', fontweight='bold')

            plt.subplot2grid((5,4),(0,2),colspan=2)
            plt.plot(tt, psl_i, 'b-', linewidth=2)
            plt.grid(True)
            plt.xlabel('time (days)')
            plt.ylabel('millibars')
            plt.title('Sea Level Pressure', fontweight='bold')
            plt.xlim([0, tt[-1]])

            plt.subplot2grid((5,4),(1,2),colspan=2)
            plt.plot(tt, wind_i, 'b-', linewidth=2)
            plt.grid(True)
            plt.xlabel('time (days)')
            plt.ylabel('ms^-1')
            plt.title('Surface Wind', fontweight='bold')
            plt.xlim([0, tt[-1]])

            plt.subplot2grid((5,4),(2,0),colspan=2)
            plt.plot(tt, speed_i, 'b-', linewidth=2)
            plt.grid(True)
            plt.xlabel('time (days)')
            plt.ylabel('km d^-1')
            plt.title('Propagation Speed', fontweight='bold')
            plt.xlim([0, tt[-1]])

            plt.subplot2grid((5,4),(2,2),colspan=2)
            plt.plot(tt, vort_i, 'b-', linewidth=2)
            plt.grid(True)
            plt.xlabel('time (days)')
            plt.ylabel('s^-1')
            plt.title('Vorticity', fontweight='bold')
            plt.xlim([0, tt[-1]])

            plt.subplot2grid((5,4),(3,0),colspan=2)
            plt.plot(tt, thick_i, 'b-', linewidth=2)
            plt.grid(True)
            plt.xlabel('time (days)')
            plt.ylabel('meters')
            plt.title('Thickness', fontweight='bold')
            plt.xlim([0, tt[-1]])

            plt.subplot2grid((5,4),(3,2),colspan=2)
            plt.plot(tt, temp_i, 'b-', linewidth=2)
            plt.grid(True)
            plt.xlabel('time (days)')
            plt.ylabel('deg K')
            plt.title('Core Temperature', fontweight='bold')
            plt.xlim([0, tt[-1]])

            if peak_rad_i is not None:
                plt.subplot2grid((5,4),(4,0),colspan=2)
                q = len(wind_rad_i) - 1
                while q >= 0:
                    wr_i_q = km_per_deg_lat*wind_rad_i[q]
                    plt.fill_between(tt, 0, wr_i_q, color=red_cmap[q], alpha=0.9, zorder=q+3)
                    plt.plot(tt, wr_i_q, '-', linewidth=2, color=red_cmap[q], zorder=q+3)
                    q -= 1
                if (self.plot_peak_radius):
                    plt.plot(tt, km_per_deg_lat*peak_rad_i, 'k--', linewidth=1, zorder=10)
                plt.plot(tt, np.zeros(len(tt)), 'w-', linewidth=2, zorder=10)
                plt.grid(True)
                plt.xlabel('time (days)')
                plt.ylabel('radius (km)')
                plt.title('Storm Size', fontweight='bold')
                plt.xlim([0, tt[-1]])
                plt.ylim(ymin=0)

                plt.subplot2grid((5,4),(4,2))
                red_cmap_pats = []
                q = 0
                while q < 6:
                    red_cmap_pats.append( \
                        plt_mp.Patch(color=red_cmap[q], label='R%d'%(q)))
                    q += 1
                if (self.plot_peak_radius):
                    red_cmap_pats.append(plt_mp.Patch(color='k', label='RP'))
                l = plt.legend(handles=red_cmap_pats, loc=2, \
                        bbox_to_anchor=(-0.1, 1.0), borderaxespad=0.0, \
                        frameon=True, ncol=2)
                plt.axis('off')

            plt.subplots_adjust(left=0.065, right=0.98, \
                bottom=0.05, top=0.9, wspace=0.6, hspace=0.7)

            plt.savefig('%s_%06d.png'%(self.basename, i), dpi=self.dpi)
            if (not self.interactive):
                plt.close(fig)

        if (self.interactive):
            plt.show()

        out_table = teca_table.New()
        out_table.shallow_copy(in_table)
        return out_table

    @staticmethod
    def render_poly(x, y, norm_x, norm_y, rad, edge_style, \
        edge_color, edge_width, face_color, face_alpha, z):
        """draw a polygon centered at x,y with a normal width
           given by rad in the current axes"""
        import matplotlib.path as plt_path
        import matplotlib.patches as plt_patches
        import matplotlib.pyplot as plt
        wr_x = rad*norm_x
        wr_y = rad*norm_y
        nids = len(x)
        q = 0
        while q < nids-1:
# build node types for quad
            poly_node_types = np.ones(5, int)*plt_path.Path.LINETO
            poly_node_types[0] = plt_path.Path.MOVETO
            poly_node_types[4] = plt_path.Path.CLOSEPOLY
# build nodes for quad
            q0 = q
            q1 = q+2
            xx = x[q0:q1]
            yy = y[q0:q1]
            wwx = wr_x[q0:q1]
            wwy = wr_y[q0:q1]
            poly_nodes = np.zeros((5, 2))
            poly_nodes[0:2,0] = xx + wwx
            poly_nodes[0:2,1] = yy + wwy
            poly_nodes[2:4,0] = (xx - wwx)[::-1]
            poly_nodes[2:4,1] = (yy - wwy)[::-1]
            poly_nodes[4,0] = poly_nodes[0,0]
            poly_nodes[4,1] = poly_nodes[0,1]
# build types for for edge
            edge_node_types = np.array([plt_path.Path.MOVETO, plt_path.Path.LINETO, \
                plt_path.Path.LINETO if q == nids-2 else plt_path.Path.MOVETO, \
                plt_path.Path.LINETO, plt_path.Path.LINETO if q == 0 else \
                plt_path.Path.MOVETO])
# check for bow-tie configuration which occurs with sharp
# curvature. NOTE: this tests for self intersection,
# another case that we should handle is intersection
# with preceding geometry.
# the order of nodes relative to my diagram is p0,p2,p3,p1
            p0x = poly_nodes[0,0]
            p0y = poly_nodes[0,1]
            p2x = poly_nodes[1,0]
            p2y = poly_nodes[1,1]
            p3x = poly_nodes[2,0]
            p3y = poly_nodes[2,1]
            p1x = poly_nodes[3,0]
            p1y = poly_nodes[3,1]
# a = p0 - p2
# b = p1 - p0
# c = p3 - p2
            ax = p0x - p2x
            ay = p0y - p2y
            bx = p1x - p0x
            by = p1y - p0y
            cx = p3x - p2x
            cy = p3y - p2y
# D = -cx*by + cy*bx
# D1 = -ax*by + ay*bx
# D2 = cx*ay - cy*ax
            D = -cx*by + cy*bx
#D1 = -ax*by + ay*bx
            D2 = cx*ay - cy*ax
# t0 = D2/D
# t1 = D1/D
            if (abs(D) > 1e-6):
                t0 = D2/D
#t1 = D1/D
# pi = p0 + (p1 - p0)t0
                pix = p0x + bx*t0
                piy = p0y + by*t0
# pi = p2 + (p3 - p2)t1
#pi1x = p2x + cx*t1
#pi1y = p2y + cy*t1
                if ((t0 > 0.0) and (t0 <= 0.5)):
# track is turning right
# convert path to triangle, with p0 removed and p2 replaced with pi
                    poly_nodes[1,:] = [pix, piy]
                    poly_node_types[1] = plt_path.Path.MOVETO

                    edge_node_types[1] = plt_path.Path.MOVETO
#sys.stderr.write('%d sharp right! t0=%f %f,%f\n'%(q,t0,pix,piy))
#plt.plot([pix],[piy],'gx')
                if ((t0 > 0.5) and (t0 < 1.0)):
# track is turning left
# convert path to triangle, remove p1, replace p3 with pi
                    poly_nodes[2,:] = [pix, piy]
                    poly_nodes[3,:] = poly_nodes[0,:]
                    poly_node_types[3] = plt_path.Path.CLOSEPOLY

                    edge_node_types[3] = edge_node_types[4]
                    edge_node_types[4] = plt_path.Path.MOVETO
#sys.stderr.write('%d sharp left! t0=%f %f,%f\n'%(q,t0,pix,piy))
#plt.plot([pix],[piy],'r+')
# patch is added to the current axes, constructed from a path
# which is constructed from nodes and node types
            plt.gca().add_patch(plt_patches.PathPatch( \
                plt_path.Path(poly_nodes, poly_node_types), \
                facecolor=face_color, edgecolor=face_color, \
                linewidth=1, alpha=face_alpha, zorder=z))

            plt.gca().add_patch(plt_patches.PathPatch( \
                plt_path.Path(poly_nodes, edge_node_types), \
                facecolor='none', edgecolor=edge_color, \
                linestyle=edge_style, linewidth=edge_width, \
                alpha=1.0, zorder=z))

            q += 1
        return

    @staticmethod
    def render_poly_simple(x, y, norm_x, norm_y, rad, edge_color, \
        edge_width, face_color, face_alpha, z):
        """draw a polygon centered at x,y with a normal width
           given by rad in the current axes"""
        import matplotlib.path as plt_path
        import matplotlib.patches as plt_patches
        import matplotlib.pyplot as plt
        wr_x = rad*norm_x
        wr_y = rad*norm_y
        nids = len(x)
        q = 0
        while q < nids-1:
# build node types
            node_types = np.ones(5, int)*plt_path.Path.LINETO
            node_types[0] = plt_path.Path.MOVETO
            node_types[4] = plt_path.Path.CLOSEPOLY
# build nodes
            q0 = q
            q1 = q+2
            xx = x[q0:q1]
            yy = y[q0:q1]
            wwx = wr_x[q0:q1]
            wwy = wr_y[q0:q1]
            nodes = np.zeros((5, 2))
            nodes[0:2,0] = xx - wwx
            nodes[0:2,1] = yy - wwy
            nodes[2:4,0] = (xx + wwx)[::-1]
            nodes[2:4,1] = (yy + wwy)[::-1]
            nodes[4,0] = nodes[0,0]
            nodes[4,1] = nodes[0,1]
# patch is added to the current axes, constructed from a path
# which is constructed from nodes and node types
            plt.gca().add_patch(plt_patches.PathPatch( \
                plt_path.Path(nodes, node_types), \
                facecolor=face_color, \
                linewidth=1, alpha=0.5, zorder=z))
            q += 1
        return

    @staticmethod
    def render_poly_convex(x, y, norm_x, norm_y, rad, edge_style, \
        edge_color, edge_width, face_color, face_alpha, z):
        """draw a polygon centered at x,y with a normal width
           given by rad in the current axes"""
        import matplotlib.path as plt_path
        import matplotlib.patches as plt_patches
        import matplotlib.pyplot as plt
        nids = len(x)
        if nids:
            nids2 = 2*nids
            nnodes = nids2+1
# build node types
            node_types = np.ones(nnodes, int)*plt_path.Path.LINETO
            node_types[0] = plt_path.Path.MOVETO
            node_types[nids2] = plt_path.Path.CLOSEPOLY
# build nodes
            nodes = np.zeros((nnodes, 2))
            wr_x = rad*norm_x
            wr_y = rad*norm_y
            nodes[0:nids,0] = x - wr_x
            nodes[0:nids,1] = y - wr_y
            nodes[nids:nids2,0] = x[::-1] + wr_x[::-1]
            nodes[nids:nids2,1] = y[::-1] + wr_y[::-1]
            nodes[nids2,0] = nodes[0,0]
            nodes[nids2,1] = nodes[0,1]
# patch is added to the current axes, constructed from a path
# which is constructed from nodes and node types
            plt.gca().add_patch(plt_patches.PathPatch( \
                plt_path.Path(nodes, node_types), \
                facecolor=face_color, edgecolor=edge_color, \
                linestyle=edge_style, linewidth=edge_width, \
                alpha=face_alpha, zorder=z))
        return

    def plot_wind_rad(self, x, y, norm_x, norm_y, wind_rad, \
        edge_style, edge_color, edge_width, face_color, face_alpha, z):
        """slpit the track into continuous segements where wind rad is defined
           and render them on the current axes as close polygons/polylines"""
        nqq = len(x)-1
        p0 = -1
        qq = 0
        while qq <= nqq:
            if (p0 < 0) and (wind_rad[qq] > 1e-6):
# found start of poly
                p0 = qq
            elif (p0 >= 0) and ((wind_rad[qq] < 1e-6) or (qq == nqq)):
# found end of poly, render it
                p1 = qq+1 if qq == nqq else qq
                if p1 - p0 > 1:
                    self.render_poly(x[p0:p1], y[p0:p1], \
                        norm_x[p0:p1], norm_y[p0:p1], wind_rad[p0:p1], \
                        edge_style, edge_color, edge_width, face_color, \
                        face_alpha, z)

                p0 = -1
            qq += 1


import sys
import numpy as np

class teca_tc_wind_radii_stats(teca_python_algorithm):
    """
    Computes statistics using track wind radii
    """
    def __init__(self):
        self.basename = 'stats'
        self.dpi = 100
        self.interactive = False
        self.wind_column = 'surface_wind'
        self.output_prefix = ''

    def __str__(self):
        return 'basename=%s, dpi=%d, interactive=%s, rel_axes=%s'%( \
            self.basename, self.dpi, str(self.interactive), str(self.rel_axes))

    def set_basename(self, basename):
        """
        All output files are prefixed by the basename. default 'stats'
        """
        self.basename = basename

    def set_dpi(self, dpi):
        """
        set the DPI resolution for image output. default 100
        """
        self.dpi = dpi

    def set_interactive(self, interactive):
        """
        plots are rendered to a an on screen window when enabled.
        when disabled plots are written directly to disk. default False
        """
        self.interactive = interactive

    def set_wind_column(self, wind_column):
        """
        set the name of the column to obtain wind speed from
        """
        self.wind_column = wind_column

    def set_output_prefix(self, output_prefix):
        """
        set the path to prepend to output files
        """
        self.output_prefix = output_prefix

    def execute(self, port, data_in, req):
        """
        expects a table with track data containing wind radii computed
        along each point of the track. produces statistical plots showing
        the global distribution of wind radii.
        """
        track_table = as_teca_table(data_in[0])

# plot stats
        import matplotlib.pyplot as plt
        import matplotlib.patches as plt_mp
        from matplotlib.colors import LogNorm

        red_cmap = ['#ffd2a3','#ffa749','#ff7c04', \
            '#ea4f00','#c92500','#a80300']

        km_per_deg_lat = 111
        km_s_per_m_hr = 3.6

        fig = plt.figure(figsize=(9.25,6.75),dpi=self.dpi)

# scatter
        plt.subplot(331)

        if not track_table.has_column(self.wind_column):
            sys.stderr.write('ERROR: track table missing %s\n'%(self.wind_column))
            sys.exit(-1)


        year = track_table.get_column('year').as_array()
        month = track_table.get_column('month').as_array()
        day = track_table.get_column('day').as_array()

        ws = km_s_per_m_hr*track_table.get_column(self.wind_column).as_array()

        wr = []
        nwr = 0
        while track_table.has_column('wind_radius_%d'%(nwr)):
            wr.append(km_per_deg_lat*track_table.get_column('wind_radius_%d'%(nwr)).as_array())
            nwr += 1

        i = 0
        while i < nwr:
            wc = teca_tc_saffir_simpson.get_upper_bound_kmph(i-1)
            wri = wr[i]
            ii = np.where(wri > 0.0)
            plt.scatter(wri[ii], ws[ii], c=red_cmap[i], alpha=0.25, marker='.', zorder=3+i)
            i += 1

        plt.ylabel('Wind speed (km/hr)', fontweight='normal', fontsize=10)
        plt.title('R0 - R5 vs Wind speed', fontweight='bold', fontsize=11)
        plt.grid(True)
        ax = plt.gca()
        ax.set_xlim([0.0, 6.0*km_per_deg_lat])

# all
        plt.subplot(332)
        i = 0
        while i < nwr:
            wc = teca_tc_saffir_simpson.get_upper_bound_kmph(i-1)
            wri = wr[i]
            n,bins,pats = plt.hist(wri[np.where(wri > 0.0)], 32, range=[0,6.0*km_per_deg_lat], \
                facecolor=red_cmap[i], alpha=0.95, edgecolor='black', \
                linewidth=2, zorder=3+i)
            i += 1
        plt.ylabel('Number', fontweight='normal', fontsize=10)
        plt.title('All R0 - R5', fontweight='bold', fontsize=11)
        plt.grid(True)
        ax = plt.gca()
        ax.set_xlim([0.0, 6.0*km_per_deg_lat])

# r0 - r5
        i = 0
        while i < nwr:
            plt.subplot(333+i)
            wc = teca_tc_saffir_simpson.get_upper_bound_kmph(i-1)
            wri = wr[i]
            wrii=wri[np.where(wri > 0.0)]
            n,bins,pats = plt.hist(wrii, 32, \
                facecolor=red_cmap[i], alpha=1.00, edgecolor='black', \
                linewidth=2, zorder=3)
            if ((i % 3) == 1):
                plt.ylabel('Number', fontweight='normal', fontsize=10)
            if (i >= 3):
                plt.xlabel('Radius (km)', fontweight='normal', fontsize=10)
            plt.title('R%d (%0.1f km/hr)'%(i,wc), fontweight='bold', fontsize=11)
            plt.grid(True)
            ax = plt.gca()
            try:
                ax.set_xlim([np.min(wrii), np.max(wrii)])
            except:
                pass
            i += 1

# legend
        plt.subplot(339)
        red_cmap_pats = []
        q = 0
        while q < nwr:
            red_cmap_pats.append( \
                plt_mp.Patch(color=red_cmap[q], label='R%d'%(q)))
            q += 1
        l = plt.legend(handles=red_cmap_pats, loc=2, bbox_to_anchor=(-0.1, 1.0), fancybox=True)
        plt.axis('off')


        plt.suptitle('Wind Radii %s/%d/%d - %s/%d/%d'%(month[0],day[0],year[0], \
            month[-1],day[-1],year[-1]), fontweight='bold', fontsize=12)
        plt.subplots_adjust(hspace=0.35, wspace=0.35, top=0.90)

        plt.savefig(self.output_prefix + 'wind_radii_stats.png')

        fig = plt.figure(figsize=(7.5,4.0),dpi=100)
# peak radius
        pr = km_per_deg_lat*track_table.get_column('peak_radius').as_array()
# peak radius is only valid if one of the other wind radii
# exist
        kk = wr[0] > 1.0e-6
        q = 1
        while q < nwr:
            kk = np.logical_or(kk, wr[q] > 1.0e-6)
            q += 1
        pr = pr[kk]

        plt.subplot(121)
        n,bins,pats = plt.hist(pr[np.where(pr > 0.0)], 24, \
            facecolor='steelblue', alpha=0.95, edgecolor='black', \
            linewidth=2, zorder=3)
        plt.ylabel('Number', fontweight='normal', fontsize=10)
        plt.xlabel('Radius (km)', fontweight='normal', fontsize=10)
        plt.title('RP (radius at peak wind)', fontweight='bold', fontsize=11)
        plt.grid(True)
        ax = plt.gca()
        ax.set_xlim([0.0, np.max(pr)])

# scatter
        plt.subplot(122)
        ii = np.where(pr > 0.0)
        cnts,xe,ye,im = plt.hist2d(pr[ii], ws[ii], bins=24, norm=LogNorm(), zorder=2)
        plt.ylabel('Wind speed (km/hr)', fontweight='normal', fontsize=10)
        plt.xlabel('Radius (km)', fontweight='normal', fontsize=10)
        plt.title('RP vs Wind speed', fontweight='bold', fontsize=11)
        plt.grid(True)
        ax = plt.gca()
        ax.set_xlim([0.0, np.max(pr)])

        fig.subplots_adjust(right=0.85)
        cbar_ax = fig.add_axes([0.88, 0.35, 0.05, 0.5])
        fig.colorbar(im, cax=cbar_ax)

        plt.suptitle('Wind Radii %s/%d/%d - %s/%d/%d'%(month[0],day[0],year[0], \
            month[-1],day[-1],year[-1]), fontweight='bold', fontsize=12)
        plt.subplots_adjust(hspace=0.3, wspace=0.3,  top=0.85)

        plt.savefig(self.output_prefix + 'peak_radius_stats.png')

        if self.interactive:
            plt.show()

# send data downstream
        return track_table

class teca_binary_segmentation(teca_algorithm):
    r"""Proxy of C++ teca_binary_segmentation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_binary_segmentation"""
        return _teca_py.teca_binary_segmentation_New()

    def get_class_name(self):
        r"""get_class_name(teca_binary_segmentation self) -> char const *"""
        return _teca_py.teca_binary_segmentation_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_binary_segmentation

    def set_segmentation_variable(self, v):
        r"""
        set_segmentation_variable(teca_binary_segmentation self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_binary_segmentation_set_segmentation_variable(self, v)

    def get_segmentation_variable(self):
        r"""get_segmentation_variable(teca_binary_segmentation self) -> std::string const &"""
        return _teca_py.teca_binary_segmentation_get_segmentation_variable(self)

    def set_segmentation_variable_attributes(self, v):
        r"""
        set_segmentation_variable_attributes(teca_binary_segmentation self, teca_metadata v)

        Parameters
        ----------
        v: teca_metadata const &

        """
        return _teca_py.teca_binary_segmentation_set_segmentation_variable_attributes(self, v)

    def get_segmentation_variable_attributes(self):
        r"""get_segmentation_variable_attributes(teca_binary_segmentation self) -> teca_metadata"""
        return _teca_py.teca_binary_segmentation_get_segmentation_variable_attributes(self)

    def set_threshold_variable(self, v):
        r"""
        set_threshold_variable(teca_binary_segmentation self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_binary_segmentation_set_threshold_variable(self, v)

    def get_threshold_variable(self):
        r"""get_threshold_variable(teca_binary_segmentation self) -> std::string const &"""
        return _teca_py.teca_binary_segmentation_get_threshold_variable(self)

    def set_low_threshold_value(self, v):
        r"""
        set_low_threshold_value(teca_binary_segmentation self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_binary_segmentation_set_low_threshold_value(self, v)

    def get_low_threshold_value(self):
        r"""get_low_threshold_value(teca_binary_segmentation self) -> double const &"""
        return _teca_py.teca_binary_segmentation_get_low_threshold_value(self)

    def set_high_threshold_value(self, v):
        r"""
        set_high_threshold_value(teca_binary_segmentation self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_binary_segmentation_set_high_threshold_value(self, v)

    def get_high_threshold_value(self):
        r"""get_high_threshold_value(teca_binary_segmentation self) -> double const &"""
        return _teca_py.teca_binary_segmentation_get_high_threshold_value(self)
    BY_VALUE = _teca_py.teca_binary_segmentation_BY_VALUE
    
    BY_PERCENTILE = _teca_py.teca_binary_segmentation_BY_PERCENTILE
    

    def set_threshold_mode(self, v):
        r"""
        set_threshold_mode(teca_binary_segmentation self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_binary_segmentation_set_threshold_mode(self, v)

    def get_threshold_mode(self):
        r"""get_threshold_mode(teca_binary_segmentation self) -> int const &"""
        return _teca_py.teca_binary_segmentation_get_threshold_mode(self)

    def set_threshold_by_percentile(self):
        r"""set_threshold_by_percentile(teca_binary_segmentation self)"""
        return _teca_py.teca_binary_segmentation_set_threshold_by_percentile(self)

    def set_threshold_by_value(self):
        r"""set_threshold_by_value(teca_binary_segmentation self)"""
        return _teca_py.teca_binary_segmentation_set_threshold_by_value(self)

# Register teca_binary_segmentation in _teca_py:
_teca_py.teca_binary_segmentation_swigregister(teca_binary_segmentation)

def teca_binary_segmentation_New():
    r"""teca_binary_segmentation_New() -> p_teca_binary_segmentation"""
    return _teca_py.teca_binary_segmentation_New()

class teca_apply_binary_mask(teca_algorithm):
    r"""Proxy of C++ teca_apply_binary_mask class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_apply_binary_mask"""
        return _teca_py.teca_apply_binary_mask_New()

    def get_class_name(self):
        r"""get_class_name(teca_apply_binary_mask self) -> char const *"""
        return _teca_py.teca_apply_binary_mask_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_apply_binary_mask

    def set_mask_variable(self, v):
        r"""
        set_mask_variable(teca_apply_binary_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_apply_binary_mask_set_mask_variable(self, v)

    def get_mask_variable(self):
        r"""get_mask_variable(teca_apply_binary_mask self) -> std::string const &"""
        return _teca_py.teca_apply_binary_mask_get_mask_variable(self)

    def get_number_of_masked_variables(self):
        r"""get_number_of_masked_variables(teca_apply_binary_mask self) -> size_t"""
        return _teca_py.teca_apply_binary_mask_get_number_of_masked_variables(self)

    def append_masked_variable(self, v):
        r"""
        append_masked_variable(teca_apply_binary_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_apply_binary_mask_append_masked_variable(self, v)

    def set_masked_variable(self, i, v):
        r"""
        set_masked_variable(teca_apply_binary_mask self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_apply_binary_mask_set_masked_variable(self, i, v)

    def set_masked_variables(self, *args):
        r"""
        set_masked_variables(teca_apply_binary_mask self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_masked_variables(teca_apply_binary_mask self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_apply_binary_mask_set_masked_variables(self, *args)

    def get_masked_variable(self, i):
        r"""
        get_masked_variable(teca_apply_binary_mask self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_apply_binary_mask_get_masked_variable(self, i)

    def get_masked_variables(self):
        r"""get_masked_variables(teca_apply_binary_mask self) -> std_vector_string"""
        return _teca_py.teca_apply_binary_mask_get_masked_variables(self)

    def clear_masked_variables(self):
        r"""clear_masked_variables(teca_apply_binary_mask self)"""
        return _teca_py.teca_apply_binary_mask_clear_masked_variables(self)

    def set_output_variable_prefix(self, v):
        r"""
        set_output_variable_prefix(teca_apply_binary_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_apply_binary_mask_set_output_variable_prefix(self, v)

    def get_output_variable_prefix(self):
        r"""get_output_variable_prefix(teca_apply_binary_mask self) -> std::string const &"""
        return _teca_py.teca_apply_binary_mask_get_output_variable_prefix(self)

    def get_output_variable_names(self, names):
        r"""
        get_output_variable_names(teca_apply_binary_mask self, std_vector_string names)

        Parameters
        ----------
        names: std::vector< std::string,std::allocator< std::string > > &

        """
        return _teca_py.teca_apply_binary_mask_get_output_variable_names(self, names)

# Register teca_apply_binary_mask in _teca_py:
_teca_py.teca_apply_binary_mask_swigregister(teca_apply_binary_mask)

def teca_apply_binary_mask_New():
    r"""teca_apply_binary_mask_New() -> p_teca_apply_binary_mask"""
    return _teca_py.teca_apply_binary_mask_New()

class teca_tc_saffir_simpson(object):
    r"""Proxy of C++ teca_tc_saffir_simpson class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def classify_mps(w):
        r"""
        classify_mps(double w) -> int

        Parameters
        ----------
        w: double

        """
        return _teca_py.teca_tc_saffir_simpson_classify_mps(w)

    @staticmethod
    def get_lower_bound_mps(c):
        r"""
        get_lower_bound_mps(int c) -> double

        Parameters
        ----------
        c: int

        """
        return _teca_py.teca_tc_saffir_simpson_get_lower_bound_mps(c)

    @staticmethod
    def get_upper_bound_mps(c):
        r"""
        get_upper_bound_mps(int c) -> double

        Parameters
        ----------
        c: int

        """
        return _teca_py.teca_tc_saffir_simpson_get_upper_bound_mps(c)

    @staticmethod
    def classify_kmph(w):
        r"""
        classify_kmph(double w) -> int

        Parameters
        ----------
        w: double

        """
        return _teca_py.teca_tc_saffir_simpson_classify_kmph(w)

    @staticmethod
    def get_lower_bound_kmph(c):
        r"""
        get_lower_bound_kmph(int c) -> double

        Parameters
        ----------
        c: int

        """
        return _teca_py.teca_tc_saffir_simpson_get_lower_bound_kmph(c)

    @staticmethod
    def get_upper_bound_kmph(c):
        r"""
        get_upper_bound_kmph(int c) -> double

        Parameters
        ----------
        c: int

        """
        return _teca_py.teca_tc_saffir_simpson_get_upper_bound_kmph(c)

    def __init__(self):
        r"""__init__(teca_tc_saffir_simpson self) -> teca_tc_saffir_simpson"""
        _teca_py.teca_tc_saffir_simpson_swiginit(self, _teca_py.new_teca_tc_saffir_simpson())
    __swig_destroy__ = _teca_py.delete_teca_tc_saffir_simpson

# Register teca_tc_saffir_simpson in _teca_py:
_teca_py.teca_tc_saffir_simpson_swigregister(teca_tc_saffir_simpson)

def teca_tc_saffir_simpson_classify_mps(w):
    r"""
    teca_tc_saffir_simpson_classify_mps(double w) -> int

    Parameters
    ----------
    w: double

    """
    return _teca_py.teca_tc_saffir_simpson_classify_mps(w)

def teca_tc_saffir_simpson_get_lower_bound_mps(c):
    r"""
    teca_tc_saffir_simpson_get_lower_bound_mps(int c) -> double

    Parameters
    ----------
    c: int

    """
    return _teca_py.teca_tc_saffir_simpson_get_lower_bound_mps(c)

def teca_tc_saffir_simpson_get_upper_bound_mps(c):
    r"""
    teca_tc_saffir_simpson_get_upper_bound_mps(int c) -> double

    Parameters
    ----------
    c: int

    """
    return _teca_py.teca_tc_saffir_simpson_get_upper_bound_mps(c)

def teca_tc_saffir_simpson_classify_kmph(w):
    r"""
    teca_tc_saffir_simpson_classify_kmph(double w) -> int

    Parameters
    ----------
    w: double

    """
    return _teca_py.teca_tc_saffir_simpson_classify_kmph(w)

def teca_tc_saffir_simpson_get_lower_bound_kmph(c):
    r"""
    teca_tc_saffir_simpson_get_lower_bound_kmph(int c) -> double

    Parameters
    ----------
    c: int

    """
    return _teca_py.teca_tc_saffir_simpson_get_lower_bound_kmph(c)

def teca_tc_saffir_simpson_get_upper_bound_kmph(c):
    r"""
    teca_tc_saffir_simpson_get_upper_bound_kmph(int c) -> double

    Parameters
    ----------
    c: int

    """
    return _teca_py.teca_tc_saffir_simpson_get_upper_bound_kmph(c)

class teca_evaluate_expression(teca_algorithm):
    r"""Proxy of C++ teca_evaluate_expression class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_evaluate_expression"""
        return _teca_py.teca_evaluate_expression_New()

    def get_class_name(self):
        r"""get_class_name(teca_evaluate_expression self) -> char const *"""
        return _teca_py.teca_evaluate_expression_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_evaluate_expression

    def set_expression(self, expr):
        r"""
        set_expression(teca_evaluate_expression self, std::string const & expr)

        Parameters
        ----------
        expr: std::string const &

        """
        return _teca_py.teca_evaluate_expression_set_expression(self, expr)

    def get_expression(self):
        r"""get_expression(teca_evaluate_expression self) -> std::string"""
        return _teca_py.teca_evaluate_expression_get_expression(self)

    def set_result_variable(self, v):
        r"""
        set_result_variable(teca_evaluate_expression self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_evaluate_expression_set_result_variable(self, v)

    def get_result_variable(self):
        r"""get_result_variable(teca_evaluate_expression self) -> std::string const &"""
        return _teca_py.teca_evaluate_expression_get_result_variable(self)

    def set_remove_dependent_variables(self, v):
        r"""
        set_remove_dependent_variables(teca_evaluate_expression self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_evaluate_expression_set_remove_dependent_variables(self, v)

    def get_remove_dependent_variables(self):
        r"""get_remove_dependent_variables(teca_evaluate_expression self) -> int const &"""
        return _teca_py.teca_evaluate_expression_get_remove_dependent_variables(self)

# Register teca_evaluate_expression in _teca_py:
_teca_py.teca_evaluate_expression_swigregister(teca_evaluate_expression)

def teca_evaluate_expression_New():
    r"""teca_evaluate_expression_New() -> p_teca_evaluate_expression"""
    return _teca_py.teca_evaluate_expression_New()

class teca_table_remove_rows(teca_algorithm):
    r"""Proxy of C++ teca_table_remove_rows class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table_remove_rows"""
        return _teca_py.teca_table_remove_rows_New()

    def get_class_name(self):
        r"""get_class_name(teca_table_remove_rows self) -> char const *"""
        return _teca_py.teca_table_remove_rows_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_table_remove_rows

    def set_mask_expression(self, expr):
        r"""
        set_mask_expression(teca_table_remove_rows self, std::string const & expr)

        Parameters
        ----------
        expr: std::string const &

        """
        return _teca_py.teca_table_remove_rows_set_mask_expression(self, expr)

    def get_mask_expression(self):
        r"""get_mask_expression(teca_table_remove_rows self) -> std::string"""
        return _teca_py.teca_table_remove_rows_get_mask_expression(self)

    def set_remove_dependent_variables(self, v):
        r"""
        set_remove_dependent_variables(teca_table_remove_rows self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_table_remove_rows_set_remove_dependent_variables(self, v)

    def get_remove_dependent_variables(self):
        r"""get_remove_dependent_variables(teca_table_remove_rows self) -> int const &"""
        return _teca_py.teca_table_remove_rows_get_remove_dependent_variables(self)

# Register teca_table_remove_rows in _teca_py:
_teca_py.teca_table_remove_rows_swigregister(teca_table_remove_rows)

def teca_table_remove_rows_New():
    r"""teca_table_remove_rows_New() -> p_teca_table_remove_rows"""
    return _teca_py.teca_table_remove_rows_New()

class teca_tc_wind_radii(teca_algorithm):
    r"""Proxy of C++ teca_tc_wind_radii class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_tc_wind_radii"""
        return _teca_py.teca_tc_wind_radii_New()

    def get_class_name(self):
        r"""get_class_name(teca_tc_wind_radii self) -> char const *"""
        return _teca_py.teca_tc_wind_radii_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_tc_wind_radii

    def set_storm_id_column(self, v):
        r"""
        set_storm_id_column(teca_tc_wind_radii self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_wind_radii_set_storm_id_column(self, v)

    def get_storm_id_column(self):
        r"""get_storm_id_column(teca_tc_wind_radii self) -> std::string const &"""
        return _teca_py.teca_tc_wind_radii_get_storm_id_column(self)

    def set_storm_x_coordinate_column(self, v):
        r"""
        set_storm_x_coordinate_column(teca_tc_wind_radii self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_wind_radii_set_storm_x_coordinate_column(self, v)

    def get_storm_x_coordinate_column(self):
        r"""get_storm_x_coordinate_column(teca_tc_wind_radii self) -> std::string const &"""
        return _teca_py.teca_tc_wind_radii_get_storm_x_coordinate_column(self)

    def set_storm_y_coordinate_column(self, v):
        r"""
        set_storm_y_coordinate_column(teca_tc_wind_radii self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_wind_radii_set_storm_y_coordinate_column(self, v)

    def get_storm_y_coordinate_column(self):
        r"""get_storm_y_coordinate_column(teca_tc_wind_radii self) -> std::string const &"""
        return _teca_py.teca_tc_wind_radii_get_storm_y_coordinate_column(self)

    def set_storm_wind_speed_column(self, v):
        r"""
        set_storm_wind_speed_column(teca_tc_wind_radii self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_wind_radii_set_storm_wind_speed_column(self, v)

    def get_storm_wind_speed_column(self):
        r"""get_storm_wind_speed_column(teca_tc_wind_radii self) -> std::string const &"""
        return _teca_py.teca_tc_wind_radii_get_storm_wind_speed_column(self)

    def set_storm_time_column(self, v):
        r"""
        set_storm_time_column(teca_tc_wind_radii self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_wind_radii_set_storm_time_column(self, v)

    def get_storm_time_column(self):
        r"""get_storm_time_column(teca_tc_wind_radii self) -> std::string const &"""
        return _teca_py.teca_tc_wind_radii_get_storm_time_column(self)

    def set_wind_u_variable(self, v):
        r"""
        set_wind_u_variable(teca_tc_wind_radii self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_wind_radii_set_wind_u_variable(self, v)

    def get_wind_u_variable(self):
        r"""get_wind_u_variable(teca_tc_wind_radii self) -> std::string const &"""
        return _teca_py.teca_tc_wind_radii_get_wind_u_variable(self)

    def set_wind_v_variable(self, v):
        r"""
        set_wind_v_variable(teca_tc_wind_radii self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_tc_wind_radii_set_wind_v_variable(self, v)

    def get_wind_v_variable(self):
        r"""get_wind_v_variable(teca_tc_wind_radii self) -> std::string const &"""
        return _teca_py.teca_tc_wind_radii_get_wind_v_variable(self)

    def set_search_radius(self, v):
        r"""
        set_search_radius(teca_tc_wind_radii self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_wind_radii_set_search_radius(self, v)

    def get_search_radius(self):
        r"""get_search_radius(teca_tc_wind_radii self) -> double const &"""
        return _teca_py.teca_tc_wind_radii_get_search_radius(self)

    def set_core_radius(self, v):
        r"""
        set_core_radius(teca_tc_wind_radii self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_wind_radii_set_core_radius(self, v)

    def get_core_radius(self):
        r"""get_core_radius(teca_tc_wind_radii self) -> double const &"""
        return _teca_py.teca_tc_wind_radii_get_core_radius(self)

    def set_number_of_radial_bins(self, v):
        r"""
        set_number_of_radial_bins(teca_tc_wind_radii self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_tc_wind_radii_set_number_of_radial_bins(self, v)

    def get_number_of_radial_bins(self):
        r"""get_number_of_radial_bins(teca_tc_wind_radii self) -> int const &"""
        return _teca_py.teca_tc_wind_radii_get_number_of_radial_bins(self)

    def get_number_of_critical_wind_speeds(self):
        r"""get_number_of_critical_wind_speeds(teca_tc_wind_radii self) -> size_t"""
        return _teca_py.teca_tc_wind_radii_get_number_of_critical_wind_speeds(self)

    def append_critical_wind_speed(self, v):
        r"""
        append_critical_wind_speed(teca_tc_wind_radii self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_tc_wind_radii_append_critical_wind_speed(self, v)

    def set_critical_wind_speed(self, i, v):
        r"""
        set_critical_wind_speed(teca_tc_wind_radii self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_tc_wind_radii_set_critical_wind_speed(self, i, v)

    def set_critical_wind_speeds(self, *args):
        r"""
        set_critical_wind_speeds(teca_tc_wind_radii self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_critical_wind_speeds(teca_tc_wind_radii self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_tc_wind_radii_set_critical_wind_speeds(self, *args)

    def get_critical_wind_speed(self, i):
        r"""
        get_critical_wind_speed(teca_tc_wind_radii self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_tc_wind_radii_get_critical_wind_speed(self, i)

    def get_critical_wind_speeds(self):
        r"""get_critical_wind_speeds(teca_tc_wind_radii self) -> std_vector_double"""
        return _teca_py.teca_tc_wind_radii_get_critical_wind_speeds(self)

    def clear_critical_wind_speeds(self):
        r"""clear_critical_wind_speeds(teca_tc_wind_radii self)"""
        return _teca_py.teca_tc_wind_radii_clear_critical_wind_speeds(self)
    PROFILE_MAX = _teca_py.teca_tc_wind_radii_PROFILE_MAX
    
    PROFILE_AVERAGE = _teca_py.teca_tc_wind_radii_PROFILE_AVERAGE
    

    def set_profile_type(self, v):
        r"""
        set_profile_type(teca_tc_wind_radii self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_tc_wind_radii_set_profile_type(self, v)

    def get_profile_type(self):
        r"""get_profile_type(teca_tc_wind_radii self) -> int const &"""
        return _teca_py.teca_tc_wind_radii_get_profile_type(self)

    def set_input_connection(self, id, port):
        r"""
        set_input_connection(teca_tc_wind_radii self, unsigned int id, teca_output_port_type port)

        Parameters
        ----------
        id: unsigned int
        port: teca_algorithm_output_port const &

        """
        return _teca_py.teca_tc_wind_radii_set_input_connection(self, id, port)

# Register teca_tc_wind_radii in _teca_py:
_teca_py.teca_tc_wind_radii_swigregister(teca_tc_wind_radii)

def teca_tc_wind_radii_New():
    r"""teca_tc_wind_radii_New() -> p_teca_tc_wind_radii"""
    return _teca_py.teca_tc_wind_radii_New()

class teca_2d_component_area(teca_algorithm):
    r"""Proxy of C++ teca_2d_component_area class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_2d_component_area"""
        return _teca_py.teca_2d_component_area_New()

    def get_class_name(self):
        r"""get_class_name(teca_2d_component_area self) -> char const *"""
        return _teca_py.teca_2d_component_area_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_2d_component_area

    def set_component_variable(self, v):
        r"""
        set_component_variable(teca_2d_component_area self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_2d_component_area_set_component_variable(self, v)

    def get_component_variable(self):
        r"""get_component_variable(teca_2d_component_area self) -> std::string const &"""
        return _teca_py.teca_2d_component_area_get_component_variable(self)

    def set_contiguous_component_ids(self, v):
        r"""
        set_contiguous_component_ids(teca_2d_component_area self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_2d_component_area_set_contiguous_component_ids(self, v)

    def get_contiguous_component_ids(self):
        r"""get_contiguous_component_ids(teca_2d_component_area self) -> int const &"""
        return _teca_py.teca_2d_component_area_get_contiguous_component_ids(self)

    def set_background_id(self, v):
        r"""
        set_background_id(teca_2d_component_area self, long const & v)

        Parameters
        ----------
        v: long const &

        """
        return _teca_py.teca_2d_component_area_set_background_id(self, v)

    def get_background_id(self):
        r"""get_background_id(teca_2d_component_area self) -> long const &"""
        return _teca_py.teca_2d_component_area_get_background_id(self)

# Register teca_2d_component_area in _teca_py:
_teca_py.teca_2d_component_area_swigregister(teca_2d_component_area)

def teca_2d_component_area_New():
    r"""teca_2d_component_area_New() -> p_teca_2d_component_area"""
    return _teca_py.teca_2d_component_area_New()

class teca_latitude_damper(teca_algorithm):
    r"""Proxy of C++ teca_latitude_damper class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_latitude_damper"""
        return _teca_py.teca_latitude_damper_New()

    def get_class_name(self):
        r"""get_class_name(teca_latitude_damper self) -> char const *"""
        return _teca_py.teca_latitude_damper_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_latitude_damper

    def set_center(self, v):
        r"""
        set_center(teca_latitude_damper self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_latitude_damper_set_center(self, v)

    def get_center(self):
        r"""get_center(teca_latitude_damper self) -> double const &"""
        return _teca_py.teca_latitude_damper_get_center(self)

    def set_half_width_at_half_max(self, v):
        r"""
        set_half_width_at_half_max(teca_latitude_damper self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_latitude_damper_set_half_width_at_half_max(self, v)

    def get_half_width_at_half_max(self):
        r"""get_half_width_at_half_max(teca_latitude_damper self) -> double const &"""
        return _teca_py.teca_latitude_damper_get_half_width_at_half_max(self)

    def get_number_of_damped_variables(self):
        r"""get_number_of_damped_variables(teca_latitude_damper self) -> size_t"""
        return _teca_py.teca_latitude_damper_get_number_of_damped_variables(self)

    def append_damped_variable(self, v):
        r"""
        append_damped_variable(teca_latitude_damper self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_latitude_damper_append_damped_variable(self, v)

    def set_damped_variable(self, i, v):
        r"""
        set_damped_variable(teca_latitude_damper self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_latitude_damper_set_damped_variable(self, i, v)

    def set_damped_variables(self, *args):
        r"""
        set_damped_variables(teca_latitude_damper self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_damped_variables(teca_latitude_damper self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_latitude_damper_set_damped_variables(self, *args)

    def get_damped_variable(self, i):
        r"""
        get_damped_variable(teca_latitude_damper self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_latitude_damper_get_damped_variable(self, i)

    def get_damped_variables(self):
        r"""get_damped_variables(teca_latitude_damper self) -> std_vector_string"""
        return _teca_py.teca_latitude_damper_get_damped_variables(self)

    def clear_damped_variables(self):
        r"""clear_damped_variables(teca_latitude_damper self)"""
        return _teca_py.teca_latitude_damper_clear_damped_variables(self)

    def set_variable_postfix(self, v):
        r"""
        set_variable_postfix(teca_latitude_damper self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_latitude_damper_set_variable_postfix(self, v)

    def get_variable_postfix(self):
        r"""get_variable_postfix(teca_latitude_damper self) -> std::string const &"""
        return _teca_py.teca_latitude_damper_get_variable_postfix(self)

# Register teca_latitude_damper in _teca_py:
_teca_py.teca_latitude_damper_swigregister(teca_latitude_damper)

def teca_latitude_damper_New():
    r"""teca_latitude_damper_New() -> p_teca_latitude_damper"""
    return _teca_py.teca_latitude_damper_New()

class teca_bayesian_ar_detect(teca_algorithm):
    r"""Proxy of C++ teca_bayesian_ar_detect class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_bayesian_ar_detect"""
        return _teca_py.teca_bayesian_ar_detect_New()

    def get_class_name(self):
        r"""get_class_name(teca_bayesian_ar_detect self) -> char const *"""
        return _teca_py.teca_bayesian_ar_detect_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_bayesian_ar_detect

    def set_ivt_variable(self, v):
        r"""
        set_ivt_variable(teca_bayesian_ar_detect self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_bayesian_ar_detect_set_ivt_variable(self, v)

    def get_ivt_variable(self):
        r"""get_ivt_variable(teca_bayesian_ar_detect self) -> std::string const &"""
        return _teca_py.teca_bayesian_ar_detect_get_ivt_variable(self)

    def set_min_ivt_variable(self, v):
        r"""
        set_min_ivt_variable(teca_bayesian_ar_detect self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_bayesian_ar_detect_set_min_ivt_variable(self, v)

    def get_min_ivt_variable(self):
        r"""get_min_ivt_variable(teca_bayesian_ar_detect self) -> std::string const &"""
        return _teca_py.teca_bayesian_ar_detect_get_min_ivt_variable(self)

    def set_min_component_area_variable(self, v):
        r"""
        set_min_component_area_variable(teca_bayesian_ar_detect self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_bayesian_ar_detect_set_min_component_area_variable(self, v)

    def get_min_component_area_variable(self):
        r"""get_min_component_area_variable(teca_bayesian_ar_detect self) -> std::string const &"""
        return _teca_py.teca_bayesian_ar_detect_get_min_component_area_variable(self)

    def set_hwhm_latitude_variable(self, v):
        r"""
        set_hwhm_latitude_variable(teca_bayesian_ar_detect self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_bayesian_ar_detect_set_hwhm_latitude_variable(self, v)

    def get_hwhm_latitude_variable(self):
        r"""get_hwhm_latitude_variable(teca_bayesian_ar_detect self) -> std::string const &"""
        return _teca_py.teca_bayesian_ar_detect_get_hwhm_latitude_variable(self)

    def set_ar_probability_variable(self, v):
        r"""
        set_ar_probability_variable(teca_bayesian_ar_detect self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_bayesian_ar_detect_set_ar_probability_variable(self, v)

    def get_ar_probability_variable(self):
        r"""get_ar_probability_variable(teca_bayesian_ar_detect self) -> std::string const &"""
        return _teca_py.teca_bayesian_ar_detect_get_ar_probability_variable(self)

    def set_thread_pool_size(self, n_threads):
        r"""
        set_thread_pool_size(teca_bayesian_ar_detect self, int n_threads)

        Parameters
        ----------
        n_threads: int

        """
        return _teca_py.teca_bayesian_ar_detect_set_thread_pool_size(self, n_threads)

    def get_thread_pool_size(self):
        r"""get_thread_pool_size(teca_bayesian_ar_detect self) -> unsigned int"""
        return _teca_py.teca_bayesian_ar_detect_get_thread_pool_size(self)

    def set_input_connection(self, id, port):
        r"""
        set_input_connection(teca_bayesian_ar_detect self, unsigned int id, teca_output_port_type port)

        Parameters
        ----------
        id: unsigned int
        port: teca_algorithm_output_port const &

        """
        return _teca_py.teca_bayesian_ar_detect_set_input_connection(self, id, port)

# Register teca_bayesian_ar_detect in _teca_py:
_teca_py.teca_bayesian_ar_detect_swigregister(teca_bayesian_ar_detect)

def teca_bayesian_ar_detect_New():
    r"""teca_bayesian_ar_detect_New() -> p_teca_bayesian_ar_detect"""
    return _teca_py.teca_bayesian_ar_detect_New()

class teca_bayesian_ar_detect_parameters(teca_algorithm):
    r"""Proxy of C++ teca_bayesian_ar_detect_parameters class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_bayesian_ar_detect_parameters"""
        return _teca_py.teca_bayesian_ar_detect_parameters_New()

    def get_class_name(self):
        r"""get_class_name(teca_bayesian_ar_detect_parameters self) -> char const *"""
        return _teca_py.teca_bayesian_ar_detect_parameters_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_bayesian_ar_detect_parameters

    def set_number_of_rows(self, v):
        r"""
        set_number_of_rows(teca_bayesian_ar_detect_parameters self, long const & v)

        Parameters
        ----------
        v: long const &

        """
        return _teca_py.teca_bayesian_ar_detect_parameters_set_number_of_rows(self, v)

    def get_number_of_rows(self):
        r"""get_number_of_rows(teca_bayesian_ar_detect_parameters self) -> long const &"""
        return _teca_py.teca_bayesian_ar_detect_parameters_get_number_of_rows(self)

    def get_parameter_table_size(self):
        r"""get_parameter_table_size(teca_bayesian_ar_detect_parameters self) -> unsigned long"""
        return _teca_py.teca_bayesian_ar_detect_parameters_get_parameter_table_size(self)

# Register teca_bayesian_ar_detect_parameters in _teca_py:
_teca_py.teca_bayesian_ar_detect_parameters_swigregister(teca_bayesian_ar_detect_parameters)

def teca_bayesian_ar_detect_parameters_New():
    r"""teca_bayesian_ar_detect_parameters_New() -> p_teca_bayesian_ar_detect_parameters"""
    return _teca_py.teca_bayesian_ar_detect_parameters_New()

class teca_component_statistics(teca_algorithm):
    r"""Proxy of C++ teca_component_statistics class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_component_statistics"""
        return _teca_py.teca_component_statistics_New()

    def get_class_name(self):
        r"""get_class_name(teca_component_statistics self) -> char const *"""
        return _teca_py.teca_component_statistics_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_component_statistics

# Register teca_component_statistics in _teca_py:
_teca_py.teca_component_statistics_swigregister(teca_component_statistics)

def teca_component_statistics_New():
    r"""teca_component_statistics_New() -> p_teca_component_statistics"""
    return _teca_py.teca_component_statistics_New()

class teca_component_area_filter(teca_algorithm):
    r"""Proxy of C++ teca_component_area_filter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_component_area_filter"""
        return _teca_py.teca_component_area_filter_New()

    def get_class_name(self):
        r"""get_class_name(teca_component_area_filter self) -> char const *"""
        return _teca_py.teca_component_area_filter_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_component_area_filter

    def set_component_variable(self, v):
        r"""
        set_component_variable(teca_component_area_filter self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_component_area_filter_set_component_variable(self, v)

    def get_component_variable(self):
        r"""get_component_variable(teca_component_area_filter self) -> std::string const &"""
        return _teca_py.teca_component_area_filter_get_component_variable(self)

    def set_number_of_components_key(self, v):
        r"""
        set_number_of_components_key(teca_component_area_filter self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_component_area_filter_set_number_of_components_key(self, v)

    def get_number_of_components_key(self):
        r"""get_number_of_components_key(teca_component_area_filter self) -> std::string const &"""
        return _teca_py.teca_component_area_filter_get_number_of_components_key(self)

    def set_component_ids_key(self, v):
        r"""
        set_component_ids_key(teca_component_area_filter self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_component_area_filter_set_component_ids_key(self, v)

    def get_component_ids_key(self):
        r"""get_component_ids_key(teca_component_area_filter self) -> std::string const &"""
        return _teca_py.teca_component_area_filter_get_component_ids_key(self)

    def set_component_area_key(self, v):
        r"""
        set_component_area_key(teca_component_area_filter self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_component_area_filter_set_component_area_key(self, v)

    def get_component_area_key(self):
        r"""get_component_area_key(teca_component_area_filter self) -> std::string const &"""
        return _teca_py.teca_component_area_filter_get_component_area_key(self)

    def set_mask_value(self, v):
        r"""
        set_mask_value(teca_component_area_filter self, long const & v)

        Parameters
        ----------
        v: long const &

        """
        return _teca_py.teca_component_area_filter_set_mask_value(self, v)

    def get_mask_value(self):
        r"""get_mask_value(teca_component_area_filter self) -> long const &"""
        return _teca_py.teca_component_area_filter_get_mask_value(self)

    def set_low_area_threshold(self, v):
        r"""
        set_low_area_threshold(teca_component_area_filter self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_component_area_filter_set_low_area_threshold(self, v)

    def get_low_area_threshold(self):
        r"""get_low_area_threshold(teca_component_area_filter self) -> double const &"""
        return _teca_py.teca_component_area_filter_get_low_area_threshold(self)

    def set_high_area_threshold(self, v):
        r"""
        set_high_area_threshold(teca_component_area_filter self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_component_area_filter_set_high_area_threshold(self, v)

    def get_high_area_threshold(self):
        r"""get_high_area_threshold(teca_component_area_filter self) -> double const &"""
        return _teca_py.teca_component_area_filter_get_high_area_threshold(self)

    def set_variable_postfix(self, v):
        r"""
        set_variable_postfix(teca_component_area_filter self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_component_area_filter_set_variable_postfix(self, v)

    def get_variable_postfix(self):
        r"""get_variable_postfix(teca_component_area_filter self) -> std::string const &"""
        return _teca_py.teca_component_area_filter_get_variable_postfix(self)

    def set_contiguous_component_ids(self, v):
        r"""
        set_contiguous_component_ids(teca_component_area_filter self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_component_area_filter_set_contiguous_component_ids(self, v)

    def get_contiguous_component_ids(self):
        r"""get_contiguous_component_ids(teca_component_area_filter self) -> int const &"""
        return _teca_py.teca_component_area_filter_get_contiguous_component_ids(self)

# Register teca_component_area_filter in _teca_py:
_teca_py.teca_component_area_filter_swigregister(teca_component_area_filter)

def teca_component_area_filter_New():
    r"""teca_component_area_filter_New() -> p_teca_component_area_filter"""
    return _teca_py.teca_component_area_filter_New()

class teca_normalize_coordinates(teca_algorithm):
    r"""Proxy of C++ teca_normalize_coordinates class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_normalize_coordinates"""
        return _teca_py.teca_normalize_coordinates_New()

    def get_class_name(self):
        r"""get_class_name(teca_normalize_coordinates self) -> char const *"""
        return _teca_py.teca_normalize_coordinates_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_normalize_coordinates

    def set_enable_periodic_shift_x(self, v):
        r"""
        set_enable_periodic_shift_x(teca_normalize_coordinates self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_normalize_coordinates_set_enable_periodic_shift_x(self, v)

    def get_enable_periodic_shift_x(self):
        r"""get_enable_periodic_shift_x(teca_normalize_coordinates self) -> int const &"""
        return _teca_py.teca_normalize_coordinates_get_enable_periodic_shift_x(self)

    def set_enable_y_axis_ascending(self, v):
        r"""
        set_enable_y_axis_ascending(teca_normalize_coordinates self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_normalize_coordinates_set_enable_y_axis_ascending(self, v)

    def get_enable_y_axis_ascending(self):
        r"""get_enable_y_axis_ascending(teca_normalize_coordinates self) -> int const &"""
        return _teca_py.teca_normalize_coordinates_get_enable_y_axis_ascending(self)

# Register teca_normalize_coordinates in _teca_py:
_teca_py.teca_normalize_coordinates_swigregister(teca_normalize_coordinates)

def teca_normalize_coordinates_New():
    r"""teca_normalize_coordinates_New() -> p_teca_normalize_coordinates"""
    return _teca_py.teca_normalize_coordinates_New()

class field_generator(object):
    r"""Proxy of C++ field_generator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_teca_py.field_generator_name_get, _teca_py.field_generator_name_set, doc=r"""name : std::string""")
    attributes = property(_teca_py.field_generator_attributes_get, _teca_py.field_generator_attributes_set, doc=r"""attributes : teca_metadata""")
    generator = property(_teca_py.field_generator_generator_get, _teca_py.field_generator_generator_set, doc=r"""generator : field_generator_callback""")

    def __init__(self):
        r"""__init__(field_generator self) -> field_generator"""
        _teca_py.field_generator_swiginit(self, _teca_py.new_field_generator())
    __swig_destroy__ = _teca_py.delete_field_generator

# Register field_generator in _teca_py:
_teca_py.field_generator_swigregister(field_generator)

class teca_cartesian_mesh_source(teca_algorithm):
    r"""Proxy of C++ teca_cartesian_mesh_source class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_cartesian_mesh_source"""
        return _teca_py.teca_cartesian_mesh_source_New()

    def get_class_name(self):
        r"""get_class_name(teca_cartesian_mesh_source self) -> char const *"""
        return _teca_py.teca_cartesian_mesh_source_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_cartesian_mesh_source

    def set_coordinate_type_code(self, v):
        r"""
        set_coordinate_type_code(teca_cartesian_mesh_source self, unsigned int const & v)

        Parameters
        ----------
        v: unsigned int const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_coordinate_type_code(self, v)

    def get_coordinate_type_code(self):
        r"""get_coordinate_type_code(teca_cartesian_mesh_source self) -> unsigned int const &"""
        return _teca_py.teca_cartesian_mesh_source_get_coordinate_type_code(self)

    def set_field_type_code(self, v):
        r"""
        set_field_type_code(teca_cartesian_mesh_source self, unsigned int const & v)

        Parameters
        ----------
        v: unsigned int const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_field_type_code(self, v)

    def get_field_type_code(self):
        r"""get_field_type_code(teca_cartesian_mesh_source self) -> unsigned int const &"""
        return _teca_py.teca_cartesian_mesh_source_get_field_type_code(self)

    def get_number_of_whole_extents(self):
        r"""get_number_of_whole_extents(teca_cartesian_mesh_source self) -> size_t"""
        return _teca_py.teca_cartesian_mesh_source_get_number_of_whole_extents(self)

    def append_whole_extent(self, v):
        r"""
        append_whole_extent(teca_cartesian_mesh_source self, unsigned long const & v)

        Parameters
        ----------
        v: unsigned long const &

        """
        return _teca_py.teca_cartesian_mesh_source_append_whole_extent(self, v)

    def set_whole_extent(self, i, v):
        r"""
        set_whole_extent(teca_cartesian_mesh_source self, size_t i, unsigned long const & v)

        Parameters
        ----------
        i: size_t
        v: unsigned long const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_whole_extent(self, i, v)

    def set_whole_extents(self, *args):
        r"""
        set_whole_extents(teca_cartesian_mesh_source self, std_vector_ulong v)

        Parameters
        ----------
        v: std::vector< unsigned long,std::allocator< unsigned long > > const &

        set_whole_extents(teca_cartesian_mesh_source self, std::initializer_list< unsigned long > const && l)

        Parameters
        ----------
        l: std::initializer_list< unsigned long > const &&

        """
        return _teca_py.teca_cartesian_mesh_source_set_whole_extents(self, *args)

    def get_whole_extent(self, i):
        r"""
        get_whole_extent(teca_cartesian_mesh_source self, size_t i) -> unsigned long const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cartesian_mesh_source_get_whole_extent(self, i)

    def get_whole_extents(self):
        r"""get_whole_extents(teca_cartesian_mesh_source self) -> std_vector_ulong"""
        return _teca_py.teca_cartesian_mesh_source_get_whole_extents(self)

    def clear_whole_extents(self):
        r"""clear_whole_extents(teca_cartesian_mesh_source self)"""
        return _teca_py.teca_cartesian_mesh_source_clear_whole_extents(self)

    def set_spatial_extents(self, md, three_d=True):
        r"""
        set_spatial_extents(teca_cartesian_mesh_source self, teca_metadata md, bool three_d=True) -> int

        Parameters
        ----------
        md: teca_metadata const &
        three_d: bool

        """
        return _teca_py.teca_cartesian_mesh_source_set_spatial_extents(self, md, three_d)

    def get_number_of_bounds(self):
        r"""get_number_of_bounds(teca_cartesian_mesh_source self) -> size_t"""
        return _teca_py.teca_cartesian_mesh_source_get_number_of_bounds(self)

    def append_bound(self, v):
        r"""
        append_bound(teca_cartesian_mesh_source self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_cartesian_mesh_source_append_bound(self, v)

    def set_bound(self, i, v):
        r"""
        set_bound(teca_cartesian_mesh_source self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_bound(self, i, v)

    def set_bounds(self, *args):
        r"""
        set_bounds(teca_cartesian_mesh_source self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_bounds(teca_cartesian_mesh_source self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_cartesian_mesh_source_set_bounds(self, *args)

    def get_bound(self, i):
        r"""
        get_bound(teca_cartesian_mesh_source self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cartesian_mesh_source_get_bound(self, i)

    def get_bounds(self):
        r"""get_bounds(teca_cartesian_mesh_source self) -> std_vector_double"""
        return _teca_py.teca_cartesian_mesh_source_get_bounds(self)

    def clear_bounds(self):
        r"""clear_bounds(teca_cartesian_mesh_source self)"""
        return _teca_py.teca_cartesian_mesh_source_clear_bounds(self)

    def set_spatial_bounds(self, md, three_d=True):
        r"""
        set_spatial_bounds(teca_cartesian_mesh_source self, teca_metadata md, bool three_d=True) -> int

        Parameters
        ----------
        md: teca_metadata const &
        three_d: bool

        """
        return _teca_py.teca_cartesian_mesh_source_set_spatial_bounds(self, md, three_d)

    def set_x_axis_variable(self, *args):
        r"""
        set_x_axis_variable(teca_cartesian_mesh_source self, std::string const & name)

        Parameters
        ----------
        name: std::string const &

        set_x_axis_variable(teca_cartesian_mesh_source self, std::string const & name, teca_metadata atts)

        Parameters
        ----------
        name: std::string const &
        atts: teca_metadata const &

        set_x_axis_variable(teca_cartesian_mesh_source self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_x_axis_variable(self, *args)

    def set_y_axis_variable(self, *args):
        r"""
        set_y_axis_variable(teca_cartesian_mesh_source self, std::string const & name)

        Parameters
        ----------
        name: std::string const &

        set_y_axis_variable(teca_cartesian_mesh_source self, std::string const & name, teca_metadata atts)

        Parameters
        ----------
        name: std::string const &
        atts: teca_metadata const &

        set_y_axis_variable(teca_cartesian_mesh_source self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_y_axis_variable(self, *args)

    def set_z_axis_variable(self, *args):
        r"""
        set_z_axis_variable(teca_cartesian_mesh_source self, std::string const & name)

        Parameters
        ----------
        name: std::string const &

        set_z_axis_variable(teca_cartesian_mesh_source self, std::string const & name, teca_metadata atts)

        Parameters
        ----------
        name: std::string const &
        atts: teca_metadata const &

        set_z_axis_variable(teca_cartesian_mesh_source self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_z_axis_variable(self, *args)

    def set_calendar(self, calendar, units):
        r"""
        set_calendar(teca_cartesian_mesh_source self, std::string const & calendar, std::string const & units)

        Parameters
        ----------
        calendar: std::string const &
        units: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_calendar(self, calendar, units)

    def set_t_axis_variable(self, *args):
        r"""
        set_t_axis_variable(teca_cartesian_mesh_source self, std::string const & name)

        Parameters
        ----------
        name: std::string const &

        set_t_axis_variable(teca_cartesian_mesh_source self, std::string const & name, teca_metadata atts)

        Parameters
        ----------
        name: std::string const &
        atts: teca_metadata const &

        set_t_axis_variable(teca_cartesian_mesh_source self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_t_axis_variable(self, *args)

    def set_t_axis(self, *args):
        r"""
        set_t_axis(teca_cartesian_mesh_source self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata const &

        set_t_axis(teca_cartesian_mesh_source self, p_teca_variant_array const & t)

        Parameters
        ----------
        t: p_teca_variant_array const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_t_axis(self, *args)

    def set_output_metadata(self, md):
        r"""
        set_output_metadata(teca_cartesian_mesh_source self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_output_metadata(self, md)

    def get_number_of_field_generators(self):
        r"""get_number_of_field_generators(teca_cartesian_mesh_source self) -> size_t"""
        return _teca_py.teca_cartesian_mesh_source_get_number_of_field_generators(self)

    def append_field_generator(self, *args):
        r"""
        append_field_generator(teca_cartesian_mesh_source self, std::string const & name, teca_metadata atts, field_generator_callback & callback)

        Parameters
        ----------
        name: std::string const &
        atts: teca_metadata const &
        callback: field_generator_callback &

        append_field_generator(teca_cartesian_mesh_source self, field_generator v)

        Parameters
        ----------
        v: field_generator_t const &

        """
        return _teca_py.teca_cartesian_mesh_source_append_field_generator(self, *args)

    def set_field_generator(self, i, v):
        r"""
        set_field_generator(teca_cartesian_mesh_source self, size_t i, field_generator v)

        Parameters
        ----------
        i: size_t
        v: field_generator_t const &

        """
        return _teca_py.teca_cartesian_mesh_source_set_field_generator(self, i, v)

    def set_field_generators(self, *args):
        r"""
        set_field_generators(teca_cartesian_mesh_source self, std::vector< field_generator_t,std::allocator< field_generator_t > > const & v)

        Parameters
        ----------
        v: std::vector< field_generator_t,std::allocator< field_generator_t > > const &

        set_field_generators(teca_cartesian_mesh_source self, std::initializer_list< field_generator_t > const && l)

        Parameters
        ----------
        l: std::initializer_list< field_generator_t > const &&

        """
        return _teca_py.teca_cartesian_mesh_source_set_field_generators(self, *args)

    def get_field_generator(self, i):
        r"""
        get_field_generator(teca_cartesian_mesh_source self, size_t i) -> field_generator

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cartesian_mesh_source_get_field_generator(self, i)

    def get_field_generators(self):
        r"""get_field_generators(teca_cartesian_mesh_source self) -> std::vector< field_generator_t,std::allocator< field_generator_t > > const &"""
        return _teca_py.teca_cartesian_mesh_source_get_field_generators(self)

    def clear_field_generators(self):
        r"""clear_field_generators(teca_cartesian_mesh_source self)"""
        return _teca_py.teca_cartesian_mesh_source_clear_field_generators(self)

# Register teca_cartesian_mesh_source in _teca_py:
_teca_py.teca_cartesian_mesh_source_swigregister(teca_cartesian_mesh_source)

def teca_cartesian_mesh_source_New():
    r"""teca_cartesian_mesh_source_New() -> p_teca_cartesian_mesh_source"""
    return _teca_py.teca_cartesian_mesh_source_New()

import sys
import numpy
if get_teca_has_cupy():
    import cupy

class teca_temporal_reduction(teca_threaded_python_algorithm):
    """
    Reduce a mesh across the time dimensions by a defined increment using
    a defined operation.

        time increments: daily, monthly, seasonal
        reduction operators: average, min, max

    The output time axis will be defined using the selected increment.
    The output data will be accumulated/reduced using the selected
    operation.

    The set_use_fill_value  method controls how invalid or missing values are
    teated.  When set to 1, NetCDF CF fill values are detected and handled.
    This is the default. If it is known that the dataset has no invalid or
    missing values one may set this to 0 for faster processing. By default the
    fill value will be obtained from metadata stored in the NetCDF CF file
    (_FillValue). One may override this by explicitly calling set_fill_value
    method with the desired fill value.

    For minimum and maximum operations, at given grid point only valid values
    over the interval are used in the calculation.  if there are no valid
    values over the interval at the grid point it is set to the fill_value.

    For the averaging operation, during summation missing values are treated
    as 0.0 and a per-grid point count of valid values over the interval is
    maintained and used in the average. Grid points with no valid values over
    the inteval are set to the fill value.

    User defined reductions:
    ------------------------
    A reduction_operator compatible with teca_temporal_reduction must implement
    3 class methods: initialize, update, and finalize.

        initialize(self, fill_value) -> None

            initializes the reduction. If a not None fill value is passed
            the operator should use it to identify missing values in the data
            and handle them approproiately.

        update(self, out_array, out_valid, in_array, in_valid) -> (numpy ndarray, numpy ndarray)

            reduces in_array (new data) into out_array (current state) and
            returns the result.

        finalize(self, out_array, out_valid) -> (numpy ndarray, numpy ndarray)

            finalizes out_array (current state) and returns the result.
            if no finalization is needed simpy return out_array.

    A reduction_operator_factory compatible with teca_temporal_reduction
    must implement a factory method named New that takes a string and returns
    a reduction_operator.

        New(self, op_name) -> reduction_operator

        A factory method that creates an instance on demand from a string that
        matches its name. The existing operator_collection may be extended by
        overriding this method and falling back to the base method when the
        passed string is unknown.

    To use a user defined custom reduction operator, one must install the
    factory that creates it by passing a factory instance to
    teca_temporal_reduction.set_reduction_operator_factory.

    User defined time intervals:
    ----------------------------
    An interval_iterator compatible with teca_temporal_reduction must implement
    the Python iterator methods : __init__, __iter__ and __next__. The __init__
    method will be passed a floating point array of time values to iterate over
    and calendaring metadata (calendar name and time units strings) needed to
    interpret the values.  The __iter__method retuns self. The __next__ method
    determines the indices that span the next interval and return the start and
    end index into the time array as well as the floating point time of the
    start of the interval.  Following the Python iterator protocol __next_
    raises a StopIteration exception when all intervals have been visited and
    iteration should stop. The __next__ method will return a time_interval
    object. This object must have the following public member variables: time,
    start_index, and end_index.

        __init__(self, t, units, calendar)

            initializes the interval iterator from time values in t and
            calendaring metadata in units and calendar

        __iter__(self) -> self

            Boiler plate Python iterator protocol

        __next__(self) -> time_interval

            returns the next time_interval in the series and raises
            StopIteration when the series in complete.

    An interval_iterator_factory compatible with teca_temporal_reduction
    must implement a factory method named New that takes a string naming
    the type of the interval iterator to create, the floating point time
    values to iterate over, and calendaring metadata. The factory will
    return an iterator instance or raise a RuntimeError if no such interval
    iterator is defined.

        New(self, it_name, time_vals, units, calendar) -> interval_iterator

        A factory method that creates an instance on demand from a string that
        matches its name. The existing iterator_collection may be extended by
        overriding this method and falling back to the base method when the
        passed string is unknown.
    """

    class reduction_operator_collection:
        """
        A collection of reduction_operators compatible with
        teca_temporal_reduction, and a factory method that creates one on demand
        from a runtime provided string.

        This collection implements the following operators:

            minimum
            maximum
            average
            summation

        The factory method (operator_collection.New) retruns instances when passed
        a string naming one of them.
        """
        class average:
            def __init__(self):
                self.count = None
                self.fill_value = None

            def initialize(self, fill_value):
                self.fill_value = fill_value

            def update(self, dev, out_array, out_valid, in_array, in_valid):

# select GPU or CPU
                if dev < 0:
                    np = numpy
                else:
                    np = cupy

# don't use integer types for this calculation
                if in_array.dtype.kind == 'i':
                    in_array = in_array.astype(np.float32) \
                        if in_array.itemsize < 8 else \
                        in_array.astype(float64)

                if out_array.dtype.kind == 'i':
                    out_array = out_array.astype(np.float32) \
                        if out_array.itemsize < 8 else \
                        out_array.astype(float64)

# identify the invalid values
                if self.fill_value is not None:
                    out_is_good = np.array(out_valid, dtype=np.bool_)
                    in_is_good = np.array(in_valid, dtype=np.bool_)

# initialize the count the first time through. this needs to
# happen now since before this we don't know where invalid
# values are.
                if self.count is None:
                    if self.fill_value is None:
                        self.count = np.float32(1)
                    else:
                        self.count = np.zeros_like(out_array, dtype=np.float32)
                        self.count[out_is_good] += np.float32(1)

                if self.fill_value is not None:
# update the count only where there is valid data
                    self.count[in_is_good] += np.float32(1)

# accumulate
                    tmp = np.where(out_is_good, out_array, np.float32(0)) \
                        + np.where(in_is_good, in_array, np.float32(0))

# update the valid value mask
                    tmp_vv = np.zeros_like(out_array, dtype=np.int8)
                    tmp_vv[in_is_good] = np.int8(1)
                    tmp_vv[out_is_good] = np.int8(1)
                else:
# update count
                    self.count += np.float32(1)

# accumulate
                    tmp = out_array + in_array
                    tmp_vv = None

                return tmp, tmp_vv

            def finalize(self, dev, out_array, out_valid):

# select GPU or CPU
                if dev < 0:
                    np = numpy
                else:
                    np = cupy

                if self.fill_value is not None:
# finish the average. We keep track of the invalid
# values (these will have a zero count) set them to
# the fill value
                    out_is_bad = np.logical_not(out_valid)
                    out_array[out_is_bad] = np.float32(1)
                    out_array /= self.count
                    out_array[out_is_bad] = self.fill_value
                else:
                    out_array /= self.count

                self.count = None
                return out_array, out_valid

        class summation:
            def __init__(self):
                self.fill_value = None

            def initialize(self, fill_value):
                self.fill_value = fill_value

            def update(self, dev, out_array, out_valid, in_array, in_valid):

# select GPU or CPU
                if dev < 0:
                    np = numpy
                else:
                    np = cupy

                if self.fill_value is not None:
# identify the invalid values
                    out_is_good = np.array(out_valid, dtype=np.bool_)
                    in_is_good = np.array(in_valid, dtype=np.bool_)

# accumulate
                    tmp = np.where(out_is_good, out_array, np.float32(0)) \
                        + np.where(in_is_good, in_array, np.float32(0))

# update the valid value mask
                    tmp_vv = np.zeros_like(out_array, dtype=np.int8)
                    tmp_vv[in_is_good] = np.int8(1)
                    tmp_vv[out_is_good] = np.int8(1)
                else:
# accumulate
                    tmp = out_array + in_array
                    tmp_vv = None

                return tmp, tmp_vv

            def finalize(self, dev, out_array, out_valid):
                if self.fill_value is not None:
                    out_is_bad = np.logical_not(out_valid)
                    out_array[out_is_bad] = self.fill_value
                return out_array, out_valid

        class minimum:
            def __init__(self):
                self.fill_value = None

            def initialize(self, fill_value):
                self.fill_value = fill_value

            def update(self, dev, out_array, out_valid, in_array, in_valid):

# select GPU or CPU
                if dev < 0:
                    np = numpy
                else:
                    np = cupy

# reduce
                tmp = np.minimum(out_array, in_array)
                tmp_valid = None

# fix invalid values
                if self.fill_value is not None:
                    out_is_good = np.array(out_valid, dtype=np.bool_)
                    out_is_bad = np.logical_not(out_valid)
                    in_is_good = np.array(in_valid, dtype=np.bool_)
                    in_is_bad = np.logical_not(in_valid)
                    tmp = np.where(np.logical_and(out_is_bad, in_is_good), in_array, tmp)
                    tmp = np.where(np.logical_and(in_is_bad, out_is_good), out_array, tmp)
                    tmp_valid = np.zeros_like(out_valid, dtype=np.int8)
                    tmp_valid[in_is_good] = np.int8(1)
                    tmp_valid[out_is_good] = np.int8(1)

                return tmp, tmp_valid

            def finalize(self, dev, out_array, out_valid):
                if self.fill_value is not None:
                    out_is_bad = np.logical_not(out_valid)
                    out_array[out_is_bad] = self.fill_value
                return out_array, out_valid

        class maximum:
            def __init__(self):
                self.fill_value = None

            def initialize(self, fill_value):
                self.fill_value = fill_value

            def update(self, dev, out_array, out_valid, in_array, in_valid):
# select GPU or CPU
                if dev < 0:
                    np = numpy
                else:
                    np = cupy

# reduce
                tmp = np.maximum(out_array, in_array)
                tmp_valid = None

# fix invalid values
                if self.fill_value is not None:
                    out_is_good = np.array(out_valid, dtype=np.bool_)
                    out_is_bad = np.logical_not(out_valid)
                    in_is_good = np.array(in_valid, dtype=np.bool_)
                    in_is_bad = np.logical_not(in_valid)
                    tmp = np.where(np.logical_and(out_is_bad, in_is_good), in_array, tmp)
                    tmp = np.where(np.logical_and(in_is_bad, out_is_good), out_array, tmp)
                    tmp_valid = np.zeros_like(out_valid, dtype=np.int8)
                    tmp_valid[in_is_good] = np.int8(1)
                    tmp_valid[out_is_good] = np.int8(1)

                return tmp, tmp_valid

            def finalize(self, dev, out_array, out_valid):
                if self.fill_value is not None:
                    out_is_bad = np.logical_not(out_valid)
                    out_array[out_is_bad] = self.fill_value
                return out_array, out_valid


        def New(self, op_name):
            """ factory method that creates an instance from a string """
            if op_name == 'average':
                return teca_temporal_reduction. \
                    reduction_operator_collection. \
                        average()

            elif op_name == 'minimum':
                return teca_temporal_reduction. \
                    reduction_operator_collection. \
                        minimum()

            elif op_name == 'maximum':
                return teca_temporal_reduction. \
                    reduction_operator_collection. \
                        maximum()

            elif op_name == 'summation':
                return teca_temporal_reduction. \
                    reduction_operator_collection. \
                        summation()


            raise RuntimeError('Invalid operator %s' % (op_name))


    class time_interval:
        """
        Defines a time interval.
        Public member variables:

            time        - the floating point time value of the start of the
                          interval
            start_index - the index into the floating point time array of the
                          first index to include in the interval
            end_index   - the index into the floating point time array of the
                          last index to include in the interval
        """
        def __init__(self, t, start_idx, end_idx, **kwds):
            self.time = t
            self.start_index = start_idx
            self.end_index = end_idx
            self.__dict__.update(kwds)

        def __str__(self):
            strg = ''
            for k, v in self.__dict__.items():
                strg += k + '=' + str(v) + ', '
            return strg

    class interval_iterator_collection:
        """
        A collection of interval_iterators compatible with
        teca_temporal_reduction and a factory method that creates ionstances
        from a string that names the type.

        This collectiond implements the following interval_iterators

            daily
            monthly
            seasonal
            yearly
            n_steps

        The factory method (interval_iterator_collection.New) retruns instances
        when passed a string naming one of the above iterators. For the n_steps
        iterator replace n with the desired number of steps (eg. 8_steps)
        """

        class time_point:
            """
            A structure holding a floating point time value and its
            corresponding year, month day, hour minute and second
            """
            def __init__(self, t, units, calendar):
                self.t = t
                self.units = units
                self.calendar = calendar

                self.year, self.month, self.day, \
                    self.hour, self.minutes, self.seconds = \
                    calendar_util.date(t, self.units, self.calendar)

            def __str__(self):
                return '%g (%s, %s) --> %04d-%02d-%02d %02d:%02d:%02g' % (
                    self.t, self.units, self.calendar, self.year, self.month,
                    self.day, self.hour, self.minutes, self.seconds)

        class n_step_iterator:
            """ An iterator over intervals of N time steps """

            def __init__(self, t, units, calendar, n_steps):
                self.time = t
                self.index = 0
                self.n_steps = n_steps

            def __iter__(self):
                return self

            def __next__(self):

                i0 = self.index
                i1 = self.index + self.n_steps

                if i1 >= len(self.time):
                    raise StopIteration

                self.index = i1

                return teca_temporal_reduction. \
                    time_interval(self.time[i0], i0, i1)

        class season_iterator:
            """
            An iterator over seasons (DJF, MAM, JJA, SON) between 2
            time_point's.  A pair of time steps bracketing the current season
            are returned at each iteration. Only full seasonal intervals are
            processed.  If the input data doesn't start or end on a seasonal
            boundary it is skipped.
            """

            def __init__(self, t, units, calendar):
                """
                t - an array of floating point time values
                units - string units of the time values
                calendar - string name of the calendar system
                """
                self.t = t
                self.units = units

                calendar = calendar.lower()
                self.calendar = calendar

# time point's to iterate between
                self.t0 = teca_temporal_reduction. \
                    interval_iterator_collection. \
                        time_point(t[0], units, calendar)

                self.t1 = teca_temporal_reduction. \
                    interval_iterator_collection. \
                        time_point(t[-1], units, calendar)

# current time state
                self.year, self.month = \
                     self.get_first_season(self.t0.year, self.t0.month)

            def get_season_name(self, month):
                """
                returns one of DJF,MAM,JJA,SON based on the month passed in
                """
                if (month == 12) or ((month >= 1) and (month <= 2)):
                    return 'DJF'
                elif (month >= 3) and (month <= 5):
                    return 'MAM'
                elif (month >= 6) and (month <= 8):
                    return 'JJA'
                elif (month >= 9) and (month <= 11):
                    return 'SON'

                raise RuntimeError('Invalid month %d' % (month))

            def get_first_season(self, y, m):
                """
                given a year and month, checks that the values fall on
                a seasonal boundary. if not, returns the year and month
                of the start of the next season.
                """
                if (m == 12) or (m == 3) or (m == 6) or (m == 9):
                    return y, m
                else:
                    return self.get_next_season(y, m)

            def get_season_end(self, year, month):
                """
                Given a year and month returns the year month and day
                of the end of the season. the input month need not be on
                a seasonal boundary.
                """
                if (month == 12):
                    y = year + 1
                    m = 2
                elif (month >= 1) and (month <= 2):
                    y = year
                    m = 2
                elif (month >= 3) and (month <= 5):
                    y = year
                    m = 5
                elif (month >= 6) and (month <= 8):
                    y = year
                    m = 8
                elif (month >= 9) and (month <= 11):
                    y = year
                    m = 11
                else:
                    raise RuntimeError('Invalid month %d' % (month))

                d = self.last_day_of_month(y, m)

                return y, m, d

            def get_next_season(self, year, month):
                """
                Given a year and month returns the year and month
                of the next season. the input momnth doesn't need to be
                on a seasonal boundary.
                """
                if (month == 12):
                    y = year + 1
                    m = 3
                elif (month >= 1) and (month <= 2):
                    y = year
                    m = 3
                elif (month >= 3) and (month <= 5):
                    y = year
                    m = 6
                elif (month >= 6) and (month <= 8):
                    y = year
                    m = 9
                elif (month >= 9) and (month <= 11):
                    y = year
                    m = 12
                else:
                    raise RuntimeError('Invalid month %d' % (month))

                return y, m

            def last_day_of_month(self, year, month):
                """
                get the number of days in the month, with logic for
                leap years
                """
                return \
                    calendar_util.days_in_month(self.calendar,
                                                self.units, year,
                                                month)

            def __iter__(self):
                return self

            def __next__(self):
                """
                return a pair of time steps bracketing the current month.
                both returned time steps belong to the current month.
                """
# get the end of the current season
                ey, em, ed = self.get_season_end(self.year, self.month)

# verify that we have data for the current season
                if ((ey > self.t1.year) or
                    ((ey == self.t1.year) and (em > self.t1.month)) or
                    ((ey == self.t1.year) and (em == self.t1.month) and
                    (ed > self.t1.day))):
                    raise StopIteration

# find the time step of the first day
                sy = self.year
                sm = self.month

                t0 = '%04d-%02d-01 00:00:00' % (sy, sm)
                i0 = coordinate_util.time_step_of(self.t, False, True,
                                                  self.calendar,
                                                  self.units, t0)

# find the time step of the last day
                t1 = '%04d-%02d-%02d 23:59:59' % (ey, em, ed)
                i1 = coordinate_util.time_step_of(self.t, True, True,
                                                  self.calendar,
                                                  self.units, t1)

# move to next season
                self.year, self.month = \
                     self.get_next_season(sy, sm)

                return teca_temporal_reduction.time_interval(
                    self.t[i0], i0, i1, year=sy, month=sm, day=1)


        class month_iterator:
            """
            An iterator over all months between 2 time_point's. A pair
            of time steps bracketing the current month are returned at
            each iteration.
            """

            def __init__(self, t, units, calendar):
                """
                t - an array of floating point time values
                units - string units of the time values
                calendar - string name of the calendar system
                """
                self.t = t
                self.units = units

                calendar = calendar.lower()
                self.calendar = calendar

# time point's to iterate between
                self.t0 = teca_temporal_reduction. \
                    interval_iterator_collection. \
                        time_point(t[0], units, calendar)

                self.t1 = teca_temporal_reduction. \
                    interval_iterator_collection. \
                        time_point(t[-1], units, calendar)

# current time state
                self.year = self.t0.year
                self.month = self.t0.month

            def last_day_of_month(self):
                """
                get the number of days in the month, with logic for
                leap years
                """
                return \
                    calendar_util.days_in_month(self.calendar,
                                                self.units, self.year,
                                                self.month)

            def __iter__(self):
                return self

            def __next__(self):
                """
                return a pair of time steps bracketing the current month.
                both returned time steps belong to the current month.
                """
# check for more months to process
                if (self.year > self.t1.year) or \
                        (self.year == self.t1.year) and \
                        (self.month > self.t1.month):
                    raise StopIteration

# find the time step of the first day
                year = self.year
                month = self.month

                t0 = '%04d-%02d-01 00:00:00' % (self.year, self.month)
                i0 = coordinate_util.time_step_of(self.t, False, True,
                                                  self.calendar,
                                                  self.units, t0)

# find the time step of the last day
                n_days = self.last_day_of_month()

                t1 = '%04d-%02d-%02d 23:59:59' % \
                    (self.year, self.month, n_days)

                i1 = coordinate_util.time_step_of(self.t, True, True,
                                                  self.calendar,
                                                  self.units, t1)

# move to next month
                self.month += 1

# move to next year
                if self.month == 13:
                    self.month = 1
                    self.year += 1

                return teca_temporal_reduction.time_interval(
                    self.t[i0], i0, i1, year=year, month=month, day=1)

        class day_iterator:
            """
            An iterator over all days between 2 time_point's. A pair
            of time steps bracketing the current day are returned at
            each iteration.
            """

            def __init__(self, t, units, calendar):
                """
                t - an array of floating point time values
                units - string units of the time values
                calendar - string name of the calendar system
                """
# time values
                self.t = t
                self.units = units

                calendar = calendar.lower()
                self.calendar = calendar

# time point's to iterate between
                self.t0 = teca_temporal_reduction. \
                    interval_iterator_collection. \
                        time_point(t[0], units, calendar)

                self.t1 = teca_temporal_reduction. \
                    interval_iterator_collection. \
                        time_point(t[-1], units, calendar)

# current time state
                self.year = self.t0.year
                self.month = self.t0.month
                self.day = self.t0.day

            def last_day_of_month(self):
                """
                get the number of days in the month, with logic for
                leap years
                """
                return calendar_util.days_in_month(
                           self.calendar, self.units, self.year, self.month)

            def __iter__(self):
                return self

            def __next__(self):
                """
                return a pair of time steps bracketing the current month.
                both returned time steps belong to the current month.
                """
# check for more days to process
                if (self.year > self.t1.year) or \
                        ((self.year == self.t1.year) and
                         (self.month > self.t1.month)) or \
                        ((self.year == self.t1.year) and
                         (self.month == self.t1.month) and
                         (self.day > self.t1.day)):
                    raise StopIteration

# find the time step of the first day
                year = self.year
                month = self.month
                day = self.day

                t0 = '%04d-%02d-%02d 00:00:00' % \
                    (self.year, self.month, self.day)

                i0 = coordinate_util.time_step_of(self.t, False, True,
                                                  self.calendar,
                                                  self.units, t0)

# find the time step of the last day
                t1 = '%04d-%02d-%02d 23:59:59' % \
                    (self.year, self.month, self.day)

                i1 = coordinate_util.time_step_of(self.t, True, True,
                                                  self.calendar,
                                                  self.units, t1)

# move to next day
                n_days = self.last_day_of_month()
                self.day += 1

# move to next month
                if self.day > n_days:
                    self.month += 1
                    self.day = 1

# move to next year
                if self.month == 13:
                    self.month = 1
                    self.year += 1

                return teca_temporal_reduction.time_interval(
                    self.t[i0], i0, i1, year=year, month=month, day=day)

        def New(self, interval, t, units, calendar):
            if interval == 'seasonal':

                return teca_temporal_reduction. \
                    interval_iterator_collection. \
                        season_iterator(t, units, calendar)

            if interval == 'monthly':

                return teca_temporal_reduction. \
                    interval_iterator_collection. \
                        month_iterator(t, units, calendar)

            elif interval == 'daily':

                return teca_temporal_reduction. \
                    interval_iterator_collection. \
                        day_iterator(t, units, calendar)

            elif (pos := interval.rfind('_steps')) > 0:

                n_steps = int(interval[0:pos])

                return teca_temporal_reduction. \
                    interval_iterator_collection. \
                        n_steps_iterator(t, units, calendar, n_steps)

            else:

                raise RuntimeError('Invlid interval %s' % (interval))


    def __init__(self):
        self.have_cuda = get_teca_has_cuda() and get_teca_has_cupy()
        self.indices = []
        self.point_arrays = []
        self.interval_name = None
        self.operator_name = None
        self.use_fill_value = 1
        self.fill_value = None
        self.operator = {}

        self.reduction_operator_factory = \
            teca_temporal_reduction.reduction_operator_collection()

        self.interval_iterator_factory = \
            teca_temporal_reduction.interval_iterator_collection()

    def set_reduction_operator_factory(self, factory):
        """
        Sets a factory object that implements a method named New that,
        given a string naming an aoperastor, creates an instance of that
        operator. The factory method has the following signature:

            New(self, op_name) -> reduction_operator

        where:

            op_name - is a string naming the type of reduction operator to
                      create

        """
        self.reduction_operator_factory = factory

    def set_interval_iterator_factory(self, factory):
        """
        Sets a factory object that implelents a method named New that,
        given a string naming the interval, can create the coresponding
        interval_iterator. The factory has the following signature:

            New(self, interval_name, t, units, calendar) -> interval_iterator

        where

            interval_name - a string naming the type of interval iterator to
                          - create
            t             - an array with the time coordinates to iterate over
            units         - time units
            calendar      - the calendar
        """
        self.interval_iterator_factory = factory


    def set_fill_value(self, fill_value):
        """
        set the output fill_value
        """
        self.fill_value = fill_value

    def set_use_fill_value(self, use):
        """
        set the output fill_value
        """
        self.use_fill_value = use

    def set_interval(self, interval):
        """
        set the output interval
        """
        self.interval_name = interval

    def set_interval_to_seasonal(self):
        """
        set the output interval to seasonal.
        """
        self.interval_name = 'seasonal'

    def set_interval_to_monthly(self):
        """
        set the output interval to monthly.
        """
        self.interval_name = 'monthly'

    def set_interval_to_daily(self):
        """
        set the output interval to daily.
        """
        self.interval_name = 'daily'

    def set_interval_to_n_steps(self, n_steps):
        """
        set the output interval to n_steps.
        """
        self.interval_name = '%d_steps'%(n_steps)

    def set_operator(self, operator):
        """
        set the reduction operator
        """
        self.operator_name = operator

    def set_operator_to_maximum(self):
        """
        set the reduction operator to maximum.
        """
        self.operator_name = 'maximum'

    def set_operator_to_minimum(self):
        """
        set the reduction operator to minimum.
        """
        self.operator_name = 'minimum'

    def set_operator_to_average(self):
        """
        set the reduction operator to average.
        """
        self.operator_name = 'average'

    def set_operator_to_summation(self):
        """
        set the reduction operator to summation.
        """
        self.operator_name = 'summation'

    def set_point_arrays(self, arrays):
        """
        Set the list of arrays to reduce
        """
        if isinstance(arrays, list):
            arrays = list(arrays)
        self.point_arrays = arrays

    def report(self, port, md_in):
        """
        implements the report phase of pipeline execution
        """
        if self.get_verbose() > 0:
            try:
                rank = self.get_communicator().Get_rank()
            except Exception:
                rank = 0
            sys.stderr.write('[%d] teca_temporal_reduction::report\n' % (rank))

# sanity checks
        if self.interval_name is None:
            raise RuntimeError('No interval specified')

        if self.operator_name is None:
            raise RuntimeError('No operator specified')

        if self.point_arrays is None:
            raise RuntimeError('No arrays specified')

        md_out = md_in[0]

# get the input time axis and metadata
        atts = md_out['attributes']
        coords = md_out['coordinates']

        t = coords['t']
        t_var = coords['t_variable']
        t_atts = atts[t_var]

        try:
            cal = t_atts['calendar']
        except KeyError:
            cal = 'standard'
            sys.stderr.write('Attributes for the time axis %s is missing '
                             'calendar. The "standard" calendar will be '
                             'used'%(t_var))

        t_units = t_atts['units']

# convert the time axis to the specified interval
        self.indices = [ii for ii in self.interval_iterator_factory. \
                        New(self.interval_name, t, t_units, cal)]

        if self.get_verbose() > 1:
            sys.stderr.write('indices = [\n')
            for ii in self.indices:
                sys.stderr.write('\t%s\n' % (str(ii)))
            sys.stderr.write(']\n')

# update the pipeline control keys
        initializer_key = md_out['index_initializer_key']
        md_out[initializer_key] = len(self.indices)

# update the metadata so that  modified time axis and reduced variables
# are presented
        out_atts = teca_metadata()
        out_vars = []

        for array in self.point_arrays:
# name of the output array
            out_vars.append(array)

# pass the attributes
            in_atts = atts[array]

# convert integer to floating point for averaging operations
            if self.operator_name == 'average':
                tc = in_atts['type_code']
                if ( tc == teca_int_array_code.get() )                        \
                        or ( tc == teca_char_array_code.get() )               \
                        or ( tc == teca_short_array_code.get() )              \
                        or ( tc == teca_unsigned_int_array_code.get() )       \
                        or ( tc == teca_unsigned_char_array_code.get() )      \
                        or ( tc == teca_unsigned_short_array_code.get() ):
                    tc = teca_float_array_code.get()
                elif ( tc == teca_long_array_code.get() )                     \
                        or ( tc == teca_long_long_array_code.get() )          \
                        or ( tc == teca_unsigned_long_array_code.get() )      \
                        or ( tc == teca_unsigned_long_long_array_code.get() ):
                    tc = teca_double_array_code.get()
                in_atts['type_code'] = tc

# document the transformation
            in_atts['description'] = '%s %s of %s' % (self.interval_name,
                                                      self.operator_name,
                                                      array)

            out_atts[array] = in_atts

# update time axis
        q = 0
        t_out = np.empty(len(self.indices), dtype=np.float64)
        for ii in self.indices:
            t_out[q] = ii.time
            q += 1
        coords['t'] = t_out
        md_out['coordinates'] = coords

        out_atts[t_var] = t_atts

# package it all up and return
        md_out['variables'] = out_vars
        md_out["attributes"] = out_atts

        return md_out

    def request(self, port, md_in, req_in):
        """
        implements the request phase of pipeline execution
        """
        if self.get_verbose() > 0:
            try:
                rnk = self.get_communicator().Get_rank()
            except Exception:
                rnk = 0
            sys.stderr.write('[%d] teca_temporal_reduction::request\n' % (rnk))

        md = md_in[0]

# get the available arrays
        vars_in = []
        if md.has('variables'):
            vars_in = md['variables']
            if not isinstance(vars_in, list):
                vars_in = [vars_in]

# get the requested arrays
        req_arrays = []
        if req_in.has('arrays'):
            req_arrays = req_in['arrays']
            if not isinstance(req_arrays, list):
                req_arrays = [req_arrays]

# get the array attributes
        atrs = md['attributes']

        for array in self.point_arrays:

# request the array
            if array not in req_arrays:
                req_arrays.append(array)

            fill_value = None
            vv_mask = array + '_valid'
            if self.use_fill_value and (vv_mask in vars_in) \
                    and (vv_mask not in req_arrays):
# request the associated valid value mask
                req_arrays.append(vv_mask)

# get the fill value
                array_atrs = atrs[array]
                if self.fill_value is not None:
                    fill_value = self.fill_value
                elif array_atrs.has('_FillValue'):
                    fill_value = array_atrs['_FillValue']
                elif array_atrs.has('missing_value'):
                    fill_value = array_atrs['missing_value']

# create and initialize the operator
            op = self.reduction_operator_factory.New(self.operator_name)
            op.initialize(fill_value)

# save the operator
            self.operator[array] = op

# generate one request for each time step in the interval
        up_reqs = []
        request_key = md['index_request_key']
        req_id = req_in[request_key]
        ii = self.indices[req_id]
        i = ii.start_index
        while i <= ii.end_index:
            req = teca_metadata(req_in)
            req['arrays'] = req_arrays
            req[request_key] = i
            up_reqs.append(req)
            i += 1

        return up_reqs

    def execute(self, port, data_in, req_in, streaming):
        """
        implements the execute phase of pipeline execution
        """

# get the requested index
        request_key = req_in['index_request_key']
        req_id = req_in[request_key]
        ii = self.indices[req_id]

# Get the device to execute on
        dev = -1
        alloc = variant_array_allocator_malloc
        if self.have_cuda:
            dev = req_in['device_id']
            if dev >= 0:
                cupy.cuda.Device(dev).use()
                alloc = variant_array_allocator_cuda

        if self.get_verbose() > 0:
            try:
                rank = self.get_communicator().Get_rank()
            except Exception:
                rank = 0
            sys.stderr.write('[%d] teca_temporal_reduction::execute dev'
                             ' %d request %d (%d - %d), reducing %d, %d'
                             ' remain\n' % (rank, dev, req_id, ii.start_index,
                                           ii.end_index, len(data_in),
                                           streaming))

# copy the first mesh
        mesh_in = as_teca_cartesian_mesh(data_in.pop())
        mesh_out = teca_cartesian_mesh.New()
        mesh_out.copy(mesh_in, alloc)
        arrays_out = mesh_out.get_point_arrays()

# accumulate incoming values
        while len(data_in):
            mesh_in = as_teca_cartesian_mesh(data_in.pop())
            arrays_in = mesh_in.get_point_arrays()

            for array in self.point_arrays:

# the valid value masks
                valid = array + '_valid'
                in_valid = None
                out_valid = None

# get the data on the device where it will be used
                if dev < 0:
# arrays
                    in_array = arrays_in[array].get_cpu_accessible()
                    out_array = arrays_out[array].get_cpu_accessible()
# valid value masks
                    if arrays_in.has(valid):
                        in_valid = arrays_in[valid].get_cpu_accessible()
                    if arrays_out.has(valid):
                        out_valid = arrays_out[valid].get_cpu_accessible()
                else:
# arrays
                    in_array = arrays_in[array].get_cuda_accessible()
                    out_array = arrays_out[array].get_cuda_accessible()
# valid value masks
                    if arrays_in.has(valid):
                        in_valid = arrays_in[valid].get_cuda_accessible()
                    if arrays_out.has(valid):
                        out_valid = arrays_out[valid].get_cuda_accessible()

# apply the reduction
                red_array, red_valid = \
                    self.operator[array].update(dev, out_array, out_valid,
                                                in_array, in_valid)

# udpate the output
                arrays_out[array] = red_array

                if red_valid is not None:
                    arrays_out[valid] = red_valid

# when all the data is processed
        if not streaming:
            for array in self.point_arrays:

# the valid value masks
                valid = array + '_valid'
                in_valid = None
                out_valid = None

# get the data on the device where it will be used
                if dev < 0:
                    out_array = arrays_out[array].get_cpu_accessible()
                    if arrays_out.has(valid):
                        out_valid = arrays_out[valid].get_cpu_accessible()
                else:
                    out_array = arrays_out[array].get_cuda_accessible()
                    if arrays_out.has(valid):
                        out_valid = arrays_out[valid].get_cuda_accessible()

# finalize the reduction
                red_array, red_valid = \
                    self.operator[array].finalize(dev, out_array, out_valid)

# udpate the output
                arrays_out[array] = red_array

                if red_valid is not None:
                    arrays_out[valid] = red_valid

# fix time
            mesh_out.set_time_step(req_id)
            mesh_out.set_time(ii.time)

        return mesh_out

class teca_vertical_reduction(teca_algorithm):
    r"""Proxy of C++ teca_vertical_reduction class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_vertical_reduction"""
        return _teca_py.teca_vertical_reduction_New()

    def get_class_name(self):
        r"""get_class_name(teca_vertical_reduction self) -> char const *"""
        return _teca_py.teca_vertical_reduction_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_vertical_reduction

    def get_number_of_dependent_variables(self):
        r"""get_number_of_dependent_variables(teca_vertical_reduction self) -> size_t"""
        return _teca_py.teca_vertical_reduction_get_number_of_dependent_variables(self)

    def append_dependent_variable(self, v):
        r"""
        append_dependent_variable(teca_vertical_reduction self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_vertical_reduction_append_dependent_variable(self, v)

    def set_dependent_variable(self, i, v):
        r"""
        set_dependent_variable(teca_vertical_reduction self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_vertical_reduction_set_dependent_variable(self, i, v)

    def set_dependent_variables(self, *args):
        r"""
        set_dependent_variables(teca_vertical_reduction self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_dependent_variables(teca_vertical_reduction self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_vertical_reduction_set_dependent_variables(self, *args)

    def get_dependent_variable(self, i):
        r"""
        get_dependent_variable(teca_vertical_reduction self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_vertical_reduction_get_dependent_variable(self, i)

    def get_dependent_variables(self):
        r"""get_dependent_variables(teca_vertical_reduction self) -> std_vector_string"""
        return _teca_py.teca_vertical_reduction_get_dependent_variables(self)

    def clear_dependent_variables(self):
        r"""clear_dependent_variables(teca_vertical_reduction self)"""
        return _teca_py.teca_vertical_reduction_clear_dependent_variables(self)

    def get_number_of_derived_variables(self):
        r"""get_number_of_derived_variables(teca_vertical_reduction self) -> size_t"""
        return _teca_py.teca_vertical_reduction_get_number_of_derived_variables(self)

    def append_derived_variable(self, v):
        r"""
        append_derived_variable(teca_vertical_reduction self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_vertical_reduction_append_derived_variable(self, v)

    def set_derived_variable(self, i, v):
        r"""
        set_derived_variable(teca_vertical_reduction self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_vertical_reduction_set_derived_variable(self, i, v)

    def set_derived_variables(self, *args):
        r"""
        set_derived_variables(teca_vertical_reduction self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_derived_variables(teca_vertical_reduction self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_vertical_reduction_set_derived_variables(self, *args)

    def get_derived_variable(self, i):
        r"""
        get_derived_variable(teca_vertical_reduction self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_vertical_reduction_get_derived_variable(self, i)

    def get_derived_variables(self):
        r"""get_derived_variables(teca_vertical_reduction self) -> std_vector_string"""
        return _teca_py.teca_vertical_reduction_get_derived_variables(self)

    def clear_derived_variables(self):
        r"""clear_derived_variables(teca_vertical_reduction self)"""
        return _teca_py.teca_vertical_reduction_clear_derived_variables(self)

    def get_number_of_derived_variable_attributes(self):
        r"""get_number_of_derived_variable_attributes(teca_vertical_reduction self) -> size_t"""
        return _teca_py.teca_vertical_reduction_get_number_of_derived_variable_attributes(self)

    def append_derived_variable_attribute(self, v):
        r"""
        append_derived_variable_attribute(teca_vertical_reduction self, teca_array_attributes v)

        Parameters
        ----------
        v: teca_array_attributes const &

        """
        return _teca_py.teca_vertical_reduction_append_derived_variable_attribute(self, v)

    def set_derived_variable_attribute(self, i, v):
        r"""
        set_derived_variable_attribute(teca_vertical_reduction self, size_t i, teca_array_attributes v)

        Parameters
        ----------
        i: size_t
        v: teca_array_attributes const &

        """
        return _teca_py.teca_vertical_reduction_set_derived_variable_attribute(self, i, v)

    def set_derived_variable_attributes(self, *args):
        r"""
        set_derived_variable_attributes(teca_vertical_reduction self, std::vector< teca_array_attributes,std::allocator< teca_array_attributes > > const & v)

        Parameters
        ----------
        v: std::vector< teca_array_attributes,std::allocator< teca_array_attributes > > const &

        set_derived_variable_attributes(teca_vertical_reduction self, std::initializer_list< teca_array_attributes > const && l)

        Parameters
        ----------
        l: std::initializer_list< teca_array_attributes > const &&

        """
        return _teca_py.teca_vertical_reduction_set_derived_variable_attributes(self, *args)

    def get_derived_variable_attribute(self, i):
        r"""
        get_derived_variable_attribute(teca_vertical_reduction self, size_t i) -> teca_array_attributes

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_vertical_reduction_get_derived_variable_attribute(self, i)

    def get_derived_variable_attributes(self):
        r"""get_derived_variable_attributes(teca_vertical_reduction self) -> std::vector< teca_array_attributes,std::allocator< teca_array_attributes > > const &"""
        return _teca_py.teca_vertical_reduction_get_derived_variable_attributes(self)

    def clear_derived_variable_attributes(self):
        r"""clear_derived_variable_attributes(teca_vertical_reduction self)"""
        return _teca_py.teca_vertical_reduction_clear_derived_variable_attributes(self)

# Register teca_vertical_reduction in _teca_py:
_teca_py.teca_vertical_reduction_swigregister(teca_vertical_reduction)

def teca_vertical_reduction_New():
    r"""teca_vertical_reduction_New() -> p_teca_vertical_reduction"""
    return _teca_py.teca_vertical_reduction_New()

class teca_integrated_vapor_transport(teca_vertical_reduction):
    r"""Proxy of C++ teca_integrated_vapor_transport class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_integrated_vapor_transport"""
        return _teca_py.teca_integrated_vapor_transport_New()

    def get_class_name(self):
        r"""get_class_name(teca_integrated_vapor_transport self) -> char const *"""
        return _teca_py.teca_integrated_vapor_transport_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_integrated_vapor_transport

    def set_wind_u_variable(self, v):
        r"""
        set_wind_u_variable(teca_integrated_vapor_transport self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_integrated_vapor_transport_set_wind_u_variable(self, v)

    def get_wind_u_variable(self):
        r"""get_wind_u_variable(teca_integrated_vapor_transport self) -> std::string const &"""
        return _teca_py.teca_integrated_vapor_transport_get_wind_u_variable(self)

    def set_wind_v_variable(self, v):
        r"""
        set_wind_v_variable(teca_integrated_vapor_transport self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_integrated_vapor_transport_set_wind_v_variable(self, v)

    def get_wind_v_variable(self):
        r"""get_wind_v_variable(teca_integrated_vapor_transport self) -> std::string const &"""
        return _teca_py.teca_integrated_vapor_transport_get_wind_v_variable(self)

    def set_specific_humidity_variable(self, v):
        r"""
        set_specific_humidity_variable(teca_integrated_vapor_transport self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_integrated_vapor_transport_set_specific_humidity_variable(self, v)

    def get_specific_humidity_variable(self):
        r"""get_specific_humidity_variable(teca_integrated_vapor_transport self) -> std::string const &"""
        return _teca_py.teca_integrated_vapor_transport_get_specific_humidity_variable(self)

    def set_ivt_u_variable(self, v):
        r"""
        set_ivt_u_variable(teca_integrated_vapor_transport self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_integrated_vapor_transport_set_ivt_u_variable(self, v)

    def get_ivt_u_variable(self):
        r"""get_ivt_u_variable(teca_integrated_vapor_transport self) -> std::string const &"""
        return _teca_py.teca_integrated_vapor_transport_get_ivt_u_variable(self)

    def set_ivt_v_variable(self, v):
        r"""
        set_ivt_v_variable(teca_integrated_vapor_transport self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_integrated_vapor_transport_set_ivt_v_variable(self, v)

    def get_ivt_v_variable(self):
        r"""get_ivt_v_variable(teca_integrated_vapor_transport self) -> std::string const &"""
        return _teca_py.teca_integrated_vapor_transport_get_ivt_v_variable(self)

    def set_fill_value(self, v):
        r"""
        set_fill_value(teca_integrated_vapor_transport self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_integrated_vapor_transport_set_fill_value(self, v)

    def get_fill_value(self):
        r"""get_fill_value(teca_integrated_vapor_transport self) -> double const &"""
        return _teca_py.teca_integrated_vapor_transport_get_fill_value(self)

# Register teca_integrated_vapor_transport in _teca_py:
_teca_py.teca_integrated_vapor_transport_swigregister(teca_integrated_vapor_transport)

def teca_integrated_vapor_transport_New():
    r"""teca_integrated_vapor_transport_New() -> p_teca_integrated_vapor_transport"""
    return _teca_py.teca_integrated_vapor_transport_New()

class teca_valid_value_mask(teca_algorithm):
    r"""Proxy of C++ teca_valid_value_mask class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_valid_value_mask"""
        return _teca_py.teca_valid_value_mask_New()

    def get_class_name(self):
        r"""get_class_name(teca_valid_value_mask self) -> char const *"""
        return _teca_py.teca_valid_value_mask_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_valid_value_mask

    def get_number_of_mask_arrays(self):
        r"""get_number_of_mask_arrays(teca_valid_value_mask self) -> size_t"""
        return _teca_py.teca_valid_value_mask_get_number_of_mask_arrays(self)

    def append_mask_array(self, v):
        r"""
        append_mask_array(teca_valid_value_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_valid_value_mask_append_mask_array(self, v)

    def set_mask_array(self, i, v):
        r"""
        set_mask_array(teca_valid_value_mask self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_valid_value_mask_set_mask_array(self, i, v)

    def set_mask_arrays(self, *args):
        r"""
        set_mask_arrays(teca_valid_value_mask self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_mask_arrays(teca_valid_value_mask self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_valid_value_mask_set_mask_arrays(self, *args)

    def get_mask_array(self, i):
        r"""
        get_mask_array(teca_valid_value_mask self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_valid_value_mask_get_mask_array(self, i)

    def get_mask_arrays(self):
        r"""get_mask_arrays(teca_valid_value_mask self) -> std_vector_string"""
        return _teca_py.teca_valid_value_mask_get_mask_arrays(self)

    def clear_mask_arrays(self):
        r"""clear_mask_arrays(teca_valid_value_mask self)"""
        return _teca_py.teca_valid_value_mask_clear_mask_arrays(self)

    def set_enable_valid_range(self, v):
        r"""
        set_enable_valid_range(teca_valid_value_mask self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_valid_value_mask_set_enable_valid_range(self, v)

    def get_enable_valid_range(self):
        r"""get_enable_valid_range(teca_valid_value_mask self) -> int const &"""
        return _teca_py.teca_valid_value_mask_get_enable_valid_range(self)

# Register teca_valid_value_mask in _teca_py:
_teca_py.teca_valid_value_mask_swigregister(teca_valid_value_mask)

def teca_valid_value_mask_New():
    r"""teca_valid_value_mask_New() -> p_teca_valid_value_mask"""
    return _teca_py.teca_valid_value_mask_New()

class teca_unpack_data(teca_algorithm):
    r"""Proxy of C++ teca_unpack_data class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_unpack_data"""
        return _teca_py.teca_unpack_data_New()

    def get_class_name(self):
        r"""get_class_name(teca_unpack_data self) -> char const *"""
        return _teca_py.teca_unpack_data_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_unpack_data

    def set_output_data_type(self, v):
        r"""
        set_output_data_type(teca_unpack_data self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_unpack_data_set_output_data_type(self, v)

    def get_output_data_type(self):
        r"""get_output_data_type(teca_unpack_data self) -> int const &"""
        return _teca_py.teca_unpack_data_get_output_data_type(self)

    def set_output_data_type_to_float(self):
        r"""set_output_data_type_to_float(teca_unpack_data self)"""
        return _teca_py.teca_unpack_data_set_output_data_type_to_float(self)

    def set_output_data_type_to_double(self):
        r"""set_output_data_type_to_double(teca_unpack_data self)"""
        return _teca_py.teca_unpack_data_set_output_data_type_to_double(self)

# Register teca_unpack_data in _teca_py:
_teca_py.teca_unpack_data_swigregister(teca_unpack_data)

def teca_unpack_data_New():
    r"""teca_unpack_data_New() -> p_teca_unpack_data"""
    return _teca_py.teca_unpack_data_New()

class teca_elevation_mask(teca_algorithm):
    r"""Proxy of C++ teca_elevation_mask class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_elevation_mask"""
        return _teca_py.teca_elevation_mask_New()

    def get_class_name(self):
        r"""get_class_name(teca_elevation_mask self) -> char const *"""
        return _teca_py.teca_elevation_mask_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_elevation_mask

    def set_mesh_height_variable(self, v):
        r"""
        set_mesh_height_variable(teca_elevation_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_elevation_mask_set_mesh_height_variable(self, v)

    def get_mesh_height_variable(self):
        r"""get_mesh_height_variable(teca_elevation_mask self) -> std::string const &"""
        return _teca_py.teca_elevation_mask_get_mesh_height_variable(self)

    def set_surface_elevation_variable(self, v):
        r"""
        set_surface_elevation_variable(teca_elevation_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_elevation_mask_set_surface_elevation_variable(self, v)

    def get_surface_elevation_variable(self):
        r"""get_surface_elevation_variable(teca_elevation_mask self) -> std::string const &"""
        return _teca_py.teca_elevation_mask_get_surface_elevation_variable(self)

    def get_number_of_mask_variables(self):
        r"""get_number_of_mask_variables(teca_elevation_mask self) -> size_t"""
        return _teca_py.teca_elevation_mask_get_number_of_mask_variables(self)

    def append_mask_variable(self, v):
        r"""
        append_mask_variable(teca_elevation_mask self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_elevation_mask_append_mask_variable(self, v)

    def set_mask_variable(self, i, v):
        r"""
        set_mask_variable(teca_elevation_mask self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_elevation_mask_set_mask_variable(self, i, v)

    def set_mask_variables(self, *args):
        r"""
        set_mask_variables(teca_elevation_mask self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_mask_variables(teca_elevation_mask self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_elevation_mask_set_mask_variables(self, *args)

    def get_mask_variable(self, i):
        r"""
        get_mask_variable(teca_elevation_mask self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_elevation_mask_get_mask_variable(self, i)

    def get_mask_variables(self):
        r"""get_mask_variables(teca_elevation_mask self) -> std_vector_string"""
        return _teca_py.teca_elevation_mask_get_mask_variables(self)

    def clear_mask_variables(self):
        r"""clear_mask_variables(teca_elevation_mask self)"""
        return _teca_py.teca_elevation_mask_clear_mask_variables(self)

# Register teca_elevation_mask in _teca_py:
_teca_py.teca_elevation_mask_swigregister(teca_elevation_mask)

def teca_elevation_mask_New():
    r"""teca_elevation_mask_New() -> p_teca_elevation_mask"""
    return _teca_py.teca_elevation_mask_New()

class teca_rename_variables(teca_algorithm):
    r"""Proxy of C++ teca_rename_variables class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_rename_variables"""
        return _teca_py.teca_rename_variables_New()

    def get_class_name(self):
        r"""get_class_name(teca_rename_variables self) -> char const *"""
        return _teca_py.teca_rename_variables_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_rename_variables

    def get_number_of_original_variable_names(self):
        r"""get_number_of_original_variable_names(teca_rename_variables self) -> size_t"""
        return _teca_py.teca_rename_variables_get_number_of_original_variable_names(self)

    def append_original_variable_name(self, v):
        r"""
        append_original_variable_name(teca_rename_variables self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_rename_variables_append_original_variable_name(self, v)

    def set_original_variable_name(self, i, v):
        r"""
        set_original_variable_name(teca_rename_variables self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_rename_variables_set_original_variable_name(self, i, v)

    def set_original_variable_names(self, *args):
        r"""
        set_original_variable_names(teca_rename_variables self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_original_variable_names(teca_rename_variables self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_rename_variables_set_original_variable_names(self, *args)

    def get_original_variable_name(self, i):
        r"""
        get_original_variable_name(teca_rename_variables self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_rename_variables_get_original_variable_name(self, i)

    def get_original_variable_names(self):
        r"""get_original_variable_names(teca_rename_variables self) -> std_vector_string"""
        return _teca_py.teca_rename_variables_get_original_variable_names(self)

    def clear_original_variable_names(self):
        r"""clear_original_variable_names(teca_rename_variables self)"""
        return _teca_py.teca_rename_variables_clear_original_variable_names(self)

    def get_number_of_new_variable_names(self):
        r"""get_number_of_new_variable_names(teca_rename_variables self) -> size_t"""
        return _teca_py.teca_rename_variables_get_number_of_new_variable_names(self)

    def append_new_variable_name(self, v):
        r"""
        append_new_variable_name(teca_rename_variables self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_rename_variables_append_new_variable_name(self, v)

    def set_new_variable_name(self, i, v):
        r"""
        set_new_variable_name(teca_rename_variables self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_rename_variables_set_new_variable_name(self, i, v)

    def set_new_variable_names(self, *args):
        r"""
        set_new_variable_names(teca_rename_variables self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_new_variable_names(teca_rename_variables self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_rename_variables_set_new_variable_names(self, *args)

    def get_new_variable_name(self, i):
        r"""
        get_new_variable_name(teca_rename_variables self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_rename_variables_get_new_variable_name(self, i)

    def get_new_variable_names(self):
        r"""get_new_variable_names(teca_rename_variables self) -> std_vector_string"""
        return _teca_py.teca_rename_variables_get_new_variable_names(self)

    def clear_new_variable_names(self):
        r"""clear_new_variable_names(teca_rename_variables self)"""
        return _teca_py.teca_rename_variables_clear_new_variable_names(self)

# Register teca_rename_variables in _teca_py:
_teca_py.teca_rename_variables_swigregister(teca_rename_variables)

def teca_rename_variables_New():
    r"""teca_rename_variables_New() -> p_teca_rename_variables"""
    return _teca_py.teca_rename_variables_New()

class teca_indexed_dataset_cache(teca_algorithm):
    r"""Proxy of C++ teca_indexed_dataset_cache class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_indexed_dataset_cache"""
        return _teca_py.teca_indexed_dataset_cache_New()

    def get_class_name(self):
        r"""get_class_name(teca_indexed_dataset_cache self) -> char const *"""
        return _teca_py.teca_indexed_dataset_cache_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_indexed_dataset_cache

    def set_max_cache_size(self, v):
        r"""
        set_max_cache_size(teca_indexed_dataset_cache self, unsigned long const & v)

        Parameters
        ----------
        v: unsigned long const &

        """
        return _teca_py.teca_indexed_dataset_cache_set_max_cache_size(self, v)

    def get_max_cache_size(self):
        r"""get_max_cache_size(teca_indexed_dataset_cache self) -> unsigned long const &"""
        return _teca_py.teca_indexed_dataset_cache_get_max_cache_size(self)

    def clear_cache(self):
        r"""clear_cache(teca_indexed_dataset_cache self)"""
        return _teca_py.teca_indexed_dataset_cache_clear_cache(self)

# Register teca_indexed_dataset_cache in _teca_py:
_teca_py.teca_indexed_dataset_cache_swigregister(teca_indexed_dataset_cache)

def teca_indexed_dataset_cache_New():
    r"""teca_indexed_dataset_cache_New() -> p_teca_indexed_dataset_cache"""
    return _teca_py.teca_indexed_dataset_cache_New()

class teca_apply_tempest_remap(teca_algorithm):
    r"""Proxy of C++ teca_apply_tempest_remap class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_apply_tempest_remap"""
        return _teca_py.teca_apply_tempest_remap_New()

    def get_class_name(self):
        r"""get_class_name(teca_apply_tempest_remap self) -> char const *"""
        return _teca_py.teca_apply_tempest_remap_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_apply_tempest_remap

    def set_weights_variable(self, v):
        r"""
        set_weights_variable(teca_apply_tempest_remap self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_apply_tempest_remap_set_weights_variable(self, v)

    def get_weights_variable(self):
        r"""get_weights_variable(teca_apply_tempest_remap self) -> std::string const &"""
        return _teca_py.teca_apply_tempest_remap_get_weights_variable(self)

    def set_row_variable(self, v):
        r"""
        set_row_variable(teca_apply_tempest_remap self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_apply_tempest_remap_set_row_variable(self, v)

    def get_row_variable(self):
        r"""get_row_variable(teca_apply_tempest_remap self) -> std::string const &"""
        return _teca_py.teca_apply_tempest_remap_get_row_variable(self)

    def set_column_variable(self, v):
        r"""
        set_column_variable(teca_apply_tempest_remap self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_apply_tempest_remap_set_column_variable(self, v)

    def get_column_variable(self):
        r"""get_column_variable(teca_apply_tempest_remap self) -> std::string const &"""
        return _teca_py.teca_apply_tempest_remap_get_column_variable(self)

    def set_target_mask_variable(self, v):
        r"""
        set_target_mask_variable(teca_apply_tempest_remap self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_apply_tempest_remap_set_target_mask_variable(self, v)

    def get_target_mask_variable(self):
        r"""get_target_mask_variable(teca_apply_tempest_remap self) -> std::string const &"""
        return _teca_py.teca_apply_tempest_remap_get_target_mask_variable(self)

    def set_static_target_mesh(self, v):
        r"""
        set_static_target_mesh(teca_apply_tempest_remap self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_apply_tempest_remap_set_static_target_mesh(self, v)

    def get_static_target_mesh(self):
        r"""get_static_target_mesh(teca_apply_tempest_remap self) -> int const &"""
        return _teca_py.teca_apply_tempest_remap_get_static_target_mesh(self)

# Register teca_apply_tempest_remap in _teca_py:
_teca_py.teca_apply_tempest_remap_swigregister(teca_apply_tempest_remap)

def teca_apply_tempest_remap_New():
    r"""teca_apply_tempest_remap_New() -> p_teca_apply_tempest_remap"""
    return _teca_py.teca_apply_tempest_remap_New()

class teca_cartesian_mesh_coordinate_transform(teca_algorithm):
    r"""Proxy of C++ teca_cartesian_mesh_coordinate_transform class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_cartesian_mesh_coordinate_transform"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_New()

    def get_class_name(self):
        r"""get_class_name(teca_cartesian_mesh_coordinate_transform self) -> char const *"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_cartesian_mesh_coordinate_transform

    def get_number_of_target_bounds(self):
        r"""get_number_of_target_bounds(teca_cartesian_mesh_coordinate_transform self) -> size_t"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_number_of_target_bounds(self)

    def append_target_bound(self, v):
        r"""
        append_target_bound(teca_cartesian_mesh_coordinate_transform self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_append_target_bound(self, v)

    def set_target_bound(self, i, v):
        r"""
        set_target_bound(teca_cartesian_mesh_coordinate_transform self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_set_target_bound(self, i, v)

    def get_target_bound(self, i):
        r"""
        get_target_bound(teca_cartesian_mesh_coordinate_transform self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_target_bound(self, i)

    def get_target_bounds(self):
        r"""get_target_bounds(teca_cartesian_mesh_coordinate_transform self) -> std_vector_double"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_target_bounds(self)

    def clear_target_bounds(self):
        r"""clear_target_bounds(teca_cartesian_mesh_coordinate_transform self)"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_clear_target_bounds(self)

    def set_target_bounds(self, *args):
        r"""
        set_target_bounds(teca_cartesian_mesh_coordinate_transform self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_target_bounds(teca_cartesian_mesh_coordinate_transform self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        set_target_bounds(teca_cartesian_mesh_coordinate_transform self, teca_metadata md) -> int

        Parameters
        ----------
        md: teca_metadata const &

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_set_target_bounds(self, *args)

    def set_x_axis_variable(self, v):
        r"""
        set_x_axis_variable(teca_cartesian_mesh_coordinate_transform self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_set_x_axis_variable(self, v)

    def get_x_axis_variable(self):
        r"""get_x_axis_variable(teca_cartesian_mesh_coordinate_transform self) -> std::string const &"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_x_axis_variable(self)

    def set_y_axis_variable(self, v):
        r"""
        set_y_axis_variable(teca_cartesian_mesh_coordinate_transform self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_set_y_axis_variable(self, v)

    def get_y_axis_variable(self):
        r"""get_y_axis_variable(teca_cartesian_mesh_coordinate_transform self) -> std::string const &"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_y_axis_variable(self)

    def set_z_axis_variable(self, v):
        r"""
        set_z_axis_variable(teca_cartesian_mesh_coordinate_transform self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_set_z_axis_variable(self, v)

    def get_z_axis_variable(self):
        r"""get_z_axis_variable(teca_cartesian_mesh_coordinate_transform self) -> std::string const &"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_z_axis_variable(self)

    def set_x_axis_units(self, v):
        r"""
        set_x_axis_units(teca_cartesian_mesh_coordinate_transform self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_set_x_axis_units(self, v)

    def get_x_axis_units(self):
        r"""get_x_axis_units(teca_cartesian_mesh_coordinate_transform self) -> std::string const &"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_x_axis_units(self)

    def set_y_axis_units(self, v):
        r"""
        set_y_axis_units(teca_cartesian_mesh_coordinate_transform self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_set_y_axis_units(self, v)

    def get_y_axis_units(self):
        r"""get_y_axis_units(teca_cartesian_mesh_coordinate_transform self) -> std::string const &"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_y_axis_units(self)

    def set_z_axis_units(self, v):
        r"""
        set_z_axis_units(teca_cartesian_mesh_coordinate_transform self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_coordinate_transform_set_z_axis_units(self, v)

    def get_z_axis_units(self):
        r"""get_z_axis_units(teca_cartesian_mesh_coordinate_transform self) -> std::string const &"""
        return _teca_py.teca_cartesian_mesh_coordinate_transform_get_z_axis_units(self)

# Register teca_cartesian_mesh_coordinate_transform in _teca_py:
_teca_py.teca_cartesian_mesh_coordinate_transform_swigregister(teca_cartesian_mesh_coordinate_transform)

def teca_cartesian_mesh_coordinate_transform_New():
    r"""teca_cartesian_mesh_coordinate_transform_New() -> p_teca_cartesian_mesh_coordinate_transform"""
    return _teca_py.teca_cartesian_mesh_coordinate_transform_New()

class teca_time_axis_convolution(teca_algorithm):
    r"""Proxy of C++ teca_time_axis_convolution class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_time_axis_convolution"""
        return _teca_py.teca_time_axis_convolution_New()

    def get_class_name(self):
        r"""get_class_name(teca_time_axis_convolution self) -> char const *"""
        return _teca_py.teca_time_axis_convolution_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_time_axis_convolution
    backward = _teca_py.teca_time_axis_convolution_backward
    
    centered = _teca_py.teca_time_axis_convolution_centered
    
    forward = _teca_py.teca_time_axis_convolution_forward
    

    def get_stencil_type(self):
        r"""get_stencil_type(teca_time_axis_convolution self) -> int const &"""
        return _teca_py.teca_time_axis_convolution_get_stencil_type(self)

    def set_stencil_type_to_forward(self):
        r"""set_stencil_type_to_forward(teca_time_axis_convolution self)"""
        return _teca_py.teca_time_axis_convolution_set_stencil_type_to_forward(self)

    def set_stencil_type_to_backward(self):
        r"""set_stencil_type_to_backward(teca_time_axis_convolution self)"""
        return _teca_py.teca_time_axis_convolution_set_stencil_type_to_backward(self)

    def set_stencil_type_to_centered(self):
        r"""set_stencil_type_to_centered(teca_time_axis_convolution self)"""
        return _teca_py.teca_time_axis_convolution_set_stencil_type_to_centered(self)

    def set_stencil_type(self, *args):
        r"""
        set_stencil_type(teca_time_axis_convolution self, int const & v)

        Parameters
        ----------
        v: int const &

        set_stencil_type(teca_time_axis_convolution self, std::string const & type) -> int

        Parameters
        ----------
        type: std::string const &

        """
        return _teca_py.teca_time_axis_convolution_set_stencil_type(self, *args)

    def get_stencil_type_name(self):
        r"""get_stencil_type_name(teca_time_axis_convolution self) -> std::string"""
        return _teca_py.teca_time_axis_convolution_get_stencil_type_name(self)

    def set_use_high_pass(self, v):
        r"""
        set_use_high_pass(teca_time_axis_convolution self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_time_axis_convolution_set_use_high_pass(self, v)

    def get_use_high_pass(self):
        r"""get_use_high_pass(teca_time_axis_convolution self) -> int const &"""
        return _teca_py.teca_time_axis_convolution_get_use_high_pass(self)

    def set_kernel_width(self, v):
        r"""
        set_kernel_width(teca_time_axis_convolution self, unsigned int const & v)

        Parameters
        ----------
        v: unsigned int const &

        """
        return _teca_py.teca_time_axis_convolution_set_kernel_width(self, v)

    def get_kernel_width(self):
        r"""get_kernel_width(teca_time_axis_convolution self) -> unsigned int const &"""
        return _teca_py.teca_time_axis_convolution_get_kernel_width(self)

    def get_number_of_kernel_weights(self):
        r"""get_number_of_kernel_weights(teca_time_axis_convolution self) -> size_t"""
        return _teca_py.teca_time_axis_convolution_get_number_of_kernel_weights(self)

    def append_kernel_weight(self, v):
        r"""
        append_kernel_weight(teca_time_axis_convolution self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_time_axis_convolution_append_kernel_weight(self, v)

    def set_kernel_weight(self, i, v):
        r"""
        set_kernel_weight(teca_time_axis_convolution self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_time_axis_convolution_set_kernel_weight(self, i, v)

    def get_kernel_weight(self, i):
        r"""
        get_kernel_weight(teca_time_axis_convolution self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_time_axis_convolution_get_kernel_weight(self, i)

    def get_kernel_weights(self):
        r"""get_kernel_weights(teca_time_axis_convolution self) -> std_vector_double"""
        return _teca_py.teca_time_axis_convolution_get_kernel_weights(self)

    def clear_kernel_weights(self):
        r"""clear_kernel_weights(teca_time_axis_convolution self)"""
        return _teca_py.teca_time_axis_convolution_clear_kernel_weights(self)

    def set_constant_kernel_weights(self, width):
        r"""
        set_constant_kernel_weights(teca_time_axis_convolution self, unsigned int width) -> int

        Parameters
        ----------
        width: unsigned int

        """
        return _teca_py.teca_time_axis_convolution_set_constant_kernel_weights(self, width)

    def set_gaussian_kernel_weights(self, width, high_pass=0, a=1.0, B=0.0, c=0.55):
        r"""
        set_gaussian_kernel_weights(teca_time_axis_convolution self, unsigned int width, int high_pass=0, double a=1.0, double B=0.0, double c=0.55) -> int

        Parameters
        ----------
        width: unsigned int
        high_pass: int
        a: double
        B: double
        c: double

        """
        return _teca_py.teca_time_axis_convolution_set_gaussian_kernel_weights(self, width, high_pass, a, B, c)

    def set_kernel_weights(self, *args):
        r"""
        set_kernel_weights(teca_time_axis_convolution self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_kernel_weights(teca_time_axis_convolution self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        set_kernel_weights(teca_time_axis_convolution self, std::string const & name, unsigned int width, int high_pass) -> int

        Parameters
        ----------
        name: std::string const &
        width: unsigned int
        high_pass: int

        """
        return _teca_py.teca_time_axis_convolution_set_kernel_weights(self, *args)

    def set_kernel_name(self, v):
        r"""
        set_kernel_name(teca_time_axis_convolution self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_time_axis_convolution_set_kernel_name(self, v)

    def get_kernel_name(self):
        r"""get_kernel_name(teca_time_axis_convolution self) -> std::string const &"""
        return _teca_py.teca_time_axis_convolution_get_kernel_name(self)

    def set_variable_postfix(self, v):
        r"""
        set_variable_postfix(teca_time_axis_convolution self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_time_axis_convolution_set_variable_postfix(self, v)

    def get_variable_postfix(self):
        r"""get_variable_postfix(teca_time_axis_convolution self) -> std::string const &"""
        return _teca_py.teca_time_axis_convolution_get_variable_postfix(self)

# Register teca_time_axis_convolution in _teca_py:
_teca_py.teca_time_axis_convolution_swigregister(teca_time_axis_convolution)

def teca_time_axis_convolution_New():
    r"""teca_time_axis_convolution_New() -> p_teca_time_axis_convolution"""
    return _teca_py.teca_time_axis_convolution_New()

import numpy


class teca_python_vertical_reduction(teca_python_algorithm):
    """
    The base class used for writing new vertical reduction algorithms
    in Python. Contains plumbing that connects user provided overrides
    to an instance of teca_vertical_reduction. Users are expected to
    override one or more of report, request, and/or execute.
    """

    derived_variables_attributes = {}
    dependent_variables = []

    def set_dependent_variables(self, variables_list):
        if type(variables_list) is str:
            variables_list = [variables_list]

        self.dependent_variables = variables_list

    def get_derived_variables(self):
        return list(self.derived_variables_attributes)

    def add_derived_variable_and_attributes(self, var, attributes):
        self.derived_variables_attributes[var] = attributes

    def report(self, port, input_md):
        """ Define the TECA report phase for this algorithm"""
        out_md = teca_metadata(input_md[0])

        attributes = out_md["attributes"]

# set the variables and their attributes
        for var in self.get_derived_variables():
            attributes[var] = self.derived_variables_attributes[var].\
                              to_metadata()
        out_md["attributes"] = attributes

# get the input extents
        whole_extent = out_md["whole_extent"]

# set the output extent, with vertical dim reduced
        whole_extent[4] = whole_extent[5] = 0
        out_md["whole_extent"] = whole_extent

# fix bounds if it is present
        bounds = out_md["bounds"]
        bounds[4] = bounds[5] = 0.0
        out_md["bounds"] = bounds

        return out_md

    def request(self, port, input_md, request):
        """ Define the TECA request phase for this algorithm"""

        up_reqs = []

# copy the incoming request to preserve the downstream
# requirements and add the arrays we need
        req = teca_metadata(request)

# transform extent, add back the vertical dimension
        md = teca_metadata(input_md[0])

# get the whole extent and bounds
        bounds = numpy.zeros(6, dtype=numpy.int32)
        whole_extent = numpy.zeros(6, dtype=numpy.int32)
        bounds = md["bounds"]
        whole_extent = md["whole_extent"]

        try:
            bounds_up = request["bounds"]
            has_bounds = True
        except KeyError:
            has_bounds = False

        try:
            extent_up = request["extent"]
            has_extent = True
        except KeyError:
            has_extent = False

# restore vertical bounds
        if has_bounds:
            bounds_up[4] = bounds[4]
            bounds_up[5] = bounds[5]
            req["bounds"] = bounds_up
# restore vertical extent
        elif has_extent:
            extent_up[4] = whole_extent[4]
            extent_up[5] = whole_extent[5]
            req["extent"] = extent_up
# no subset requested, request all the data
        else:
            req["extent"] = whole_extent

# get the list of variable available. we need to see if
# the valid value mask is available and if so request it
        variables = md["variables"]

# add the dependent variables into the requested arrays
        arrays = req["arrays"]

# convert the array list to a list if needed
        if type(arrays) is str:
            arrays = [arrays]

        for dep_var in self.dependent_variables:
# request the array needed for the calculation
            arrays.append(dep_var)

# request the valid value mask if they are available.
            mask_var = dep_var + "_valid"
            if (mask_var in variables):
                arrays.append(mask_var)

# capture the arrays we produce
        for var in self.get_derived_variables():
            arrays.remove(var)

# update the request
        req["arrays"] = arrays

# send it up
        up_reqs.append(req)

        return up_reqs

    def execute(self, port, input_data, request):
        """ Define the TECA execute phase for this algorithm"""
# get the input mesh
        in_mesh = as_const_teca_cartesian_mesh(input_data[0])

# construct the output
        out_mesh = as_const_teca_cartesian_mesh(in_mesh.new_instance())

# copy metadata
        out_mesh.copy_metadata(in_mesh)

# fix the metadata
        out_md = teca_metadata(out_mesh.get_metadata())

# fix whole extent
        try:
            whole_extent = out_md["whole_extent"]
            whole_extent[4] = whole_extent[5] = 0
            out_md["whole_extent"] = whole_extent
        except KeyError:
            pass

# fix extent
        try:
            extent = out_md["extent"]
            extent[4] = extent[5] = 0
            out_md["extent"] = extent
        except KeyError:
            pass

# fix bounds
        try:
            bounds = out_md["bounds"]
            bounds[4] = bounds[5] = 0
            out_md["bounds"] = bounds
        except KeyError:
            pass

        out_mesh.set_metadata(out_md)

# fix the z axis
        cart_mesh = as_const_teca_cartesian_mesh(out_mesh)

        z_var = cart_mesh.get_z_coordinate_variable()

        in_z = cart_mesh.get_z_coordinates()

        out_z = in_z.new_instance(1)
        cart_mesh.set_z_coordinates(z_var, out_z)

        return out_mesh

import numpy
if get_teca_has_cupy():
    import cupy
import sys


class teca_lapse_rate(teca_python_vertical_reduction):

    t_var = "T"
    z_var = "Z"
    zs_var = "ZS"
    zmax = 9000
    z_is_geopotential = True
    fill_value = 1e20
    gravity = 9.806

    def set_t_var(self, t_var):
        """ Sets the temperature variable name. """
        self.t_var = t_var

    def set_z_var(self, z_var):
        """ Sets the geopotential height variable name. """
        self.z_var = z_var

    def set_zs_var(self, zs_var):
        """ Sets the surface geopotential height variable name. """
        self.zs_var = zs_var

    def set_zmax(self, zmax):
        """ Sets the maximum height to use in the lapse rate calculation. """
        self.zmax = zmax

    def set_geopotential_flag(self, geopotential_flag):
        """ Flags whether z is geopotential (units m^2/s^2) or height (m) """
        self.z_is_geopotential = geopotential_flag

    def set_fill_value(self, fill_value):
        self.fill_value = fill_value

    def get_fill_value(self, fill_value):
        return self.fill_value

    def get_point_array_names(self):
        """ Returns the names of the output arrays """
        return ["lapse_rate"]

    def calculate_lapse_rate(self, dev, t, z, zs, zmax=9000):
        """ Calculates the mean lapse rate.

            input:
            ------

                t  : atmospheric temperature [K]

                z  : geopotential height [m]

                zs : surface geopotential height [m]

                zmax : the maximum height to consider in the lapse rate
                       calculation [m]

            output:
            -------

                dtdz : the mean lapse rate [K/m]


        Uses 1st order finite difference to estimate the lapse rate at all
        available levels and then averages. Levels below the surface are
        masked, and levels above zmax are masked.

        It is assumed that the vertical dimension is the first dimension
        e.g., [level, lat, lon]) for both t and z.

        """

# check shapes
        if t.shape != z.shape:
            raise RuntimeError('ERROR: t and z must have the same shape;'
                    ' shape(t) = %s but shape(z) = %s' % (str(t.shape),str(z.shape)))
        if z[0, ...].shape != zs.shape:
            raise RuntimeError('ERROR: All but the first dimension'
                   ' of z must match the dimensions of zs;'
                   ' shape(z) = %s but shape(zs) = %s' % (str(z.shape),str(zs.shape)))

# select GPU or CPU
        if dev < 0:
            np = numpy
        else:
            np = cupy

# mask temperature and height
# for under-topo values and values that are above the max height
        t_mask = np.where((z >= zs[np.newaxis, ...]) & (z < zmax), t, np.nan)
        z_mask = np.where((z >= zs[np.newaxis, ...]) & (z < zmax), z, np.nan)

# calculate the lapse rate between each level
        dt = np.diff(t_mask, axis=0)
        dz = np.diff(z_mask, axis=0)

# calculate the average lapse rate
        dtdz = np.nanmean((dt/dz), axis=0)

        return dtdz

    def request(self, port, md_in, req_in):
        """ Define the TECA request phase. """

        self.set_dependent_variables(
            [
                self.t_var,
                self.z_var,
                self.zs_var,
            ]
        )

        return super().request(port, md_in, req_in)

    def report(self, port, md_in):
        """ Define the TECA report phase """
        md = teca_metadata(md_in[0])

        lapse_atts = teca_array_attributes(
            teca_double_array_code.get(),
            teca_array_attributes.point_centering,
            0, 'k/m', 'Average Lapse Rate', "Average lapse rate \
            below {self.zmax} m", self.fill_value,
        )

# add the variables
        self.add_derived_variable_and_attributes("lapse_rate", lapse_atts)

        return super().report(port, md_in)

    def execute(self, port, data_in, req):
        """Define the TECA execute phase for this algorithm.
           Outputs a 2D array of lapserates. """

# get the device to run on
        dev = -1
        np = numpy
        if get_teca_has_cuda() and get_teca_has_cupy():
            dev = req['device_id']
            if dev >= 0:
                cupy.cuda.Device(dev).use()
                np = cupy
# report
        if self.get_verbose():
            dev_str = 'CPU' if dev < 0 else 'GPU %d' % (dev)
            sys.stderr.write('teca_lapse_rate::execute %s\n' % (dev_str))

# get the input mesh
        in_mesh = as_const_teca_cartesian_mesh(data_in[0])

# initialize the output mesh from the super function
        out_mesh = as_const_teca_cartesian_mesh(
                   super().execute(port, data_in, req))

# get the pressure level
        level = in_mesh.get_z_coordinates()

# get horizontal coordinates
        lon = in_mesh.get_x_coordinates()
        lat = in_mesh.get_y_coordinates()

        def reshape3d(in_var):
            return np.reshape(in_var, [len(level), len(lat), len(lon)])

        def reshape2d(in_var):
            return np.reshape(in_var, [len(lat), len(lon)])

        arrays = in_mesh.get_point_arrays()
        if dev < 0:
            in_t = arrays[self.t_var].get_cpu_accessible()
            in_z = arrays[self.z_var].get_cpu_accessible()
            in_zs = arrays[self.zs_var].get_cpu_accessible()
        else:
            in_t = arrays[self.t_var].get_cuda_accessible()
            in_z = arrays[self.z_var].get_cuda_accessible()
            in_zs = arrays[self.zs_var].get_cuda_accessible()

# get temperature, surface geopotential and level geopotential
        t = reshape3d(in_t)
        z = reshape3d(in_z)
        zs = reshape2d(in_zs)

# convert to units of meters if needd
        if self.z_is_geopotential:
            z /= self.gravity
            zs /= self.gravity

# calculate cloud base height
        lapse_rate = self.calculate_lapse_rate(
            dev,
            t.astype(np.float64),
            z.astype(np.float64),
            zs.astype(np.float64),
            zmax=self.zmax
        )

        out_arrays = out_mesh.get_point_arrays()
        out_arrays['lapse_rate'] = lapse_rate.ravel()

# return the current lapse rate mesh
        return out_mesh

class teca_cf_reader(teca_algorithm):
    r"""Proxy of C++ teca_cf_reader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_cf_reader"""
        return _teca_py.teca_cf_reader_New()

    def get_class_name(self):
        r"""get_class_name(teca_cf_reader self) -> char const *"""
        return _teca_py.teca_cf_reader_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_cf_reader

    def get_number_of_file_names(self):
        r"""get_number_of_file_names(teca_cf_reader self) -> size_t"""
        return _teca_py.teca_cf_reader_get_number_of_file_names(self)

    def append_file_name(self, v):
        r"""
        append_file_name(teca_cf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_append_file_name(self, v)

    def set_file_name(self, i, v):
        r"""
        set_file_name(teca_cf_reader self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_set_file_name(self, i, v)

    def set_file_names(self, *args):
        r"""
        set_file_names(teca_cf_reader self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_file_names(teca_cf_reader self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_cf_reader_set_file_names(self, *args)

    def get_file_name(self, i):
        r"""
        get_file_name(teca_cf_reader self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cf_reader_get_file_name(self, i)

    def get_file_names(self):
        r"""get_file_names(teca_cf_reader self) -> std_vector_string"""
        return _teca_py.teca_cf_reader_get_file_names(self)

    def clear_file_names(self):
        r"""clear_file_names(teca_cf_reader self)"""
        return _teca_py.teca_cf_reader_clear_file_names(self)

    def set_files_regex(self, v):
        r"""
        set_files_regex(teca_cf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_set_files_regex(self, v)

    def get_files_regex(self):
        r"""get_files_regex(teca_cf_reader self) -> std::string const &"""
        return _teca_py.teca_cf_reader_get_files_regex(self)

    def set_periodic_in_x(self, v):
        r"""
        set_periodic_in_x(teca_cf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cf_reader_set_periodic_in_x(self, v)

    def get_periodic_in_x(self):
        r"""get_periodic_in_x(teca_cf_reader self) -> int const &"""
        return _teca_py.teca_cf_reader_get_periodic_in_x(self)

    def set_periodic_in_y(self, v):
        r"""
        set_periodic_in_y(teca_cf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cf_reader_set_periodic_in_y(self, v)

    def get_periodic_in_y(self):
        r"""get_periodic_in_y(teca_cf_reader self) -> int const &"""
        return _teca_py.teca_cf_reader_get_periodic_in_y(self)

    def set_periodic_in_z(self, v):
        r"""
        set_periodic_in_z(teca_cf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cf_reader_set_periodic_in_z(self, v)

    def get_periodic_in_z(self):
        r"""get_periodic_in_z(teca_cf_reader self) -> int const &"""
        return _teca_py.teca_cf_reader_get_periodic_in_z(self)

    def set_x_axis_variable(self, v):
        r"""
        set_x_axis_variable(teca_cf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_set_x_axis_variable(self, v)

    def get_x_axis_variable(self):
        r"""get_x_axis_variable(teca_cf_reader self) -> std::string const &"""
        return _teca_py.teca_cf_reader_get_x_axis_variable(self)

    def set_y_axis_variable(self, v):
        r"""
        set_y_axis_variable(teca_cf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_set_y_axis_variable(self, v)

    def get_y_axis_variable(self):
        r"""get_y_axis_variable(teca_cf_reader self) -> std::string const &"""
        return _teca_py.teca_cf_reader_get_y_axis_variable(self)

    def set_z_axis_variable(self, v):
        r"""
        set_z_axis_variable(teca_cf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_set_z_axis_variable(self, v)

    def get_z_axis_variable(self):
        r"""get_z_axis_variable(teca_cf_reader self) -> std::string const &"""
        return _teca_py.teca_cf_reader_get_z_axis_variable(self)

    def set_t_axis_variable(self, v):
        r"""
        set_t_axis_variable(teca_cf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_set_t_axis_variable(self, v)

    def get_t_axis_variable(self):
        r"""get_t_axis_variable(teca_cf_reader self) -> std::string const &"""
        return _teca_py.teca_cf_reader_get_t_axis_variable(self)

    def set_calendar(self, v):
        r"""
        set_calendar(teca_cf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_set_calendar(self, v)

    def get_calendar(self):
        r"""get_calendar(teca_cf_reader self) -> std::string const &"""
        return _teca_py.teca_cf_reader_get_calendar(self)

    def set_t_units(self, v):
        r"""
        set_t_units(teca_cf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_set_t_units(self, v)

    def get_t_units(self):
        r"""get_t_units(teca_cf_reader self) -> std::string const &"""
        return _teca_py.teca_cf_reader_get_t_units(self)

    def set_filename_time_template(self, v):
        r"""
        set_filename_time_template(teca_cf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_reader_set_filename_time_template(self, v)

    def get_filename_time_template(self):
        r"""get_filename_time_template(teca_cf_reader self) -> std::string const &"""
        return _teca_py.teca_cf_reader_get_filename_time_template(self)

    def get_number_of_t_values(self):
        r"""get_number_of_t_values(teca_cf_reader self) -> size_t"""
        return _teca_py.teca_cf_reader_get_number_of_t_values(self)

    def append_t_value(self, v):
        r"""
        append_t_value(teca_cf_reader self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_cf_reader_append_t_value(self, v)

    def set_t_value(self, i, v):
        r"""
        set_t_value(teca_cf_reader self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_cf_reader_set_t_value(self, i, v)

    def set_t_values(self, *args):
        r"""
        set_t_values(teca_cf_reader self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_t_values(teca_cf_reader self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_cf_reader_set_t_values(self, *args)

    def get_t_value(self, i):
        r"""
        get_t_value(teca_cf_reader self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cf_reader_get_t_value(self, i)

    def get_t_values(self):
        r"""get_t_values(teca_cf_reader self) -> std_vector_double"""
        return _teca_py.teca_cf_reader_get_t_values(self)

    def clear_t_values(self):
        r"""clear_t_values(teca_cf_reader self)"""
        return _teca_py.teca_cf_reader_clear_t_values(self)

    def set_max_metadata_ranks(self, v):
        r"""
        set_max_metadata_ranks(teca_cf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cf_reader_set_max_metadata_ranks(self, v)

    def get_max_metadata_ranks(self):
        r"""get_max_metadata_ranks(teca_cf_reader self) -> int const &"""
        return _teca_py.teca_cf_reader_get_max_metadata_ranks(self)

    def set_clamp_dimensions_of_one(self, v):
        r"""
        set_clamp_dimensions_of_one(teca_cf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cf_reader_set_clamp_dimensions_of_one(self, v)

    def get_clamp_dimensions_of_one(self):
        r"""get_clamp_dimensions_of_one(teca_cf_reader self) -> int const &"""
        return _teca_py.teca_cf_reader_get_clamp_dimensions_of_one(self)

# Register teca_cf_reader in _teca_py:
_teca_py.teca_cf_reader_swigregister(teca_cf_reader)

def teca_cf_reader_New():
    r"""teca_cf_reader_New() -> p_teca_cf_reader"""
    return _teca_py.teca_cf_reader_New()

class teca_multi_cf_reader(teca_algorithm):
    r"""Proxy of C++ teca_multi_cf_reader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_multi_cf_reader"""
        return _teca_py.teca_multi_cf_reader_New()

    def get_class_name(self):
        r"""get_class_name(teca_multi_cf_reader self) -> char const *"""
        return _teca_py.teca_multi_cf_reader_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_multi_cf_reader

    def set_input_file(self, input_file):
        r"""
        set_input_file(teca_multi_cf_reader self, std::string const & input_file) -> int

        Parameters
        ----------
        input_file: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_input_file(self, input_file)

    def get_input_file(self):
        r"""get_input_file(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_input_file(self)

    def add_reader(self, regex, key, provides_time, provides_geometry, variables):
        r"""
        add_reader(teca_multi_cf_reader self, std::string const & regex, std::string const & key, int provides_time, int provides_geometry, std_vector_string variables) -> int

        Parameters
        ----------
        regex: std::string const &
        key: std::string const &
        provides_time: int
        provides_geometry: int
        variables: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _teca_py.teca_multi_cf_reader_add_reader(self, regex, key, provides_time, provides_geometry, variables)

    def set_time_reader(self, key):
        r"""
        set_time_reader(teca_multi_cf_reader self, std::string const & key) -> int

        Parameters
        ----------
        key: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_time_reader(self, key)

    def set_geometry_reader(self, key):
        r"""
        set_geometry_reader(teca_multi_cf_reader self, std::string const & key) -> int

        Parameters
        ----------
        key: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_geometry_reader(self, key)

    def add_variable_reader(self, key, variable):
        r"""
        add_variable_reader(teca_multi_cf_reader self, std::string const & key, std::string const & variable) -> int

        Parameters
        ----------
        key: std::string const &
        variable: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_add_variable_reader(self, key, variable)

    def set_variable_reader(self, key, variable):
        r"""
        set_variable_reader(teca_multi_cf_reader self, std::string const & key, std_vector_string variable) -> int

        Parameters
        ----------
        key: std::string const &
        variable: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _teca_py.teca_multi_cf_reader_set_variable_reader(self, key, variable)

    def set_periodic_in_x(self, flag):
        r"""
        set_periodic_in_x(teca_multi_cf_reader self, int flag)

        Parameters
        ----------
        flag: int

        """
        return _teca_py.teca_multi_cf_reader_set_periodic_in_x(self, flag)

    def get_periodic_in_x(self):
        r"""get_periodic_in_x(teca_multi_cf_reader self) -> int"""
        return _teca_py.teca_multi_cf_reader_get_periodic_in_x(self)

    def set_x_axis_variable(self, var):
        r"""
        set_x_axis_variable(teca_multi_cf_reader self, std::string const & var)

        Parameters
        ----------
        var: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_x_axis_variable(self, var)

    def get_x_axis_variable(self):
        r"""get_x_axis_variable(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_x_axis_variable(self)

    def set_y_axis_variable(self, var):
        r"""
        set_y_axis_variable(teca_multi_cf_reader self, std::string const & var)

        Parameters
        ----------
        var: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_y_axis_variable(self, var)

    def get_y_axis_variable(self):
        r"""get_y_axis_variable(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_y_axis_variable(self)

    def set_z_axis_variable(self, var):
        r"""
        set_z_axis_variable(teca_multi_cf_reader self, std::string const & var)

        Parameters
        ----------
        var: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_z_axis_variable(self, var)

    def get_z_axis_variable(self):
        r"""get_z_axis_variable(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_z_axis_variable(self)

    def set_t_axis_variable(self, var):
        r"""
        set_t_axis_variable(teca_multi_cf_reader self, std::string const & var)

        Parameters
        ----------
        var: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_t_axis_variable(self, var)

    def get_t_axis_variable(self):
        r"""get_t_axis_variable(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_t_axis_variable(self)

    def set_calendar(self, calendar):
        r"""
        set_calendar(teca_multi_cf_reader self, std::string const & calendar)

        Parameters
        ----------
        calendar: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_calendar(self, calendar)

    def get_calendar(self):
        r"""get_calendar(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_calendar(self)

    def set_t_units(self, units):
        r"""
        set_t_units(teca_multi_cf_reader self, std::string const & units)

        Parameters
        ----------
        units: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_t_units(self, units)

    def get_t_units(self):
        r"""get_t_units(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_t_units(self)

    def set_filename_time_template(self, templ):
        r"""
        set_filename_time_template(teca_multi_cf_reader self, std::string const & templ)

        Parameters
        ----------
        templ: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_filename_time_template(self, templ)

    def get_filename_time_template(self):
        r"""get_filename_time_template(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_filename_time_template(self)

    def get_number_of_t_values(self):
        r"""get_number_of_t_values(teca_multi_cf_reader self) -> size_t"""
        return _teca_py.teca_multi_cf_reader_get_number_of_t_values(self)

    def append_t_value(self, v):
        r"""
        append_t_value(teca_multi_cf_reader self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_multi_cf_reader_append_t_value(self, v)

    def set_t_value(self, i, v):
        r"""
        set_t_value(teca_multi_cf_reader self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_multi_cf_reader_set_t_value(self, i, v)

    def set_t_values(self, *args):
        r"""
        set_t_values(teca_multi_cf_reader self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_t_values(teca_multi_cf_reader self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_multi_cf_reader_set_t_values(self, *args)

    def get_t_value(self, i):
        r"""
        get_t_value(teca_multi_cf_reader self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_multi_cf_reader_get_t_value(self, i)

    def get_t_values(self):
        r"""get_t_values(teca_multi_cf_reader self) -> std_vector_double"""
        return _teca_py.teca_multi_cf_reader_get_t_values(self)

    def clear_t_values(self):
        r"""clear_t_values(teca_multi_cf_reader self)"""
        return _teca_py.teca_multi_cf_reader_clear_t_values(self)

    def set_max_metadata_ranks(self, v):
        r"""
        set_max_metadata_ranks(teca_multi_cf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_multi_cf_reader_set_max_metadata_ranks(self, v)

    def get_max_metadata_ranks(self):
        r"""get_max_metadata_ranks(teca_multi_cf_reader self) -> int const &"""
        return _teca_py.teca_multi_cf_reader_get_max_metadata_ranks(self)

    def set_clamp_dimensions_of_one(self, flag):
        r"""
        set_clamp_dimensions_of_one(teca_multi_cf_reader self, int flag)

        Parameters
        ----------
        flag: int

        """
        return _teca_py.teca_multi_cf_reader_set_clamp_dimensions_of_one(self, flag)

    def get_clamp_dimensions_of_one(self):
        r"""get_clamp_dimensions_of_one(teca_multi_cf_reader self) -> int"""
        return _teca_py.teca_multi_cf_reader_get_clamp_dimensions_of_one(self)

    def set_target_bounds(self, bounds):
        r"""
        set_target_bounds(teca_multi_cf_reader self, std_vector_double bounds)

        Parameters
        ----------
        bounds: std::vector< double,std::allocator< double > > const &

        """
        return _teca_py.teca_multi_cf_reader_set_target_bounds(self, bounds)

    def get_target_bounds(self):
        r"""get_target_bounds(teca_multi_cf_reader self) -> std_vector_double"""
        return _teca_py.teca_multi_cf_reader_get_target_bounds(self)

    def set_target_x_axis_variable(self, flag):
        r"""
        set_target_x_axis_variable(teca_multi_cf_reader self, std::string const & flag)

        Parameters
        ----------
        flag: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_target_x_axis_variable(self, flag)

    def get_target_x_axis_variable(self):
        r"""get_target_x_axis_variable(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_target_x_axis_variable(self)

    def set_target_y_axis_variable(self, flag):
        r"""
        set_target_y_axis_variable(teca_multi_cf_reader self, std::string const & flag)

        Parameters
        ----------
        flag: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_target_y_axis_variable(self, flag)

    def get_target_y_axis_variable(self):
        r"""get_target_y_axis_variable(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_target_y_axis_variable(self)

    def set_target_z_axis_variable(self, flag):
        r"""
        set_target_z_axis_variable(teca_multi_cf_reader self, std::string const & flag)

        Parameters
        ----------
        flag: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_target_z_axis_variable(self, flag)

    def get_target_z_axis_variable(self):
        r"""get_target_z_axis_variable(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_target_z_axis_variable(self)

    def set_target_x_axis_units(self, flag):
        r"""
        set_target_x_axis_units(teca_multi_cf_reader self, std::string const & flag)

        Parameters
        ----------
        flag: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_target_x_axis_units(self, flag)

    def get_target_x_axis_units(self):
        r"""get_target_x_axis_units(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_target_x_axis_units(self)

    def set_target_y_axis_units(self, flag):
        r"""
        set_target_y_axis_units(teca_multi_cf_reader self, std::string const & flag)

        Parameters
        ----------
        flag: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_target_y_axis_units(self, flag)

    def get_target_y_axis_units(self):
        r"""get_target_y_axis_units(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_target_y_axis_units(self)

    def set_target_z_axis_units(self, flag):
        r"""
        set_target_z_axis_units(teca_multi_cf_reader self, std::string const & flag)

        Parameters
        ----------
        flag: std::string const &

        """
        return _teca_py.teca_multi_cf_reader_set_target_z_axis_units(self, flag)

    def get_target_z_axis_units(self):
        r"""get_target_z_axis_units(teca_multi_cf_reader self) -> std::string"""
        return _teca_py.teca_multi_cf_reader_get_target_z_axis_units(self)

    def set_validate_time_axis(self, v):
        r"""
        set_validate_time_axis(teca_multi_cf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_multi_cf_reader_set_validate_time_axis(self, v)

    def get_validate_time_axis(self):
        r"""get_validate_time_axis(teca_multi_cf_reader self) -> int const &"""
        return _teca_py.teca_multi_cf_reader_get_validate_time_axis(self)

    def set_validate_spatial_coordinates(self, v):
        r"""
        set_validate_spatial_coordinates(teca_multi_cf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_multi_cf_reader_set_validate_spatial_coordinates(self, v)

    def get_validate_spatial_coordinates(self):
        r"""get_validate_spatial_coordinates(teca_multi_cf_reader self) -> int const &"""
        return _teca_py.teca_multi_cf_reader_get_validate_spatial_coordinates(self)

    def get_variables(self):
        r"""get_variables(teca_multi_cf_reader self) -> PyObject *"""
        return _teca_py.teca_multi_cf_reader_get_variables(self)

# Register teca_multi_cf_reader in _teca_py:
_teca_py.teca_multi_cf_reader_swigregister(teca_multi_cf_reader)

def teca_multi_cf_reader_New():
    r"""teca_multi_cf_reader_New() -> p_teca_multi_cf_reader"""
    return _teca_py.teca_multi_cf_reader_New()

class teca_wrf_reader(teca_algorithm):
    r"""Proxy of C++ teca_wrf_reader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_wrf_reader"""
        return _teca_py.teca_wrf_reader_New()

    def get_class_name(self):
        r"""get_class_name(teca_wrf_reader self) -> char const *"""
        return _teca_py.teca_wrf_reader_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_wrf_reader

    def get_number_of_file_names(self):
        r"""get_number_of_file_names(teca_wrf_reader self) -> size_t"""
        return _teca_py.teca_wrf_reader_get_number_of_file_names(self)

    def append_file_name(self, v):
        r"""
        append_file_name(teca_wrf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_wrf_reader_append_file_name(self, v)

    def set_file_name(self, i, v):
        r"""
        set_file_name(teca_wrf_reader self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_wrf_reader_set_file_name(self, i, v)

    def set_file_names(self, *args):
        r"""
        set_file_names(teca_wrf_reader self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_file_names(teca_wrf_reader self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_wrf_reader_set_file_names(self, *args)

    def get_file_name(self, i):
        r"""
        get_file_name(teca_wrf_reader self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_wrf_reader_get_file_name(self, i)

    def get_file_names(self):
        r"""get_file_names(teca_wrf_reader self) -> std_vector_string"""
        return _teca_py.teca_wrf_reader_get_file_names(self)

    def clear_file_names(self):
        r"""clear_file_names(teca_wrf_reader self)"""
        return _teca_py.teca_wrf_reader_clear_file_names(self)

    def set_files_regex(self, v):
        r"""
        set_files_regex(teca_wrf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_wrf_reader_set_files_regex(self, v)

    def get_files_regex(self):
        r"""get_files_regex(teca_wrf_reader self) -> std::string const &"""
        return _teca_py.teca_wrf_reader_get_files_regex(self)

    def set_metadata_cache_dir(self, v):
        r"""
        set_metadata_cache_dir(teca_wrf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_wrf_reader_set_metadata_cache_dir(self, v)

    def get_metadata_cache_dir(self):
        r"""get_metadata_cache_dir(teca_wrf_reader self) -> std::string const &"""
        return _teca_py.teca_wrf_reader_get_metadata_cache_dir(self)

    def set_periodic_in_x(self, v):
        r"""
        set_periodic_in_x(teca_wrf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_wrf_reader_set_periodic_in_x(self, v)

    def get_periodic_in_x(self):
        r"""get_periodic_in_x(teca_wrf_reader self) -> int const &"""
        return _teca_py.teca_wrf_reader_get_periodic_in_x(self)

    def set_periodic_in_y(self, v):
        r"""
        set_periodic_in_y(teca_wrf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_wrf_reader_set_periodic_in_y(self, v)

    def get_periodic_in_y(self):
        r"""get_periodic_in_y(teca_wrf_reader self) -> int const &"""
        return _teca_py.teca_wrf_reader_get_periodic_in_y(self)

    def set_periodic_in_z(self, v):
        r"""
        set_periodic_in_z(teca_wrf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_wrf_reader_set_periodic_in_z(self, v)

    def get_periodic_in_z(self):
        r"""get_periodic_in_z(teca_wrf_reader self) -> int const &"""
        return _teca_py.teca_wrf_reader_get_periodic_in_z(self)

    def set_calendar(self, v):
        r"""
        set_calendar(teca_wrf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_wrf_reader_set_calendar(self, v)

    def get_calendar(self):
        r"""get_calendar(teca_wrf_reader self) -> std::string const &"""
        return _teca_py.teca_wrf_reader_get_calendar(self)

    def set_t_units(self, v):
        r"""
        set_t_units(teca_wrf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_wrf_reader_set_t_units(self, v)

    def get_t_units(self):
        r"""get_t_units(teca_wrf_reader self) -> std::string const &"""
        return _teca_py.teca_wrf_reader_get_t_units(self)

    def set_filename_time_template(self, v):
        r"""
        set_filename_time_template(teca_wrf_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_wrf_reader_set_filename_time_template(self, v)

    def get_filename_time_template(self):
        r"""get_filename_time_template(teca_wrf_reader self) -> std::string const &"""
        return _teca_py.teca_wrf_reader_get_filename_time_template(self)

    def get_number_of_t_values(self):
        r"""get_number_of_t_values(teca_wrf_reader self) -> size_t"""
        return _teca_py.teca_wrf_reader_get_number_of_t_values(self)

    def append_t_value(self, v):
        r"""
        append_t_value(teca_wrf_reader self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_wrf_reader_append_t_value(self, v)

    def set_t_value(self, i, v):
        r"""
        set_t_value(teca_wrf_reader self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_wrf_reader_set_t_value(self, i, v)

    def set_t_values(self, *args):
        r"""
        set_t_values(teca_wrf_reader self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_t_values(teca_wrf_reader self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_wrf_reader_set_t_values(self, *args)

    def get_t_value(self, i):
        r"""
        get_t_value(teca_wrf_reader self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_wrf_reader_get_t_value(self, i)

    def get_t_values(self):
        r"""get_t_values(teca_wrf_reader self) -> std_vector_double"""
        return _teca_py.teca_wrf_reader_get_t_values(self)

    def clear_t_values(self):
        r"""clear_t_values(teca_wrf_reader self)"""
        return _teca_py.teca_wrf_reader_clear_t_values(self)

    def set_thread_pool_size(self, v):
        r"""
        set_thread_pool_size(teca_wrf_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_wrf_reader_set_thread_pool_size(self, v)

    def get_thread_pool_size(self):
        r"""get_thread_pool_size(teca_wrf_reader self) -> int const &"""
        return _teca_py.teca_wrf_reader_get_thread_pool_size(self)

# Register teca_wrf_reader in _teca_py:
_teca_py.teca_wrf_reader_swigregister(teca_wrf_reader)

def teca_wrf_reader_New():
    r"""teca_wrf_reader_New() -> p_teca_wrf_reader"""
    return _teca_py.teca_wrf_reader_New()

class teca_array_collection_reader(teca_algorithm):
    r"""Proxy of C++ teca_array_collection_reader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_array_collection_reader"""
        return _teca_py.teca_array_collection_reader_New()

    def get_class_name(self):
        r"""get_class_name(teca_array_collection_reader self) -> char const *"""
        return _teca_py.teca_array_collection_reader_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_array_collection_reader

    def get_number_of_file_names(self):
        r"""get_number_of_file_names(teca_array_collection_reader self) -> size_t"""
        return _teca_py.teca_array_collection_reader_get_number_of_file_names(self)

    def append_file_name(self, v):
        r"""
        append_file_name(teca_array_collection_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_array_collection_reader_append_file_name(self, v)

    def set_file_name(self, i, v):
        r"""
        set_file_name(teca_array_collection_reader self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_array_collection_reader_set_file_name(self, i, v)

    def set_file_names(self, *args):
        r"""
        set_file_names(teca_array_collection_reader self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_file_names(teca_array_collection_reader self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_array_collection_reader_set_file_names(self, *args)

    def get_file_name(self, i):
        r"""
        get_file_name(teca_array_collection_reader self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_array_collection_reader_get_file_name(self, i)

    def get_file_names(self):
        r"""get_file_names(teca_array_collection_reader self) -> std_vector_string"""
        return _teca_py.teca_array_collection_reader_get_file_names(self)

    def clear_file_names(self):
        r"""clear_file_names(teca_array_collection_reader self)"""
        return _teca_py.teca_array_collection_reader_clear_file_names(self)

    def set_files_regex(self, v):
        r"""
        set_files_regex(teca_array_collection_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_array_collection_reader_set_files_regex(self, v)

    def get_files_regex(self):
        r"""get_files_regex(teca_array_collection_reader self) -> std::string const &"""
        return _teca_py.teca_array_collection_reader_get_files_regex(self)

    def set_t_axis_variable(self, v):
        r"""
        set_t_axis_variable(teca_array_collection_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_array_collection_reader_set_t_axis_variable(self, v)

    def get_t_axis_variable(self):
        r"""get_t_axis_variable(teca_array_collection_reader self) -> std::string const &"""
        return _teca_py.teca_array_collection_reader_get_t_axis_variable(self)

    def set_calendar(self, v):
        r"""
        set_calendar(teca_array_collection_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_array_collection_reader_set_calendar(self, v)

    def get_calendar(self):
        r"""get_calendar(teca_array_collection_reader self) -> std::string const &"""
        return _teca_py.teca_array_collection_reader_get_calendar(self)

    def set_t_units(self, v):
        r"""
        set_t_units(teca_array_collection_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_array_collection_reader_set_t_units(self, v)

    def get_t_units(self):
        r"""get_t_units(teca_array_collection_reader self) -> std::string const &"""
        return _teca_py.teca_array_collection_reader_get_t_units(self)

    def set_filename_time_template(self, v):
        r"""
        set_filename_time_template(teca_array_collection_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_array_collection_reader_set_filename_time_template(self, v)

    def get_filename_time_template(self):
        r"""get_filename_time_template(teca_array_collection_reader self) -> std::string const &"""
        return _teca_py.teca_array_collection_reader_get_filename_time_template(self)

    def get_number_of_t_values(self):
        r"""get_number_of_t_values(teca_array_collection_reader self) -> size_t"""
        return _teca_py.teca_array_collection_reader_get_number_of_t_values(self)

    def append_t_value(self, v):
        r"""
        append_t_value(teca_array_collection_reader self, double const & v)

        Parameters
        ----------
        v: double const &

        """
        return _teca_py.teca_array_collection_reader_append_t_value(self, v)

    def set_t_value(self, i, v):
        r"""
        set_t_value(teca_array_collection_reader self, size_t i, double const & v)

        Parameters
        ----------
        i: size_t
        v: double const &

        """
        return _teca_py.teca_array_collection_reader_set_t_value(self, i, v)

    def set_t_values(self, *args):
        r"""
        set_t_values(teca_array_collection_reader self, std_vector_double v)

        Parameters
        ----------
        v: std::vector< double,std::allocator< double > > const &

        set_t_values(teca_array_collection_reader self, std::initializer_list< double > const && l)

        Parameters
        ----------
        l: std::initializer_list< double > const &&

        """
        return _teca_py.teca_array_collection_reader_set_t_values(self, *args)

    def get_t_value(self, i):
        r"""
        get_t_value(teca_array_collection_reader self, size_t i) -> double const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_array_collection_reader_get_t_value(self, i)

    def get_t_values(self):
        r"""get_t_values(teca_array_collection_reader self) -> std_vector_double"""
        return _teca_py.teca_array_collection_reader_get_t_values(self)

    def clear_t_values(self):
        r"""clear_t_values(teca_array_collection_reader self)"""
        return _teca_py.teca_array_collection_reader_clear_t_values(self)

# Register teca_array_collection_reader in _teca_py:
_teca_py.teca_array_collection_reader_swigregister(teca_array_collection_reader)

def teca_array_collection_reader_New():
    r"""teca_array_collection_reader_New() -> p_teca_array_collection_reader"""
    return _teca_py.teca_array_collection_reader_New()

class teca_cf_writer(teca_threaded_algorithm):
    r"""Proxy of C++ teca_cf_writer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_cf_writer"""
        return _teca_py.teca_cf_writer_New()

    def get_class_name(self):
        r"""get_class_name(teca_cf_writer self) -> char const *"""
        return _teca_py.teca_cf_writer_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_cf_writer

    def set_file_name(self, v):
        r"""
        set_file_name(teca_cf_writer self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_writer_set_file_name(self, v)

    def get_file_name(self):
        r"""get_file_name(teca_cf_writer self) -> std::string const &"""
        return _teca_py.teca_cf_writer_get_file_name(self)

    def set_date_format(self, v):
        r"""
        set_date_format(teca_cf_writer self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_writer_set_date_format(self, v)

    def get_date_format(self):
        r"""get_date_format(teca_cf_writer self) -> std::string const &"""
        return _teca_py.teca_cf_writer_get_date_format(self)

    def set_first_step(self, v):
        r"""
        set_first_step(teca_cf_writer self, long const & v)

        Parameters
        ----------
        v: long const &

        """
        return _teca_py.teca_cf_writer_set_first_step(self, v)

    def get_first_step(self):
        r"""get_first_step(teca_cf_writer self) -> long const &"""
        return _teca_py.teca_cf_writer_get_first_step(self)

    def set_last_step(self, v):
        r"""
        set_last_step(teca_cf_writer self, long const & v)

        Parameters
        ----------
        v: long const &

        """
        return _teca_py.teca_cf_writer_set_last_step(self, v)

    def get_last_step(self):
        r"""get_last_step(teca_cf_writer self) -> long const &"""
        return _teca_py.teca_cf_writer_get_last_step(self)
    invalid = _teca_py.teca_cf_writer_invalid
    
    number_of_steps = _teca_py.teca_cf_writer_number_of_steps
    
    daily = _teca_py.teca_cf_writer_daily
    
    monthly = _teca_py.teca_cf_writer_monthly
    
    seasonal = _teca_py.teca_cf_writer_seasonal
    
    yearly = _teca_py.teca_cf_writer_yearly
    

    def get_layout(self):
        r"""get_layout(teca_cf_writer self) -> int const &"""
        return _teca_py.teca_cf_writer_get_layout(self)

    def set_layout_to_number_of_steps(self):
        r"""set_layout_to_number_of_steps(teca_cf_writer self)"""
        return _teca_py.teca_cf_writer_set_layout_to_number_of_steps(self)

    def set_layout_to_daily(self):
        r"""set_layout_to_daily(teca_cf_writer self)"""
        return _teca_py.teca_cf_writer_set_layout_to_daily(self)

    def set_layout_to_monthly(self):
        r"""set_layout_to_monthly(teca_cf_writer self)"""
        return _teca_py.teca_cf_writer_set_layout_to_monthly(self)

    def set_layout_to_seasonal(self):
        r"""set_layout_to_seasonal(teca_cf_writer self)"""
        return _teca_py.teca_cf_writer_set_layout_to_seasonal(self)

    def set_layout_to_yearly(self):
        r"""set_layout_to_yearly(teca_cf_writer self)"""
        return _teca_py.teca_cf_writer_set_layout_to_yearly(self)

    def set_layout(self, *args):
        r"""
        set_layout(teca_cf_writer self, int const & v)

        Parameters
        ----------
        v: int const &

        set_layout(teca_cf_writer self, std::string const & layout) -> int

        Parameters
        ----------
        layout: std::string const &

        """
        return _teca_py.teca_cf_writer_set_layout(self, *args)

    def validate_layout(self, mode):
        r"""
        validate_layout(teca_cf_writer self, int mode) -> int

        Parameters
        ----------
        mode: int

        """
        return _teca_py.teca_cf_writer_validate_layout(self, mode)

    def set_steps_per_file(self, v):
        r"""
        set_steps_per_file(teca_cf_writer self, unsigned int const & v)

        Parameters
        ----------
        v: unsigned int const &

        """
        return _teca_py.teca_cf_writer_set_steps_per_file(self, v)

    def get_steps_per_file(self):
        r"""get_steps_per_file(teca_cf_writer self) -> unsigned int const &"""
        return _teca_py.teca_cf_writer_get_steps_per_file(self)

    def set_mode_flags(self, v):
        r"""
        set_mode_flags(teca_cf_writer self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cf_writer_set_mode_flags(self, v)

    def get_mode_flags(self):
        r"""get_mode_flags(teca_cf_writer self) -> int const &"""
        return _teca_py.teca_cf_writer_get_mode_flags(self)

    def set_use_unlimited_dim(self, v):
        r"""
        set_use_unlimited_dim(teca_cf_writer self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cf_writer_set_use_unlimited_dim(self, v)

    def get_use_unlimited_dim(self):
        r"""get_use_unlimited_dim(teca_cf_writer self) -> int const &"""
        return _teca_py.teca_cf_writer_get_use_unlimited_dim(self)

    def set_compression_level(self, v):
        r"""
        set_compression_level(teca_cf_writer self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cf_writer_set_compression_level(self, v)

    def get_compression_level(self):
        r"""get_compression_level(teca_cf_writer self) -> int const &"""
        return _teca_py.teca_cf_writer_get_compression_level(self)

    def set_flush_files(self, v):
        r"""
        set_flush_files(teca_cf_writer self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cf_writer_set_flush_files(self, v)

    def get_flush_files(self):
        r"""get_flush_files(teca_cf_writer self) -> int const &"""
        return _teca_py.teca_cf_writer_get_flush_files(self)

    def get_number_of_point_arrays(self):
        r"""get_number_of_point_arrays(teca_cf_writer self) -> size_t"""
        return _teca_py.teca_cf_writer_get_number_of_point_arrays(self)

    def append_point_array(self, v):
        r"""
        append_point_array(teca_cf_writer self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_writer_append_point_array(self, v)

    def set_point_array(self, i, v):
        r"""
        set_point_array(teca_cf_writer self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_cf_writer_set_point_array(self, i, v)

    def set_point_arrays(self, *args):
        r"""
        set_point_arrays(teca_cf_writer self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_point_arrays(teca_cf_writer self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_cf_writer_set_point_arrays(self, *args)

    def get_point_array(self, i):
        r"""
        get_point_array(teca_cf_writer self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cf_writer_get_point_array(self, i)

    def get_point_arrays(self):
        r"""get_point_arrays(teca_cf_writer self) -> std_vector_string"""
        return _teca_py.teca_cf_writer_get_point_arrays(self)

    def clear_point_arrays(self):
        r"""clear_point_arrays(teca_cf_writer self)"""
        return _teca_py.teca_cf_writer_clear_point_arrays(self)

    def get_number_of_information_arrays(self):
        r"""get_number_of_information_arrays(teca_cf_writer self) -> size_t"""
        return _teca_py.teca_cf_writer_get_number_of_information_arrays(self)

    def append_information_array(self, v):
        r"""
        append_information_array(teca_cf_writer self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cf_writer_append_information_array(self, v)

    def set_information_array(self, i, v):
        r"""
        set_information_array(teca_cf_writer self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_cf_writer_set_information_array(self, i, v)

    def set_information_arrays(self, *args):
        r"""
        set_information_arrays(teca_cf_writer self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_information_arrays(teca_cf_writer self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_cf_writer_set_information_arrays(self, *args)

    def get_information_array(self, i):
        r"""
        get_information_array(teca_cf_writer self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cf_writer_get_information_array(self, i)

    def get_information_arrays(self):
        r"""get_information_arrays(teca_cf_writer self) -> std_vector_string"""
        return _teca_py.teca_cf_writer_get_information_arrays(self)

    def clear_information_arrays(self):
        r"""clear_information_arrays(teca_cf_writer self)"""
        return _teca_py.teca_cf_writer_clear_information_arrays(self)

# Register teca_cf_writer in _teca_py:
_teca_py.teca_cf_writer_swigregister(teca_cf_writer)

def teca_cf_writer_New():
    r"""teca_cf_writer_New() -> p_teca_cf_writer"""
    return _teca_py.teca_cf_writer_New()

class teca_table_reader(teca_algorithm):
    r"""Proxy of C++ teca_table_reader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table_reader"""
        return _teca_py.teca_table_reader_New()

    def get_class_name(self):
        r"""get_class_name(teca_table_reader self) -> char const *"""
        return _teca_py.teca_table_reader_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_table_reader

    def set_file_name(self, v):
        r"""
        set_file_name(teca_table_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_reader_set_file_name(self, v)

    def get_file_name(self):
        r"""get_file_name(teca_table_reader self) -> std::string const &"""
        return _teca_py.teca_table_reader_get_file_name(self)

    def set_index_column(self, v):
        r"""
        set_index_column(teca_table_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_reader_set_index_column(self, v)

    def get_index_column(self):
        r"""get_index_column(teca_table_reader self) -> std::string const &"""
        return _teca_py.teca_table_reader_get_index_column(self)

    def set_generate_original_ids(self, v):
        r"""
        set_generate_original_ids(teca_table_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_table_reader_set_generate_original_ids(self, v)

    def get_generate_original_ids(self):
        r"""get_generate_original_ids(teca_table_reader self) -> int const &"""
        return _teca_py.teca_table_reader_get_generate_original_ids(self)

    def get_number_of_metadata_column_names(self):
        r"""get_number_of_metadata_column_names(teca_table_reader self) -> size_t"""
        return _teca_py.teca_table_reader_get_number_of_metadata_column_names(self)

    def append_metadata_column_name(self, v):
        r"""
        append_metadata_column_name(teca_table_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_reader_append_metadata_column_name(self, v)

    def set_metadata_column_name(self, i, v):
        r"""
        set_metadata_column_name(teca_table_reader self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_table_reader_set_metadata_column_name(self, i, v)

    def set_metadata_column_names(self, *args):
        r"""
        set_metadata_column_names(teca_table_reader self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_metadata_column_names(teca_table_reader self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_table_reader_set_metadata_column_names(self, *args)

    def get_metadata_column_name(self, i):
        r"""
        get_metadata_column_name(teca_table_reader self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_table_reader_get_metadata_column_name(self, i)

    def get_metadata_column_names(self):
        r"""get_metadata_column_names(teca_table_reader self) -> std_vector_string"""
        return _teca_py.teca_table_reader_get_metadata_column_names(self)

    def clear_metadata_column_names(self):
        r"""clear_metadata_column_names(teca_table_reader self)"""
        return _teca_py.teca_table_reader_clear_metadata_column_names(self)

    def get_number_of_metadata_column_keys(self):
        r"""get_number_of_metadata_column_keys(teca_table_reader self) -> size_t"""
        return _teca_py.teca_table_reader_get_number_of_metadata_column_keys(self)

    def append_metadata_column_key(self, v):
        r"""
        append_metadata_column_key(teca_table_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_reader_append_metadata_column_key(self, v)

    def set_metadata_column_key(self, i, v):
        r"""
        set_metadata_column_key(teca_table_reader self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_table_reader_set_metadata_column_key(self, i, v)

    def set_metadata_column_keys(self, *args):
        r"""
        set_metadata_column_keys(teca_table_reader self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_metadata_column_keys(teca_table_reader self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_table_reader_set_metadata_column_keys(self, *args)

    def get_metadata_column_key(self, i):
        r"""
        get_metadata_column_key(teca_table_reader self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_table_reader_get_metadata_column_key(self, i)

    def get_metadata_column_keys(self):
        r"""get_metadata_column_keys(teca_table_reader self) -> std_vector_string"""
        return _teca_py.teca_table_reader_get_metadata_column_keys(self)

    def clear_metadata_column_keys(self):
        r"""clear_metadata_column_keys(teca_table_reader self)"""
        return _teca_py.teca_table_reader_clear_metadata_column_keys(self)

    def add_metadata_column(self, column, key):
        r"""
        add_metadata_column(teca_table_reader self, std::string const & column, std::string const & key)

        Parameters
        ----------
        column: std::string const &
        key: std::string const &

        """
        return _teca_py.teca_table_reader_add_metadata_column(self, column, key)

    def clear_metadata_columns(self):
        r"""clear_metadata_columns(teca_table_reader self)"""
        return _teca_py.teca_table_reader_clear_metadata_columns(self)
    format_csv = _teca_py.teca_table_reader_format_csv
    
    format_bin = _teca_py.teca_table_reader_format_bin
    
    format_xlsx = _teca_py.teca_table_reader_format_xlsx
    
    format_auto = _teca_py.teca_table_reader_format_auto
    

    def set_file_format(self, v):
        r"""
        set_file_format(teca_table_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_table_reader_set_file_format(self, v)

    def get_file_format(self):
        r"""get_file_format(teca_table_reader self) -> int const &"""
        return _teca_py.teca_table_reader_get_file_format(self)

    def set_file_format_csv(self):
        r"""set_file_format_csv(teca_table_reader self)"""
        return _teca_py.teca_table_reader_set_file_format_csv(self)

    def set_file_format_bin(self):
        r"""set_file_format_bin(teca_table_reader self)"""
        return _teca_py.teca_table_reader_set_file_format_bin(self)

    def set_file_format_xlsx(self):
        r"""set_file_format_xlsx(teca_table_reader self)"""
        return _teca_py.teca_table_reader_set_file_format_xlsx(self)

    def set_file_format_auto(self):
        r"""set_file_format_auto(teca_table_reader self)"""
        return _teca_py.teca_table_reader_set_file_format_auto(self)

# Register teca_table_reader in _teca_py:
_teca_py.teca_table_reader_swigregister(teca_table_reader)

def teca_table_reader_New():
    r"""teca_table_reader_New() -> p_teca_table_reader"""
    return _teca_py.teca_table_reader_New()

class teca_table_writer(teca_algorithm):
    r"""Proxy of C++ teca_table_writer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_table_writer"""
        return _teca_py.teca_table_writer_New()

    def get_class_name(self):
        r"""get_class_name(teca_table_writer self) -> char const *"""
        return _teca_py.teca_table_writer_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_table_writer

    def set_file_name(self, v):
        r"""
        set_file_name(teca_table_writer self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_writer_set_file_name(self, v)

    def get_file_name(self):
        r"""get_file_name(teca_table_writer self) -> std::string const &"""
        return _teca_py.teca_table_writer_get_file_name(self)

    def set_row_dim_name(self, v):
        r"""
        set_row_dim_name(teca_table_writer self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_table_writer_set_row_dim_name(self, v)

    def get_row_dim_name(self):
        r"""get_row_dim_name(teca_table_writer self) -> std::string const &"""
        return _teca_py.teca_table_writer_get_row_dim_name(self)
    format_auto = _teca_py.teca_table_writer_format_auto
    
    format_csv = _teca_py.teca_table_writer_format_csv
    
    format_bin = _teca_py.teca_table_writer_format_bin
    
    format_xlsx = _teca_py.teca_table_writer_format_xlsx
    
    format_netcdf = _teca_py.teca_table_writer_format_netcdf
    

    def set_output_format(self, v):
        r"""
        set_output_format(teca_table_writer self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_table_writer_set_output_format(self, v)

    def get_output_format(self):
        r"""get_output_format(teca_table_writer self) -> int const &"""
        return _teca_py.teca_table_writer_get_output_format(self)

    def set_output_format_auto(self):
        r"""set_output_format_auto(teca_table_writer self)"""
        return _teca_py.teca_table_writer_set_output_format_auto(self)

    def set_output_format_csv(self):
        r"""set_output_format_csv(teca_table_writer self)"""
        return _teca_py.teca_table_writer_set_output_format_csv(self)

    def set_output_format_bin(self):
        r"""set_output_format_bin(teca_table_writer self)"""
        return _teca_py.teca_table_writer_set_output_format_bin(self)

    def set_output_format_xlsx(self):
        r"""set_output_format_xlsx(teca_table_writer self)"""
        return _teca_py.teca_table_writer_set_output_format_xlsx(self)

    def set_output_format_netcdf(self):
        r"""set_output_format_netcdf(teca_table_writer self)"""
        return _teca_py.teca_table_writer_set_output_format_netcdf(self)

# Register teca_table_writer in _teca_py:
_teca_py.teca_table_writer_swigregister(teca_table_writer)

def teca_table_writer_New():
    r"""teca_table_writer_New() -> p_teca_table_writer"""
    return _teca_py.teca_table_writer_New()

class teca_cartesian_mesh_reader(teca_algorithm):
    r"""Proxy of C++ teca_cartesian_mesh_reader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_cartesian_mesh_reader"""
        return _teca_py.teca_cartesian_mesh_reader_New()

    def get_class_name(self):
        r"""get_class_name(teca_cartesian_mesh_reader self) -> char const *"""
        return _teca_py.teca_cartesian_mesh_reader_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_cartesian_mesh_reader

    def set_file_name(self, v):
        r"""
        set_file_name(teca_cartesian_mesh_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_reader_set_file_name(self, v)

    def get_file_name(self):
        r"""get_file_name(teca_cartesian_mesh_reader self) -> std::string const &"""
        return _teca_py.teca_cartesian_mesh_reader_get_file_name(self)

    def set_index_column(self, v):
        r"""
        set_index_column(teca_cartesian_mesh_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_reader_set_index_column(self, v)

    def get_index_column(self):
        r"""get_index_column(teca_cartesian_mesh_reader self) -> std::string const &"""
        return _teca_py.teca_cartesian_mesh_reader_get_index_column(self)

    def set_generate_original_ids(self, v):
        r"""
        set_generate_original_ids(teca_cartesian_mesh_reader self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cartesian_mesh_reader_set_generate_original_ids(self, v)

    def get_generate_original_ids(self):
        r"""get_generate_original_ids(teca_cartesian_mesh_reader self) -> int const &"""
        return _teca_py.teca_cartesian_mesh_reader_get_generate_original_ids(self)

    def get_number_of_metadata_column_names(self):
        r"""get_number_of_metadata_column_names(teca_cartesian_mesh_reader self) -> size_t"""
        return _teca_py.teca_cartesian_mesh_reader_get_number_of_metadata_column_names(self)

    def append_metadata_column_name(self, v):
        r"""
        append_metadata_column_name(teca_cartesian_mesh_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_reader_append_metadata_column_name(self, v)

    def set_metadata_column_name(self, i, v):
        r"""
        set_metadata_column_name(teca_cartesian_mesh_reader self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_reader_set_metadata_column_name(self, i, v)

    def set_metadata_column_names(self, *args):
        r"""
        set_metadata_column_names(teca_cartesian_mesh_reader self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_metadata_column_names(teca_cartesian_mesh_reader self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_cartesian_mesh_reader_set_metadata_column_names(self, *args)

    def get_metadata_column_name(self, i):
        r"""
        get_metadata_column_name(teca_cartesian_mesh_reader self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cartesian_mesh_reader_get_metadata_column_name(self, i)

    def get_metadata_column_names(self):
        r"""get_metadata_column_names(teca_cartesian_mesh_reader self) -> std_vector_string"""
        return _teca_py.teca_cartesian_mesh_reader_get_metadata_column_names(self)

    def clear_metadata_column_names(self):
        r"""clear_metadata_column_names(teca_cartesian_mesh_reader self)"""
        return _teca_py.teca_cartesian_mesh_reader_clear_metadata_column_names(self)

    def get_number_of_metadata_column_keys(self):
        r"""get_number_of_metadata_column_keys(teca_cartesian_mesh_reader self) -> size_t"""
        return _teca_py.teca_cartesian_mesh_reader_get_number_of_metadata_column_keys(self)

    def append_metadata_column_key(self, v):
        r"""
        append_metadata_column_key(teca_cartesian_mesh_reader self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_reader_append_metadata_column_key(self, v)

    def set_metadata_column_key(self, i, v):
        r"""
        set_metadata_column_key(teca_cartesian_mesh_reader self, size_t i, std::string const & v)

        Parameters
        ----------
        i: size_t
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_reader_set_metadata_column_key(self, i, v)

    def set_metadata_column_keys(self, *args):
        r"""
        set_metadata_column_keys(teca_cartesian_mesh_reader self, std_vector_string v)

        Parameters
        ----------
        v: std::vector< std::string,std::allocator< std::string > > const &

        set_metadata_column_keys(teca_cartesian_mesh_reader self, std::initializer_list< std::string > const && l)

        Parameters
        ----------
        l: std::initializer_list< std::string > const &&

        """
        return _teca_py.teca_cartesian_mesh_reader_set_metadata_column_keys(self, *args)

    def get_metadata_column_key(self, i):
        r"""
        get_metadata_column_key(teca_cartesian_mesh_reader self, size_t i) -> std::string const &

        Parameters
        ----------
        i: size_t

        """
        return _teca_py.teca_cartesian_mesh_reader_get_metadata_column_key(self, i)

    def get_metadata_column_keys(self):
        r"""get_metadata_column_keys(teca_cartesian_mesh_reader self) -> std_vector_string"""
        return _teca_py.teca_cartesian_mesh_reader_get_metadata_column_keys(self)

    def clear_metadata_column_keys(self):
        r"""clear_metadata_column_keys(teca_cartesian_mesh_reader self)"""
        return _teca_py.teca_cartesian_mesh_reader_clear_metadata_column_keys(self)

    def add_metadata_column(self, column, key):
        r"""
        add_metadata_column(teca_cartesian_mesh_reader self, std::string const & column, std::string const & key)

        Parameters
        ----------
        column: std::string const &
        key: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_reader_add_metadata_column(self, column, key)

    def clear_metadata_columns(self):
        r"""clear_metadata_columns(teca_cartesian_mesh_reader self)"""
        return _teca_py.teca_cartesian_mesh_reader_clear_metadata_columns(self)

# Register teca_cartesian_mesh_reader in _teca_py:
_teca_py.teca_cartesian_mesh_reader_swigregister(teca_cartesian_mesh_reader)

def teca_cartesian_mesh_reader_New():
    r"""teca_cartesian_mesh_reader_New() -> p_teca_cartesian_mesh_reader"""
    return _teca_py.teca_cartesian_mesh_reader_New()

class teca_cartesian_mesh_writer(teca_algorithm):
    r"""Proxy of C++ teca_cartesian_mesh_writer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New():
        r"""New() -> p_teca_cartesian_mesh_writer"""
        return _teca_py.teca_cartesian_mesh_writer_New()

    def get_class_name(self):
        r"""get_class_name(teca_cartesian_mesh_writer self) -> char const *"""
        return _teca_py.teca_cartesian_mesh_writer_get_class_name(self)
    __swig_destroy__ = _teca_py.delete_teca_cartesian_mesh_writer

    def set_file_name(self, v):
        r"""
        set_file_name(teca_cartesian_mesh_writer self, std::string const & v)

        Parameters
        ----------
        v: std::string const &

        """
        return _teca_py.teca_cartesian_mesh_writer_set_file_name(self, v)

    def get_file_name(self):
        r"""get_file_name(teca_cartesian_mesh_writer self) -> std::string const &"""
        return _teca_py.teca_cartesian_mesh_writer_get_file_name(self)

    def set_binary(self, v):
        r"""
        set_binary(teca_cartesian_mesh_writer self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cartesian_mesh_writer_set_binary(self, v)

    def get_binary(self):
        r"""get_binary(teca_cartesian_mesh_writer self) -> int const &"""
        return _teca_py.teca_cartesian_mesh_writer_get_binary(self)
    format_bin = _teca_py.teca_cartesian_mesh_writer_format_bin
    
    format_vtk = _teca_py.teca_cartesian_mesh_writer_format_vtk
    
    format_vtr = _teca_py.teca_cartesian_mesh_writer_format_vtr
    
    format_auto = _teca_py.teca_cartesian_mesh_writer_format_auto
    

    def set_output_format(self, v):
        r"""
        set_output_format(teca_cartesian_mesh_writer self, int const & v)

        Parameters
        ----------
        v: int const &

        """
        return _teca_py.teca_cartesian_mesh_writer_set_output_format(self, v)

    def get_output_format(self):
        r"""get_output_format(teca_cartesian_mesh_writer self) -> int const &"""
        return _teca_py.teca_cartesian_mesh_writer_get_output_format(self)

    def set_output_format_bin(self):
        r"""set_output_format_bin(teca_cartesian_mesh_writer self)"""
        return _teca_py.teca_cartesian_mesh_writer_set_output_format_bin(self)

    def set_output_format_vtk(self):
        r"""set_output_format_vtk(teca_cartesian_mesh_writer self)"""
        return _teca_py.teca_cartesian_mesh_writer_set_output_format_vtk(self)

    def set_output_format_vtr(self):
        r"""set_output_format_vtr(teca_cartesian_mesh_writer self)"""
        return _teca_py.teca_cartesian_mesh_writer_set_output_format_vtr(self)

    def set_output_format_auto(self):
        r"""set_output_format_auto(teca_cartesian_mesh_writer self)"""
        return _teca_py.teca_cartesian_mesh_writer_set_output_format_auto(self)

# Register teca_cartesian_mesh_writer in _teca_py:
_teca_py.teca_cartesian_mesh_writer_swigregister(teca_cartesian_mesh_writer)

def teca_cartesian_mesh_writer_New():
    r"""teca_cartesian_mesh_writer_New() -> p_teca_cartesian_mesh_writer"""
    return _teca_py.teca_cartesian_mesh_writer_New()

class file_util(object):
    r"""Proxy of C++ file_util class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def replace_timestep(file_name, time_step, width=6):
        r"""
        replace_timestep(std::string const & file_name, unsigned long time_step, int width=6) -> std::string

        Parameters
        ----------
        file_name: std::string const &
        time_step: unsigned long
        width: int

        """
        return _teca_py.file_util_replace_timestep(file_name, time_step, width)

    @staticmethod
    def replace_time(file_name, t, calendar, units, format):
        r"""
        replace_time(std::string const & file_name, double t, std::string const & calendar, std::string const & units, std::string const & format) -> std::string

        Parameters
        ----------
        file_name: std::string const &
        t: double
        calendar: std::string const &
        units: std::string const &
        format: std::string const &

        """
        return _teca_py.file_util_replace_time(file_name, t, calendar, units, format)

    @staticmethod
    def replace_extension(file_name, ext):
        r"""
        replace_extension(std::string const & file_name, std::string const & ext) -> std::string

        Parameters
        ----------
        file_name: std::string const &
        ext: std::string const &

        """
        return _teca_py.file_util_replace_extension(file_name, ext)

    def __init__(self):
        r"""__init__(file_util self) -> file_util"""
        _teca_py.file_util_swiginit(self, _teca_py.new_file_util())
    __swig_destroy__ = _teca_py.delete_file_util

# Register file_util in _teca_py:
_teca_py.file_util_swigregister(file_util)

def file_util_replace_timestep(file_name, time_step, width=6):
    r"""
    file_util_replace_timestep(std::string const & file_name, unsigned long time_step, int width=6) -> std::string

    Parameters
    ----------
    file_name: std::string const &
    time_step: unsigned long
    width: int

    """
    return _teca_py.file_util_replace_timestep(file_name, time_step, width)

def file_util_replace_time(file_name, t, calendar, units, format):
    r"""
    file_util_replace_time(std::string const & file_name, double t, std::string const & calendar, std::string const & units, std::string const & format) -> std::string

    Parameters
    ----------
    file_name: std::string const &
    t: double
    calendar: std::string const &
    units: std::string const &
    format: std::string const &

    """
    return _teca_py.file_util_replace_time(file_name, t, calendar, units, format)

def file_util_replace_extension(file_name, ext):
    r"""
    file_util_replace_extension(std::string const & file_name, std::string const & ext) -> std::string

    Parameters
    ----------
    file_name: std::string const &
    ext: std::string const &

    """
    return _teca_py.file_util_replace_extension(file_name, ext)


def set_stack_trace_on_error(enable=1):
    r"""
    set_stack_trace_on_error(int enable=1)

    Parameters
    ----------
    enable: int

    """
    return _teca_py.set_stack_trace_on_error(enable)

def set_stack_trace_on_mpi_error(*args):
    r"""
    set_stack_trace_on_mpi_error(MPI_Comm comm=MPI_COMM_WORLD, int enable=1)

    Parameters
    ----------
    comm: MPI_Comm
    enable: int

    """
    return _teca_py.set_stack_trace_on_mpi_error(*args)

def get_program_stack(first_frame, whole_path):
    r"""
    get_program_stack(int first_frame, int whole_path) -> std::string

    Parameters
    ----------
    first_frame: int
    whole_path: int

    """
    return _teca_py.get_program_stack(first_frame, whole_path)

def get_program_name():
    r"""get_program_name() -> std::string"""
    return _teca_py.get_program_name()


